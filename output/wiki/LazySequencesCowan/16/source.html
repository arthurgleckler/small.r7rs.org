
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Copyright 2013 by Arthur A. Gleckler. All rights reserved. -->
    <title>Source for wiki LazySequencesCowan version 16</title>
    <link href="/trac.css" rel="stylesheet" type="text/css"></head>
  <body>
    <header>This site is a static rendering of the <a href="https://trac.edgewall.org/">Trac</a> instance that was used by <a href="http://scheme-reports.org/2015/working-group-1.html">R7RS-WG1</a> for its work on R7RS-small (<a href="/attachment/r7rs.pdf">PDF</a>), which was ratified in 2013. For more information, see <a href="/">Home</a>.</header>
    <ul class="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/ticket/">All tickets</a></li>
      <li><a href="/wiki/">All wiki pages</a></li></ul>
    <h1>Source for wiki LazySequencesCowan version 16</h1>
    <h2>author</h2>
    <pre>cowan</pre>
    <h2>comment</h2>
    <pre></pre>
    <h2>ipnr</h2>
    <pre>127.11.51.1</pre>
    <h2>name</h2>
    <pre>LazySequencesCowan</pre>
    <h2>readonly</h2>
    <pre>0</pre>
    <h2>text</h2>
    <pre> `
{{{
#!html
&lt;h1&gt;Table of contents&lt;/h1&gt;

&lt;ul id=&quot;toc-table&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#Abstract&quot;&gt;Abstract&lt;/a&gt;
&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#Rationale&quot;&gt;Rationale&lt;/a&gt;
&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#ProcedureIndex&quot;&gt;Procedure index&lt;/a&gt;
&lt;li&gt;&lt;a href=&quot;#Quotation&quot;&gt;Quotation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#TheProcedures&quot;&gt;The procedures&lt;/a&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#Constructors&quot;&gt;Constructors&lt;/a&gt;
  &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#Predicates&quot;&gt;Predicates&lt;/a&gt;
  &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#Selectors&quot;&gt;Selectors&lt;/a&gt;
  &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#Whole&quot;&gt;The whole lazy sequence&lt;/a&gt;
  &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#FoldingMapping&quot;&gt;Folding and mapping&lt;/a&gt;
  &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#Searching&quot;&gt;Searching&lt;/a&gt;
  &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#LazyAssociationLists&quot;&gt;Lazy association lists&lt;/a&gt;
  &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#Comparators&quot;&gt;Comparators&lt;/a&gt;
  &lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#Realization&quot;&gt;Realization&lt;/a&gt;
  &lt;/li&gt;&lt;/ul&gt;
&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#SampleImplementation&quot;&gt;Sample Implementation&lt;/a&gt;
&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#Acknowledgements&quot;&gt;Acknowledgements&lt;/a&gt;
&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#ReferencesLinks&quot;&gt;References &amp;amp; links&lt;/a&gt;
&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#Copyright&quot;&gt;Copyright&lt;/a&gt;
&lt;/li&gt;&lt;/ul&gt;


&lt;!--========================================================================--&gt;
&lt;h1&gt;&lt;a name=&quot;Abstract&quot;&gt;Abstract&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;
Lazy sequences (or lseqs) are a generalization of lists.
In particular, an lseq is either a proper list or a dotted list
whose last cdr is a &lt;a href=&quot;http://srfi.schemers.org/srfi-121/srfi-121.html&quot;&gt;SRFI 121&lt;/a&gt;
generator.
A generator is a procedure that can be invoked with no arguments
in order to lazily supply additional elements of the lseq.
When a generator has no more elements to return, it returns an
end-of-file object.  Consequently, lazy sequences cannot contain
end-of-file objects.&lt;/p&gt; 
&lt;p&gt;This proposal provides a set of procedures
suitable for operating on lazy sequences based on
&lt;a href=&quot;http://srfi.schemers.org/srfi-1/srfi-1.html&quot;&gt;SRFI 1&lt;/a&gt;.&lt;/p&gt;

&lt;h1&gt;&lt;a name=&quot;Rationale&quot;&gt;Rationale&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Lazy sequences are more heavyweight than generators, on which they
are based, but they are more lightweight than
&lt;a href=&quot;http://srfi.schemers.org/srfi-41/srfi-41.html&quot;&gt;SRFI 41&lt;/a&gt; streams.
However, streams are &lt;i&gt;even&lt;/i&gt;, as explained in the SRFI 41 rationale;
that is, the initial state of a stream does not have any elements that
have already been realized.  By contrast, lazy sequences are &lt;i&gt;odd&lt;/i&gt;,
meaning that at least one element is realized at all times unless the lseq
is empty.  Therefore, when you construct an lseq in an iterative lazy algorithm,
only the cdr side of the lazy pair is lazily evaluated; the car side is evaluated 
immediately, even if you don’t use it.&lt;/p&gt;

&lt;p&gt;In most cases this doesn't matter,
because calculating one additional item is a negligible overhead.
However, when you create a self-referential lazy structure,
in which the earlier elements of a sequence are used to caculate
the latter elements of itself, a bit of caution is needed;
code that is valid for circular streams may not terminate
if it is mechanically converted to use lazy sequences.
This eagerness is also visible when side effects are involved;
for example, lazy character sequence reading from a port
may read one character ahead.&lt;/p&gt;
 

&lt;p&gt;This proposal is less comprehensive than SRFI 1, because it omits
most procedures that process every element of the list (at least,
when used in the absence of &lt;code&gt;call/cc&lt;/code&gt;).  The linear-update
procedures of SRFI 1 are also omitted.&lt;/p&gt; 
&lt;!--========================================================================--&gt;
&lt;h1&gt;&lt;a name=&quot;ProcedureIndex&quot;&gt;Procedure Index&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;
Here is a short list of the procedures provided by this SRFI.

&lt;/p&gt;&lt;div class=&quot;indent&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;proc-index&quot;&gt; Constructors
&lt;/dt&gt;&lt;dd class=&quot;proc-index&quot;&gt;
&lt;pre class=&quot;proc-index&quot;&gt;&lt;a href=&quot;#generator-&gt;lseq&quot;&gt;generator-&gt;lseq&lt;/a&gt; 
&lt;/pre&gt;

&lt;/dd&gt;&lt;dt class=&quot;proc-index&quot;&gt; Predicates
&lt;/dt&gt;&lt;dd class=&quot;proc-index&quot;&gt;
&lt;pre class=&quot;proc-index&quot;&gt;
&lt;a href=&quot;#lazy-p&quot;&gt;lseq?&lt;/a&gt;         &lt;a href=&quot;#lseq=&quot;&gt;lseq=&lt;/a&gt;
&lt;/pre&gt;

&lt;/dd&gt;&lt;dt class=&quot;proc-index&quot;&gt; Selectors
&lt;/dt&gt;&lt;dd class=&quot;proc-index&quot;&gt;
&lt;pre class=&quot;proc-index&quot;&gt;
&lt;a href=&quot;#lazy-car&quot;&gt;lazy-car&lt;/a&gt;     &lt;a href=&quot;#lazy-cdr&quot;&gt;lazy-cdr&lt;/a&gt;
&lt;a href=&quot;#lazy-first&quot;&gt;lazy-first&lt;/a&gt;   &lt;a href=&quot;#lazy-second&quot;&gt;lazy-second&lt;/a&gt;  &lt;a href=&quot;#lazy-third&quot;&gt;lazy-third&lt;/a&gt;  &lt;a href=&quot;#lazy-fourth&quot;&gt;lazy-fourth&lt;/a&gt; &lt;a href=&quot;#lazy-fifth&quot;&gt;lazy-fifth&lt;/a&gt;
&lt;a href=&quot;#lazy-sixth&quot;&gt;lazy-sixth&lt;/a&gt;   &lt;a href=&quot;#lazy-seventh&quot;&gt;lazy-seventh&lt;/a&gt; &lt;a href=&quot;#lazy-eighth&quot;&gt;lazy-eighth&lt;/a&gt; &lt;a href=&quot;#lazy-ninth&quot;&gt;lazy-ninth&lt;/a&gt;  &lt;a href=&quot;#lazy-tenth&quot;&gt;lazy-tenth&lt;/a&gt;
&lt;a href=&quot;#lazy-rest&quot;&gt;lazy-rest&lt;/a&gt;    &lt;a href=&quot;#lazy-ref&quot;&gt;lazy-ref&lt;/a&gt;
&lt;a href=&quot;#lazy-take&quot;&gt;lazy-take&lt;/a&gt;    &lt;a href=&quot;#lazy-drop&quot;&gt;lazy-drop&lt;/a&gt;
&lt;a href=&quot;#lazy-split-at&quot;&gt;isplit-at&lt;/a&gt;   
&lt;/pre&gt;

&lt;/dd&gt;&lt;dt class=&quot;proc-index&quot;&gt; The whole lazy sequence
&lt;/dt&gt;&lt;dd class=&quot;proc-index&quot;&gt;
&lt;pre class=&quot;proc-index&quot;&gt;&lt;a href=&quot;#lazy-length&quot;&gt;lazy-length&lt;/a&gt; 
&lt;a href=&quot;#lazy-zip&quot;&gt;lazy-zip&lt;/a&gt;     &lt;a href=&quot;#lazy-unzip1&quot;&gt;lazy-unzip1&lt;/a&gt;       &lt;a href=&quot;#lazy-unzip2&quot;&gt;lazy-unzip2&lt;/a&gt;
&lt;a href=&quot;#lazy-unzip3&quot;&gt;lazy-unzip3&lt;/a&gt;  &lt;a href=&quot;#lazy-unzip4&quot;&gt;lazy-unzip4&lt;/a&gt;       &lt;a href=&quot;#lazy-unzip5&quot;&gt;lazy-unzip5&lt;/a&gt;
&lt;/pre&gt;

&lt;/dd&gt;&lt;dt class=&quot;proc-index&quot;&gt; Folding and mapping
&lt;/dt&gt;&lt;dd class=&quot;proc-index&quot;&gt;
&lt;pre class=&quot;proc-index&quot;&gt;&lt;a href=&quot;#lazy-map&quot;&gt;lazy-map&lt;/a&gt;
&lt;a href=&quot;#lazy-fold&quot;&gt;lazy-fold&lt;/a&gt;       &lt;a href=&quot;#lazy-fold-right&quot;&gt;lazy-fold-right&lt;/a&gt;
&lt;a href=&quot;#lazy-pair-fold&quot;&gt;lazy-for-each&lt;/a&gt;   &lt;a href=&quot;#lazy-pair-for-each&quot;&gt;lazy-pair-for-each&lt;/a&gt;
&lt;a href=&quot;#lazy-reduce&quot;&gt;lazy-reduce&lt;/a&gt;     &lt;a href=&quot;#lazy-reduce-right&quot;&gt;lazy-reduce-right&lt;/a&gt; 
&lt;/pre&gt;

&lt;/dd&gt;&lt;dt class=&quot;proc-index&quot;&gt; Searching
&lt;/dt&gt;&lt;dd class=&quot;proc-index&quot;&gt;&lt;pre class=&quot;proc-index&quot;&gt;
&lt;a href=&quot;#lazy-member&quot;&gt;lazy-member&lt;/a&gt;       &lt;a href=&quot;#lazy-memq&quot;&gt;lazy-memq&lt;/a&gt;     &lt;a href=&quot;#lazy-memv&quot;&gt;lazy-memv&lt;/a&gt;
&lt;a href=&quot;#lazy-find&quot;&gt;lazy-find&lt;/a&gt;         &lt;a href=&quot;#lazy-find-rest&quot;&gt;lazy-find-rest&lt;/a&gt; 
&lt;a href=&quot;#lazy-any&quot;&gt;lazy-any&lt;/a&gt;          &lt;a href=&quot;#lazy-every&quot;&gt;lazy-every&lt;/a&gt;
&lt;a href=&quot;#lazy-index&quot;&gt;lazy-index&lt;/a&gt;
&lt;a href=&quot;#lazy-take-while&quot;&gt;lazy-take-while&lt;/a&gt;   &lt;a href=&quot;#lazy-drop-while&quot;&gt;lazy-drop-while&lt;/a&gt;
&lt;a href=&quot;#lazy-span&quot;&gt;lazy-span&lt;/a&gt;         &lt;a href=&quot;#lazy-break&quot;&gt;lazy-break&lt;/a&gt;
&lt;/pre&gt;

&lt;/dd&gt;&lt;dt class=&quot;proc-index&quot;&gt; Lazy association lists
&lt;/dt&gt;&lt;dd class=&quot;proc-index&quot;&gt;
&lt;pre class=&quot;proc-index&quot;&gt;&lt;a href=&quot;#lazy-assoc&quot;&gt;lazy-assoc&lt;/a&gt;        &lt;a href=&quot;#lazy-assq&quot;&gt;lazy-assq&lt;/a&gt;       &lt;a href=&quot;#lazy-assv&quot;&gt;lazy-assv&lt;/a&gt;
&lt;/pre&gt;

&lt;/dd&gt;&lt;dt class=&quot;proc-index&quot;&gt; Comparators
&lt;/dt&gt;&lt;dd class=&quot;proc-index&quot;&gt;
&lt;pre class=&quot;proc-index&quot;&gt;&lt;a href=&quot;#lazy-comparator&quot;&gt;lazy-comparator&lt;/a&gt;   &lt;a href=&quot;#make-lazy-comparator&quot;&gt;make-lazy-comparator&lt;/a&gt;
&lt;/pre&gt;

&lt;/dd&gt;&lt;dt class=&quot;proc-index&quot;&gt; Realization
&lt;/dt&gt;&lt;dd class=&quot;proc-index&quot;&gt;
&lt;pre class=&quot;proc-index&quot;&gt;&lt;a href=&quot;#lazy-realize&quot;&gt;lazy-realize&lt;/a&gt;              &lt;a href=&quot;#lazy-realize-once&quot;&gt;lazy-realize-once&lt;/a&gt;
&lt;a href=&quot;#lazy-realize-steps&quot;&gt;lazy-realize-steps&lt;/a&gt;        &lt;a href=&quot;#lazy-realize-until&quot;&gt;lazy-realize-until&lt;/a&gt;
&lt;/pre&gt;

&lt;/dd&gt;&lt;/dl&gt;
&lt;/div&gt;

&lt;h1&gt;&lt;a name=&quot;Quotation&quot;&gt;Quotation&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;The syntax keyword &lt;code&gt;lq&lt;/code&gt; is
provided as part of this SRFI.  It is analogous to &lt;code&gt;quote&lt;/code&gt;,
taking an arbitrary number of literals and constructing an lseq from them.
It is useful for providing constant lazy sequences.&lt;/p&gt;


&lt;!--========================================================================--&gt;
&lt;h1&gt;&lt;a name=&quot;TheProcedures&quot;&gt;The procedures&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;
The templates given below obey the following conventions for procedure formals:
&lt;/p&gt;&lt;table&gt;
&lt;tbody&gt;&lt;tr valign=&quot;baseline&quot;&gt;&lt;th align=&quot;left&quot;&gt; &lt;var&gt;lseq&lt;/var&gt;	
    &lt;/th&gt;&lt;td&gt; A lazy sequence
&lt;/td&gt;&lt;/tr&gt;&lt;tr valign=&quot;baseline&quot;&gt;
    &lt;th align=&quot;left&quot;&gt; &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;d&lt;/var&gt;, &lt;var&gt;a&lt;/var&gt;
    &lt;/th&gt;&lt;td&gt; Any value
&lt;/td&gt;&lt;/tr&gt;&lt;tr valign=&quot;baseline&quot;&gt;&lt;th align=&quot;left&quot;&gt; &lt;var&gt;object&lt;/var&gt;, &lt;var&gt;value&lt;/var&gt;
    &lt;/th&gt;&lt;td&gt; Any value
&lt;/td&gt;&lt;/tr&gt;&lt;tr valign=&quot;baseline&quot;&gt;&lt;th align=&quot;left&quot;&gt; &lt;var&gt;n&lt;/var&gt;, &lt;var&gt;i&lt;/var&gt;
    &lt;/th&gt;&lt;td&gt; A natural number (an integer &amp;gt;= 0)
&lt;/td&gt;&lt;/tr&gt;&lt;tr valign=&quot;baseline&quot;&gt;&lt;th align=&quot;left&quot;&gt; &lt;var&gt;proc&lt;/var&gt;
    &lt;/th&gt;&lt;td&gt; A procedure
&lt;/td&gt;&lt;/tr&gt;&lt;tr valign=&quot;baseline&quot;&gt;&lt;th align=&quot;left&quot;&gt; &lt;var&gt;pred&lt;/var&gt;
    &lt;/th&gt;&lt;td&gt; A procedure whose return value is treated as a boolean
&lt;/td&gt;&lt;/tr&gt;&lt;tr valign=&quot;baseline&quot;&gt;&lt;th align=&quot;left&quot;&gt; &lt;var&gt;generator&lt;/var&gt;
    &lt;/th&gt;&lt;td&gt; A procedure with no arguments that returns a sequence of values
&lt;/td&gt;&lt;/tr&gt;&lt;tr valign=&quot;baseline&quot;&gt;&lt;th align=&quot;left&quot;&gt; &lt;var&gt;=&lt;/var&gt;
    &lt;/th&gt;&lt;td&gt; A boolean procedure taking two arguments
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;To interpret the examples, pretend that they are executed on a Scheme that prints lazy sequences with the syntax of lists.

&lt;!--========================================================================--&gt;
&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;Constructors&quot;&gt;Constructors&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;
Every list constructor procedure is also an lseq constructor procedure.
The procedure &lt;code&gt;generator-&gt;lseq&lt;/code&gt; constructs an lseq based on the
values of a generator.  In order to prepend a realized value to a generator,
simply use &lt;code&gt;cons&lt;/i&gt;; to prepend more than one value, use SRFI 1's
&lt;code&gt;cons*&lt;/code&gt;.
&lt;/p&gt;&lt;dl&gt;

&lt;a name=&quot;generator-&gt;lseq&quot;&gt;&lt;/a&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt; &lt;code class=&quot;proc-def&quot;&gt;generator-&gt;lseq&lt;/code&gt; &lt;var&gt;generator -&amp;gt; lseq&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;Returns an lseq
    whose elements are the elements of &lt;var&gt;list, vector, string&lt;/var&gt;,
    or the values generated by &lt;var&gt;generator&lt;/var&gt;.&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;
(list-&gt;lseq '(c c c c c)) =&amp;gt; (c c c c)
(vector-&gt;lseq #(c c c c c)) =&amp;gt; (c c c c)
(string-&gt;lseq &quot;cccc&quot;) =&amp;gt; (#\c #\c #\c #\c)
(generator-&gt;lseq (circular-generator 'c)) =&amp;gt; (c c c ...)
&lt;/pre&gt;&lt;/dd&gt;&lt;/dl&gt;

&lt;!--========================================================================--&gt;
&lt;h2&gt;&lt;a name=&quot;Predicates&quot;&gt;Predicates&lt;/a&gt;&lt;/h2&gt;
&lt;dl&gt;
&lt;!--
==== lseq?
============================================================================--&gt;
&lt;dt class=&quot;proc-def&quot;&gt;
&lt;code class=&quot;proc-def&quot;&gt;lseq?&lt;/code&gt;&lt;var&gt; x -&amp;gt; boolean&lt;/var&gt;
&lt;a name=&quot;lazy-p&quot;&gt;&lt;/a&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;Returns &lt;code&gt;#t&lt;/code&gt; iff &lt;var&gt;x&lt;/var&gt; is an lseq, otherwise &lt;code&gt;#f&lt;/code&gt;.
       This procedure may return &lt;code&gt;#t&lt;/code&gt; if &lt;var&gt;x&lt;/var&gt; is an improper list
       whose last car is a procedure that requires arguments, since there is no
       portable way to examine a procedure to determine how many arguments it requires.
    &lt;/p&gt;


&lt;!--
==== lseq=
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;list=&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lseq=&lt;/code&gt;&lt;var&gt; elt= lseq&lt;sub&gt;1&lt;/sub&gt; ... -&amp;gt; boolean&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;Determines lseq equality, given an element-equality procedure.
    The lseq &lt;var&gt;A&lt;/var&gt; equals the lseq &lt;var&gt;B&lt;/var&gt; 
    if they are of the same length,
    and their corresponding elements are equal, 
    as determined by &lt;var&gt;elt=&lt;/var&gt;. 
    If the element-comparison procedure's first argument is
    from &lt;var&gt;lseq&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt;, 
    then its second argument is from &lt;var&gt;lseq&lt;sub&gt;i+1&lt;/sub&gt;&lt;/var&gt;, 
    &lt;em&gt;i.e.&lt;/em&gt; it is always called as
        &lt;code&gt;(&lt;var&gt;elt=&lt;/var&gt; &lt;var&gt;a&lt;/var&gt; &lt;var&gt;b&lt;/var&gt;)&lt;/code&gt;
    for &lt;var&gt;a&lt;/var&gt; an element of lseq &lt;var&gt;A&lt;/var&gt;, 
    and &lt;var&gt;b&lt;/var&gt; an element of lseq &lt;var&gt;B&lt;/var&gt;.&lt;/p&gt;
&lt;p&gt;
    In the &lt;var&gt;n&lt;/var&gt;-ary case, 
    every &lt;var&gt;lseq&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt; is compared to 
    &lt;var&gt;lseq&lt;sub&gt;i+1&lt;/sub&gt;&lt;/var&gt; 
    (as opposed, for example, to comparing 
    &lt;var&gt;lseq&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; to    &lt;var&gt;lseq&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt;, 
    for &lt;var&gt;i&lt;/var&gt;&amp;gt;1). 
    If there are no lseq arguments at all, 
    &lt;code&gt;lseq=&lt;/code&gt; simply returns true.
&lt;/p&gt;&lt;p&gt;
    Note that the dynamic order in which the &lt;var&gt;elt=&lt;/var&gt; procedure is
    applied to pairs of elements is not specified. 
    For example, if &lt;code&gt;lseq=&lt;/code&gt; is applied
    to three lseqs, &lt;var&gt;A&lt;/var&gt;, &lt;var&gt;B&lt;/var&gt;, and &lt;var&gt;C&lt;/var&gt;, 
    it may first completely compare &lt;var&gt;A&lt;/var&gt; to &lt;var&gt;B&lt;/var&gt;,
    then compare &lt;var&gt;B&lt;/var&gt; to &lt;var&gt;C&lt;/var&gt;, 
    or it may compare the first elements of &lt;var&gt;A&lt;/var&gt; and &lt;var&gt;B&lt;/var&gt;,
    then the first elements of &lt;var&gt;B&lt;/var&gt; and &lt;var&gt;C&lt;/var&gt;, 
    then the second elements of &lt;var&gt;A&lt;/var&gt; and &lt;var&gt;B&lt;/var&gt;, and so forth.
&lt;/p&gt;&lt;p&gt;
    The equality procedure must be consistent with &lt;code&gt;eq?&lt;/code&gt;. 
    That is, it must be the case that
&lt;/p&gt;&lt;div class=&quot;indent&quot;&gt;
        &lt;code&gt;(eq? &lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; =&amp;gt; &lt;code&gt;(&lt;var&gt;elt=&lt;/var&gt; &lt;var&gt;x&lt;/var&gt; &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt;.
&lt;/div&gt;
    &lt;p&gt;Note that this implies that two lseqs which are &lt;code&gt;eq?&lt;/code&gt; 
    are always &lt;code&gt;lseq=&lt;/code&gt;, as well; implementations may exploit this
    fact to &quot;short-cut&quot; the element-by-element comparisons.&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;(lseq= eq?) =&amp;gt; #t       ; Trivial cases
(lseq= eq? (lq a)) =&amp;gt; #t
&lt;/pre&gt;

&lt;/dd&gt;&lt;/dl&gt;


&lt;!--========================================================================--&gt;
&lt;h2&gt;&lt;a name=&quot;Selectors&quot;&gt;Selectors&lt;/a&gt;&lt;/h2&gt;
&lt;dl&gt;

&lt;!--
==== lazy-tenth
==== lazy-ninth
==== lazy-eighth
==== lazy-seventh
==== lazy-sixth
==== lazy-fifth
==== lazy-fourth
==== lazy-third
==== lazy-second
==== lazy-first
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def1&quot;&gt;
&lt;a name=&quot;lazy-car&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-car&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object &lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-first&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-first&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object &lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-second&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-second&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object &lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-third&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-third&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object &lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-fourth&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-fourth&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object &lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-fifth&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-fifth&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object &lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-sixth&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-sixth&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object &lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-seventh&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-seventh&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object &lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-eighth&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-eighth&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object &lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-ninth&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-ninth&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object &lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-tenth&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-tenth&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object  &lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defn&quot;&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;Returns the first, second, ..., tenth element of &lt;var&gt;lseq&lt;/var&gt;.  Note that
&lt;code&gt;lazy-car&lt;/code&gt; and &lt;code&gt;lazy-first&lt;/code&gt; are synonymous with &lt;code&gt;car&lt;/code&gt;.&lt;/p&gt; 

&lt;pre class=&quot;code-example&quot;&gt;(lazy-third (lq a b c d e)) =&amp;gt; c
&lt;/pre&gt;

&lt;!--
==== lazy-rest
============================================================================--&gt;
&gt;&lt;dt class=&quot;proc-def1&quot;&gt;
&lt;a name=&quot;lazy-cdr&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-cdr&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object &lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defn&quot;&gt;
&lt;a name=&quot;lazy-rest&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-rest&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; object &lt;/var&gt;
&lt;/dt&gt;&lt;    
    &lt;p&gt;Returns an lseq with the contents of &lt;var&gt;lseq&lt;/i&gt; except for the
    first element.
    Note that it is an error to apply it to an empty lseq.&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;
(lazy-first (lq a b c))       =&amp;gt;  a        (lazy-rest (lq a b c))         =&amp;gt;  (b c)  
(lazy-first (lq (a) b c d))   =&amp;gt;  (a)	      (lazy-rest (lq (a) b c d))     =&amp;gt;  (b c d)
(lazy-first (cons 1 2))  =&amp;gt;  1	      (lazy-rest (lazy-pair 1 2))    =&amp;gt;  2      
(lazy-first '())              =&amp;gt;  *error*  (lazy-rest '())                =&amp;gt;  *error*
&lt;/pre&gt;



&lt;!--
==== lazy-ref
============================================================================--&gt;
&lt;a name=&quot;lazy-ref&quot;&gt;&lt;/a&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;&lt;code class=&quot;proc-def&quot;&gt;lazy-ref&lt;/code&gt;&lt;var&gt; lseq i -&amp;gt; value&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    
    &lt;p&gt;Returns the &lt;var&gt;i&lt;/var&gt;th element of &lt;var&gt;lseq&lt;/var&gt;.  
    (This is the same as 
        &lt;code&gt;(lazy-first (lazy-drop &lt;var&gt;lseq&lt;/var&gt; &lt;var&gt;i&lt;/var&gt;))&lt;/code&gt;.)
    It is an error if &lt;var&gt;i&lt;/var&gt; &amp;gt;= &lt;var&gt;n&lt;/var&gt;, 
    where &lt;var&gt;n&lt;/var&gt; is the length of &lt;var&gt;lseq&lt;/var&gt;.&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;    
(lazy-ref (lq a b c d) 2) =&amp;gt; c
&lt;/pre&gt;    

&lt;!--
==== lazy-drop
==== lazy-take
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def1&quot;&gt;
&lt;a name=&quot;lazy-take&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-take&lt;/code&gt;&lt;var&gt; lseq i -&amp;gt; lseq&lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-drop&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-drop&lt;/code&gt;&lt;var&gt; lseq i -&amp;gt; object&lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;&lt;code&gt;lazy-take&lt;/code&gt; returns the first &lt;var&gt;i&lt;/var&gt; elements of &lt;var&gt;lseq&lt;/var&gt;.&lt;br/&gt;
    &lt;code&gt;lazy-drop&lt;/code&gt; returns all but the first &lt;var&gt;i&lt;/var&gt; elements of &lt;var&gt;lseq&lt;/var&gt;.&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;(lazy-take (lq a b c d e)  2) =&amp;gt; (a b)
(lazy-drop (lq a b c d e)  2) =&amp;gt; (c d e)
&lt;/pre&gt;
    &lt;p&gt;For a legal &lt;var&gt;i&lt;/var&gt;, &lt;code&gt;lazy-take&lt;/code&gt; and &lt;code&gt;lazy-drop&lt;/code&gt; partition &lt;var&gt;lseq&lt;/var&gt; in a manner which
    can be inverted with &lt;code&gt;lazy-append&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;(lazy-append (lazy-take &lt;var&gt;lseq&lt;/var&gt; &lt;var&gt;i&lt;/var&gt;) (lazy-drop &lt;var&gt;lseq&lt;/var&gt; &lt;var&gt;i&lt;/var&gt;)) = &lt;var&gt;lseq&lt;/var&gt;
&lt;/pre&gt;
    &lt;p&gt;&lt;code&gt;lazy-drop&lt;/code&gt; is exactly equivalent to performing &lt;var&gt;i&lt;/var&gt; &lt;code&gt;lazy-rest&lt;/code&gt; operations on &lt;var&gt;lseq&lt;/var&gt;.&lt;/p&gt;


&lt;!--
==== lazy-split-at
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-split-at&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-split-at&amp;nbsp;&lt;/code&gt;&lt;var&gt; lseq i -&amp;gt; [lseq object]&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;Splits the lseq &lt;var&gt;lseq&lt;/var&gt; 
    at index &lt;var&gt;i&lt;/var&gt;, returning two values, an lseq of the 
    first &lt;var&gt;i&lt;/var&gt; elements, and an lseq of the remaining elements. It is equivalent
    to&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;(values (lazy-take lseq i) (lazy-drop lseq i))
&lt;/pre&gt;
&lt;/dd&gt;&lt;/dl&gt;

&lt;!--========================================================================--&gt;
&lt;h2&gt;&lt;a name=&quot;Whole&quot;&gt;The whole lazy sequence&lt;/a&gt;&lt;/h2&gt;

&lt;dl&gt;
&lt;!--
==== lazy-length
============================================================================--&gt;
&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-length&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-length&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt;lseq -&amp;gt; integer&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;Returns the length of its argument, which is the non-negative integer &lt;var&gt;n&lt;/var&gt; such that &lt;code&gt;lazy-last&lt;/code&gt; 
    applied &lt;var&gt;n&lt;/var&gt; times to the lseq produces an empty lseq.&lt;/p&gt;


&lt;!--
==== lazy-zip
============================================================================--&gt;
&lt;a name=&quot;lazy-zip&quot;&gt;&lt;/a&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;&lt;code class=&quot;proc-def&quot;&gt;lazy-zip&lt;/code&gt; &lt;var&gt;lseq&lt;sub&gt;1&lt;/sub&gt; lseq&lt;sub&gt;2&lt;/sub&gt; ... -&amp;gt; lseq&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;If &lt;code&gt;lazy-zip&lt;/code&gt; is passed &lt;var&gt;n&lt;/var&gt; lseqs, it returns an lseq as long as the shortest
    of these lseqs, each element of which is an &lt;var&gt;n&lt;/var&gt;-element list comprised
    of the corresponding elements from the arguments.&lt;/p&gt;

&lt;pre class=&quot;code-example&quot;&gt;(lazy-zip (lq one two three) 
     (lq 1 2 3)
     (lq odd even odd even odd even odd even))
    =&amp;gt; ((one 1 odd) (two 2 even) (three 3 odd))

(lazy-zip (lq 1 2 3)) =&amp;gt; ((1) (2) (3))
&lt;/pre&gt;
    
&lt;!--
==== lazy-unzip5
==== lazy-unzip4
==== lazy-unzip3
==== lazy-unzip2
==== lazy-unzip1
============================================================================--&gt;
&lt;a name=&quot;lazy-unzip1&quot;&gt;&lt;/a&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def1&quot;&gt;  &lt;code class=&quot;proc-def&quot;&gt;lazy-unzip1&lt;/code&gt;&lt;var&gt; list-of-lseqs -&amp;gt; lseq&lt;/var&gt;
&lt;a name=&quot;lazy-unzip2&quot;&gt;&lt;/a&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt; &lt;code class=&quot;proc-def&quot;&gt;lazy-unzip2&lt;/code&gt;&lt;var&gt; list-of-lseqs -&amp;gt; [lseq lseq]&lt;/var&gt;
&lt;a name=&quot;lazy-unzip3&quot;&gt;&lt;/a&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt; &lt;code class=&quot;proc-def&quot;&gt;lazy-unzip3&lt;/code&gt;&lt;var&gt; list-of-lseqs -&amp;gt; [lseq lseq lseq]&lt;/var&gt;
&lt;a name=&quot;lazy-unzip4&quot;&gt;&lt;/a&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt; &lt;code class=&quot;proc-def&quot;&gt;lazy-unzip4&lt;/code&gt;&lt;var&gt; list-of-lseqs -&amp;gt; [lseq lseq lseq lseq]&lt;/var&gt;
&lt;a name=&quot;lazy-unzip5&quot;&gt;&lt;/a&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defn&quot;&gt; &lt;code class=&quot;proc-def&quot;&gt;lazy-unzip5&lt;/code&gt;&lt;var&gt; lslist-of-lseqs eq -&amp;gt; [lseq lseq lseq lseq lseq]&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;&lt;code&gt;lazy-unzip1&lt;/code&gt; takes a list of lseqs, 
    where every lseq must contain at least one element, 
    and returns an lseq containing the initial element of each such lseq. 
    That is, it returns &lt;code&gt;(lazy-map lazy-first lseqs)&lt;/code&gt;.  
    &lt;code&gt;lazy-unzip2&lt;/code&gt; takes a list of lseqs, where every lseq must contain at least
    two elements, and returns two values: an lseq of the first elements,
    and an lseq of the second elements. &lt;code&gt;lazy-unzip3&lt;/code&gt; does the same for the first
    three elements of the lseqs, and so forth.&lt;/p&gt;

&lt;pre class=&quot;code-example&quot;&gt;(lazy-unzip2 (list (lq 1 one) (lq 2 two) (lq 3 three))) =&amp;gt;
    (1 2 3) 
    (one two three)
&lt;/pre&gt;
&lt;/dd&gt;&lt;/dl&gt;
&lt;!--========================================================================--&gt;
&lt;h2&gt;&lt;a name=&quot;FoldingMapping&quot;&gt;Folding and mapping&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;It is an error if all the lseq arguments to these procedures can be indefinitely
expanded: for example, if they are built from circular generators or procedures that
never return an end-of-file object.
&lt;dl&gt;
&lt;!--
==== lazy-fold
============================================================================--&gt;
&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-fold&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-fold&lt;/code&gt;&lt;var&gt; kons knil lseq&lt;sub&gt;1&lt;/sub&gt; lseq&lt;sub&gt;2&lt;/sub&gt; ... -&amp;gt; value&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;The fundamental lseq iterator. 
&lt;/p&gt;&lt;p&gt;
    First, consider the single lazy-parameter case. If &lt;var&gt;lseq&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; = (&lt;var&gt;e&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; &lt;var&gt;e&lt;sub&gt;2&lt;/sub&gt;&lt;/var&gt; ... &lt;var&gt;e&lt;sub&gt;n&lt;/sub&gt;&lt;/var&gt;),
    then this procedure returns
&lt;/p&gt;&lt;div class=&quot;indent&quot;&gt;
&lt;code&gt;(&lt;var&gt;kons&lt;/var&gt; &lt;var&gt;e&lt;sub&gt;n&lt;/sub&gt;&lt;/var&gt; ... (&lt;var&gt;kons&lt;/var&gt; &lt;var&gt;e&lt;sub&gt;2&lt;/sub&gt;&lt;/var&gt; (&lt;var&gt;kons&lt;/var&gt; &lt;var&gt;e&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; &lt;var&gt;knil&lt;/var&gt;)) ... )&lt;/code&gt;
&lt;/div&gt;
    &lt;p&gt;That is, it obeys the (tail) recursion&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;(lazy-fold &lt;var&gt;kons&lt;/var&gt; &lt;var&gt;knil&lt;/var&gt; &lt;var&gt;lis&lt;/var&gt;) = (lazy-fold &lt;var&gt;kons&lt;/var&gt; (&lt;var&gt;kons&lt;/var&gt; (lazy-first &lt;var&gt;lis&lt;/var&gt;) &lt;var&gt;knil&lt;/var&gt;) (lazy-last &lt;var&gt;lis&lt;/var&gt;))
(lazy-fold &lt;var&gt;kons&lt;/var&gt; &lt;var&gt;knil&lt;/var&gt; '()) = &lt;var&gt;knil&lt;/var&gt;
&lt;/pre&gt;

    Examples:
&lt;pre class=&quot;code-example&quot;&gt;(lazy-fold + 0 lis)			; Add up the elements of LIS.

(lazy-fold lseq* (lseq) lseq)		; Reverse lseq.

(lazy-fold lseq* tail rev-head)	; See append-reverse.

;; How many symbols in LIS?
(lazy-fold (lambda (x count) (if (symbol? x) (+ count 1) count))
      0
      lseq)

;; Length of the longest string in lseq:
(lazy-fold (lambda (s max-len) (max max-len (string-length s)))
      0
      lseq)
&lt;/pre&gt;

    &lt;p&gt;If &lt;var&gt;n&lt;/var&gt; lseq arguments are provided, then the &lt;var&gt;kons&lt;/var&gt; function must take
    &lt;var&gt;n&lt;/var&gt;+1 parameters: one element from each lseq, and the &quot;seed&quot; or fold
    state, which is initially &lt;var&gt;knil&lt;/var&gt;. The fold operation terminates when
    the shortest lseq runs out of values:&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;(lazy-fold lseq* '() (lq a b c) (lq 1 2 3 4 5)) =&amp;gt; (c 3 b 2 a 1)
&lt;/pre&gt;
   
&lt;!--
==== lazy-fold-right
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-fold-right&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-fold-right&lt;/code&gt;&lt;var&gt; kons knil lseq&lt;sub&gt;1&lt;/sub&gt; lseq&lt;sub&gt;2&lt;/sub&gt; ... -&amp;gt; value&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;&lt;p&gt;
    The fundamental lseq recursion operator. 
&lt;/p&gt;&lt;p&gt;
    First, consider the single lazy-parameter case. If &lt;var&gt;lseq&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; = &lt;code&gt;(&lt;var&gt;e&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; &lt;var&gt;e&lt;sub&gt;2&lt;/sub&gt;&lt;/var&gt; ... &lt;var&gt;e&lt;sub&gt;n&lt;/sub&gt;&lt;/var&gt;)&lt;/code&gt;, 
    then this procedure returns
&lt;/p&gt;&lt;div class=&quot;indent&quot;&gt;&lt;code&gt;
(&lt;var&gt;kons&lt;/var&gt; &lt;var&gt;e&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; (&lt;var&gt;kons&lt;/var&gt; &lt;var&gt;e&lt;sub&gt;2&lt;/sub&gt;&lt;/var&gt; ... (&lt;var&gt;kons&lt;/var&gt; &lt;var&gt;e&lt;sub&gt;n&lt;/sub&gt;&lt;/var&gt; &lt;var&gt;knil&lt;/var&gt;)))
&lt;/code&gt;&lt;/div&gt;
    &lt;p&gt;That is, it obeys the recursion&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;(lazy-fold-right &lt;var&gt;kons&lt;/var&gt; &lt;var&gt;knil&lt;/var&gt; &lt;var&gt;lis&lt;/var&gt;) = (&lt;var&gt;kons&lt;/var&gt; (lazy-first &lt;var&gt;lis&lt;/var&gt;) (lazy-fold-right &lt;var&gt;kons&lt;/var&gt; &lt;var&gt;knil&lt;/var&gt; (lazy-last &lt;var&gt;lis&lt;/var&gt;)))
(lazy-fold-right &lt;var&gt;kons&lt;/var&gt; &lt;var&gt;knil&lt;/var&gt; '()) = &lt;var&gt;knil&lt;/var&gt;
&lt;/pre&gt;
        
    Examples:
;; Filter the even numbers out of lseq.
(lazy-fold-right (lambda (x l) (if (even? x) (lazy-cons x l) l)) '() lseq))
&lt;/pre&gt;

    &lt;p&gt;If &lt;var&gt;n&lt;/var&gt; lseq arguments are provided, then the &lt;var&gt;kons&lt;/var&gt; procedure must take
    &lt;var&gt;n&lt;/var&gt;+1 parameters: one element from each lseq, and the &quot;seed&quot; or fold
    state, which is initially &lt;var&gt;knil&lt;/var&gt;. The fold operation terminates when
    the shortest lseq runs out of values:&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;(lazy-fold-right lseq* '() (lq a b c) (lq 1 2 3 4 5)) =&amp;gt; (a 1 b 2 c 3)
&lt;/pre&gt;
 
&lt;!--
==== lazy-reduce
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-reduce&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-reduce&lt;/code&gt;&lt;var&gt; f ridentity lseq -&amp;gt; value&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;&lt;code&gt;lazy-reduce&lt;/code&gt; is a variant of &lt;code&gt;lazy-fold&lt;/code&gt;. 
&lt;/p&gt;&lt;p&gt;
    &lt;var&gt;ridentity&lt;/var&gt; should be a &quot;right identity&quot; of the procedure &lt;var&gt;f&lt;/var&gt; — that is, 
    for any value &lt;var&gt;x&lt;/var&gt; acceptable to &lt;var&gt;f&lt;/var&gt;,
&lt;/p&gt;&lt;pre class=&quot;code-example&quot;&gt;(&lt;var&gt;f&lt;/var&gt; &lt;var&gt;x&lt;/var&gt; &lt;var&gt;ridentity&lt;/var&gt;) = &lt;var&gt;x&lt;/var&gt;
&lt;/pre&gt;
    
    &lt;p&gt;&lt;code&gt;lazy-reduce&lt;/code&gt; has the following definition:
&lt;div class=&quot;indent&quot;&gt;
If &lt;var&gt;lseq&lt;/var&gt; = (),  return &lt;var&gt;ridentity&lt;/var&gt;;&lt;br/&gt;
Otherwise,    return &lt;code&gt;(lazy-fold &lt;var&gt;f&lt;/var&gt; (lazy-first &lt;var&gt;lseq&lt;/var&gt;) (lazy-last &lt;var&gt;lseq&lt;/var&gt;))&lt;/code&gt;.
&lt;/div&gt;
    ...in other words, we compute 
    &lt;code&gt;(lazy-fold &lt;var&gt;f&lt;/var&gt; &lt;var&gt;ridentity&lt;/var&gt; &lt;var&gt;lseq&lt;/var&gt;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;
    Note that &lt;var&gt;ridentity&lt;/var&gt; is used &lt;em&gt;only&lt;/em&gt; in an empty-lseq case.
    You typically use &lt;code&gt;lazy-reduce&lt;/code&gt; when applying &lt;var&gt;f&lt;/var&gt; is expensive and you'd
    like to avoid the extra application incurred when &lt;code&gt;lazy-fold&lt;/code&gt; applies
    &lt;var&gt;f&lt;/var&gt; to the head of &lt;var&gt;lseq&lt;/var&gt; and the identity value,
    redundantly producing the same value passed in to &lt;var&gt;f&lt;/var&gt;. 
    For example, if &lt;var&gt;f&lt;/var&gt; involves searching a file directory or 
    performing a database query, this can be significant. 
    In general, however, &lt;code&gt;lazy-fold&lt;/code&gt; is useful
    in many contexts where &lt;code&gt;lazy-reduce&lt;/code&gt; is not
    (consider the examples given in the &lt;code&gt;lazy-fold&lt;/code&gt; definition — only one of the
    folds uses a function with a right identity. 
    The other four may not be performed with &lt;code&gt;lazy-reduce&lt;/code&gt;).

&lt;/p&gt;&lt;pre class=&quot;code-example&quot;&gt;;; take the max of an lseq of non-negative integers.
(lazy-reduce max 0 nums)
&lt;/pre&gt;

&lt;!--
==== lazy-reduce-right
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-reduce-right&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-reduce-right&lt;/code&gt;&lt;var&gt; f ridentity lseq -&amp;gt; value&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;&lt;code&gt;lazy-reduce-right&lt;/code&gt; is the fold-right variant of &lt;code&gt;lazy-reduce&lt;/code&gt;.
    It obeys the following definition:&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;(lazy-reduce-right &lt;var&gt;f&lt;/var&gt; &lt;var&gt;ridentity&lt;/var&gt; '()) = &lt;var&gt;ridentity&lt;/var&gt;
(lazy-reduce-right &lt;var&gt;f&lt;/var&gt; &lt;var&gt;ridentity&lt;/var&gt; (lq &lt;var&gt;e&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt;)) = (&lt;var&gt;f&lt;/var&gt; &lt;var&gt;e&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; &lt;var&gt;ridentity&lt;/var&gt;) = &lt;var&gt;e&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt;
(lazy-reduce-right &lt;var&gt;f&lt;/var&gt; &lt;var&gt;ridentity&lt;/var&gt; (lq &lt;var&gt;e&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; &lt;var&gt;e&lt;sub&gt;2&lt;/sub&gt;&lt;/var&gt; ...)) =
    (&lt;var&gt;f&lt;/var&gt; &lt;var&gt;e&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; (lazy-reduce &lt;var&gt;f&lt;/var&gt; &lt;var&gt;ridentity&lt;/var&gt; (&lt;var&gt;e&lt;sub&gt;2&lt;/sub&gt;&lt;/var&gt; ...)))
&lt;/pre&gt;
    &lt;p&gt;...in other words, we compute 
    &lt;code&gt;(lazy-fold-right &lt;var&gt;f&lt;/var&gt; &lt;var&gt;ridentity&lt;/var&gt; &lt;var&gt;lseq&lt;/var&gt;)&lt;/code&gt;.&lt;/p&gt;
    
&lt;pre class=&quot;code-example&quot;&gt;;; Append a bunch of lseqs together.
(lazy-reduce-right lazy-append '() lazy-of-lseqs)
&lt;/pre&gt;

&lt;!--
==== lazy-map
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-map&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-map&lt;/code&gt;&lt;var&gt; proc lseq&lt;sub&gt;1&lt;/sub&gt; lseq&lt;sub&gt;2&lt;/sub&gt; ... -&amp;gt; lseq&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    

     &lt;p&gt;&lt;var&gt;proc&lt;/var&gt; is a procedure taking as many arguments 
     as there are lseq arguments and returning a single value.  
     &lt;code&gt;lazy-map&lt;/code&gt; applies &lt;var&gt;proc&lt;/var&gt; element-wise to the elements
     of the lseqs and returns an lseq of the results, 
     in order.  
     The dynamic order in which &lt;var&gt;proc&lt;/var&gt; 
     is applied to the elements of the lseqs is unspecified.&lt;/p&gt;
    
&lt;pre class=&quot;code-example&quot;&gt;(lazy-map icadr (lq (a b) (d e) (g h))) =&amp;gt;  (b e h)

(lazy-map (lambda (n) (expt n n))
     (lq 1 2 3 4 5))
    =&amp;gt;  (1 4 27 256 3125)

(lazy-map + (lq 1 2 3) (lq 4 5 6)) =&amp;gt;  (5 7 9)

(let ((count 0))
  (lazy-map (lambda (lazy-gnored)
         (set! count (+ count 1))
         count)
       (lq a b))) =&amp;gt;  (1 2) &lt;em&gt;or&lt;/em&gt; (2 1)
&lt;/pre&gt;

 &lt;p&gt;
    
&lt;!--
==== lazy-for-each
==== lazy-pair-for-each
============================================================================--&gt;
&lt;/p&gt;&lt;/dd&gt;&lt;dt class=&quot;proc-def1&quot;&gt;
&lt;a name=&quot;lazy-for-each&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-for-each&lt;/code&gt;&lt;var&gt; proc lseq&lt;sub&gt;1&lt;/sub&gt; lseq&lt;sub&gt;2&lt;/sub&gt; ... -&amp;gt; unspecified&lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defn&quot;&gt;
&lt;a name=&quot;lazy-pair-for-each&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-pair-for-each&lt;/code&gt;&lt;var&gt; proc lseq&lt;sub&gt;1&lt;/sub&gt; lseq&lt;sub&gt;2&lt;/sub&gt; ... -&amp;gt; unspecified&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
     

     &lt;p&gt;The arguments to &lt;code&gt;lazy-for-each&lt;/code&gt; are like the arguments to 
     &lt;code&gt;lazy-map&lt;/code&gt;, but
     &lt;code&gt;lazy-for-each&lt;/code&gt; calls &lt;var&gt;proc&lt;/var&gt; for its side effects rather
     than for its values.  
     Unlike &lt;code&gt;lazy-map&lt;/code&gt;, &lt;code&gt;lazy-for-each&lt;/code&gt; is guaranteed to call 
     &lt;var&gt;proc&lt;/var&gt; on the elements of the lseqs in order from the first
     element(s) to the last, 
     and the value returned by &lt;code&gt;lazy-for-each&lt;/code&gt; is unspecified.&lt;/p&gt;
     &lt;p&gt;The procedure &lt;code&gt;lazy-pair-for-each&lt;/code&gt; is the same as
     &lt;code&gt;lazy-for-each&lt;/code&gt;, except that it
     calls &lt;var&gt;proc&lt;/var&gt; on each pair rather than
     each element.&lt;/p&gt;

&lt;pre class=&quot;code-example&quot;&gt;(let ((v (make-vector 5)))
  (lazy-for-each (lambda (lazy-)
              (vector-set! v i (* i i)))
            (lq 0 1 2 3 4))
  v)  =&amp;gt;  #(0 1 4 9 16)
&lt;/pre&gt;
  
 &lt;p&gt;
  
&lt;/dd&gt;&lt;/dl&gt;

&lt;!--========================================================================--&gt;
&lt;/dd&gt;&lt;/dl&gt;&lt;h2&gt;&lt;a name=&quot;Searching&quot;&gt;Searching&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;

The following procedures all search lseqs for the leftmost element satisfying
some criteria. 

&lt;!--
==== lazy-find
============================================================================--&gt;
&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-find&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-find&lt;/code&gt;&lt;var&gt; pred lseq -&amp;gt; value&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;Return the first element of &lt;var&gt;lseq&lt;/var&gt; that satisfies predicate &lt;var&gt;pred&lt;/var&gt;;
    false if no element does.&lt;/p&gt;

&lt;pre class=&quot;code-example&quot;&gt;(lazy-find even? (lq 3 1 4 1 5 9)) =&amp;gt; 4
&lt;/pre&gt;

    &lt;p&gt;Note that &lt;code&gt;lazy-find&lt;/code&gt; has an ambiguity in its lookup semantics — if &lt;code&gt;lazy-find&lt;/code&gt;
    returns &lt;code&gt;#f&lt;/code&gt;, you cannot tell (in general) if it found a &lt;code&gt;#f&lt;/code&gt; element
    that satisfied &lt;var&gt;pred&lt;/var&gt;, or if it did not find any element at all. In
    many situations, this ambiguity cannot arise — either the lseq being
    searched is known not to contain any &lt;code&gt;#f&lt;/code&gt; elements, or the lseq is
    guaranteed to have an element satisfying &lt;var&gt;pred&lt;/var&gt;. However, in cases
    where this ambiguity can arise, you should use &lt;code&gt;lazy-find-tail&lt;/code&gt; instead of
    &lt;code&gt;lazy-find&lt;/code&gt; — &lt;code&gt;lazy-find-tail&lt;/code&gt; has no such ambiguity:&lt;/p&gt;
&lt;pre class=&quot;code-example&quot;&gt;(cond ((lazy-find-tail pred lseq) =&amp;gt; (lambda (lseq) ...))
      (else ...)) ; Search failed.
&lt;/pre&gt;

&lt;!--
==== lazy-find-tail
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-find-tail&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-find-tail&lt;/code&gt;&lt;var&gt; pred lseq -&amp;gt; lseq or false&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;Return the longest tail of &lt;var&gt;lseq&lt;/var&gt; whose first element satisfies &lt;var&gt;pred&lt;/var&gt;. If no element does,
    return false.
&lt;/p&gt;&lt;p&gt;
    &lt;code&gt;lazy-find-tail&lt;/code&gt; can be viewed as a general-predicate variant of the &lt;code&gt;lazy-member&lt;/code&gt;
    function.
&lt;/p&gt;&lt;p&gt;
    Examples: 
&lt;/p&gt;&lt;pre class=&quot;code-example&quot;&gt;(lazy-find-tail even? (lq 3 1 37 -8 -5 0 0)) =&amp;gt; (-8 -5 0 0)
(lazy-find-tail even? (lq 3 1 37 -5)) =&amp;gt; #f

;; imember x lseq:
(lazy-find-tail (lambda (elt) (equal? x elt)) lseq)
&lt;/pre&gt;

&lt;p&gt;
    &lt;code&gt;lazy-find-tail&lt;/code&gt; is essentially &lt;code&gt;lazy-drop-while&lt;/code&gt;, 
    where the sense of the predicate is inverted: 
    &lt;code&gt;lazy-find-tail&lt;/code&gt; searches until it finds an element satisfying
    the predicate; &lt;code&gt;lazy-drop-while&lt;/code&gt; searches until it finds an 
    element that &lt;em&gt;doesn't&lt;/em&gt; satisfy the predicate.

&lt;!--
==== lazy-take-while
============================================================================--&gt;
&lt;/p&gt;&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-take-while&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-take-while&amp;nbsp;&lt;/code&gt;&lt;var&gt; pred lseq -&amp;gt; lseq&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;

&lt;p&gt;Returns the longest initial prefix of &lt;var&gt;lseq&lt;/var&gt; whose elements all
satisfy the predicate &lt;var&gt;pred&lt;/var&gt;.&lt;/p&gt;

&lt;pre class=&quot;code-example&quot;&gt;(lazy-take-while even? (lq 2 18 3 10 22 9)) =&amp;gt; (2 18)
&lt;/pre&gt;

&lt;!--
==== lazy-drop-while
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-drop-while&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-drop-while&lt;/code&gt;&lt;var&gt; pred lseq -&amp;gt; lseq&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
&lt;p&gt;Drops the longest initial prefix of &lt;var&gt;lseq&lt;/var&gt; whose elements all
satisfy the predicate &lt;var&gt;pred&lt;/var&gt;, and returns the rest of the lseq.&lt;/p&gt;

&lt;pre class=&quot;code-example&quot;&gt;(lazy-drop-while even? (lq 2 18 3 10 22 9)) =&amp;gt; (3 10 22 9)
&lt;/pre&gt;

&lt;!--
==== lazy-span ibreak
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def1&quot;&gt;
&lt;a name=&quot;lazy-span&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-span&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;var&gt; pred lseq -&amp;gt; [lseq lseq]&lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defn&quot;&gt;
&lt;a name=&quot;lazy-break&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-break&amp;nbsp;&lt;/code&gt;&lt;var&gt; pred lseq -&amp;gt; [lseq lseq]&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;

&lt;p&gt;&lt;code&gt;lazy-span&lt;/code&gt; splits the lseq into the longest initial prefix whose
elements all satisfy &lt;var&gt;pred&lt;/var&gt;, and the remaining tail. 
&lt;code&gt;lazy-break&lt;/code&gt; inverts the sense of the predicate: 
the tail commences with the first element of the input lseq
that satisfies the predicate.&lt;/p&gt;

&lt;p&gt;
In other words: 
&lt;code&gt;lazy-span&lt;/code&gt; finds the initial span of elements 
satisfying &lt;var&gt;pred&lt;/var&gt;, 
and &lt;code&gt;lazy-break&lt;/code&gt; breaks the lseq at the first element satisfying 
&lt;var&gt;pred&lt;/var&gt;.

&lt;/p&gt;&lt;p&gt;
&lt;code&gt;lazy-span&lt;/code&gt; is equivalent to 
&lt;/p&gt;&lt;pre class=&quot;code-example&quot;&gt;(values (lazy-take-while &lt;var&gt;pred&lt;/var&gt; &lt;var&gt;lseq&lt;/var&gt;) 
        (lazy-drop-while &lt;var&gt;pred&lt;/var&gt; &lt;var&gt;lseq&lt;/var&gt;))
&lt;/pre&gt;

&lt;p&gt;
&lt;/p&gt;&lt;pre class=&quot;code-example&quot;&gt;(lazy-span even? (lq 2 18 3 10 22 9)) =&amp;gt;
  (2 18)
  (3 10 22 9)

(lazy-break even? (lq 3 1 4 1 5 9)) =&amp;gt;
  (3 1)
  (4 1 5 9)
&lt;/pre&gt;


&lt;!--
==== lazy-any
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-any&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-any&lt;/code&gt;&lt;var&gt; pred lseq&lt;sub&gt;1&lt;/sub&gt; lseq&lt;sub&gt;2&lt;/sub&gt; ... -&amp;gt; value&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;Applies the predicate across the lseqs, returning true if the predicate
    returns true on any application.
&lt;/p&gt;&lt;p&gt;
    If there are &lt;var&gt;n&lt;/var&gt; lseq arguments &lt;var&gt;lseq&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; ... &lt;var&gt;lseq&lt;sub&gt;n&lt;/sub&gt;&lt;/var&gt;, then &lt;var&gt;pred&lt;/var&gt; must be a
    procedure taking &lt;var&gt;n&lt;/var&gt; arguments and returning a boolean result.
&lt;/p&gt;&lt;p&gt;
    &lt;code&gt;lazy-any&lt;/code&gt; applies &lt;var&gt;pred&lt;/var&gt; to the first elements of the &lt;var&gt;lseq&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt; parameters.
    If this application returns a true value, &lt;code&gt;lazy-any&lt;/code&gt; immediately returns
    that value. Otherwise, it iterates, applying &lt;var&gt;pred&lt;/var&gt; to the second
    elements of the &lt;var&gt;lseq&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt; parameters, then the third, and so forth.
    The iteration stops when a true value is produced or one of the lseqs runs
    out of values; in
    the latter case, &lt;code&gt;lazy-any&lt;/code&gt; returns &lt;code&gt;#f&lt;/code&gt;. 
    The application of &lt;var&gt;pred&lt;/var&gt; to the last element of the
    lseqs is a tail call.
&lt;/p&gt;&lt;p&gt;
    Note the difference between &lt;code&gt;lazy-find&lt;/code&gt; and &lt;code&gt;lazy-any&lt;/code&gt; — &lt;code&gt;lazy-find&lt;/code&gt; returns the element
    that satisfied the predicate; &lt;code&gt;lazy-any&lt;/code&gt; returns the true value that the
    predicate produced.
&lt;/p&gt;&lt;p&gt;
    Like &lt;code&gt;lazy-every&lt;/code&gt;, &lt;code&gt;lazy-any&lt;/code&gt;'s name does not end with a question mark — this is to
    indicate that it does not return a simple boolean (&lt;code&gt;#t&lt;/code&gt; or &lt;code&gt;#f&lt;/code&gt;), but a
    general value.

&lt;/p&gt;&lt;pre class=&quot;code-example&quot;&gt;(lazy-any integer? (lq a 3 b 2.7))   =&amp;gt; #t
(lazy-any integer? (lq a 3.1 b 2.7)) =&amp;gt; #f
(lazy-any &amp;lt; (lq 3 1 4 1 5)
       (lq 2 7 1 8 2)) =&amp;gt; #t
&lt;/pre&gt;

&lt;!--
==== lazy-every
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-every&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-every&lt;/code&gt;&lt;var&gt; pred lseq&lt;sub&gt;1&lt;/sub&gt; lseq&lt;sub&gt;2&lt;/sub&gt; ... -&amp;gt; value&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;Applies the predicate across the lseqs, returning true if the predicate
    returns true on every application.
&lt;/p&gt;&lt;p&gt;
    If there are &lt;var&gt;n&lt;/var&gt; lseq arguments &lt;var&gt;lseq&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; ... &lt;var&gt;lseq&lt;sub&gt;n&lt;/sub&gt;&lt;/var&gt;, then &lt;var&gt;pred&lt;/var&gt; must be a
    procedure taking &lt;var&gt;n&lt;/var&gt; arguments and returning a boolean result.
&lt;/p&gt;&lt;p&gt;
    &lt;code&gt;lazy-every&lt;/code&gt; applies &lt;var&gt;pred&lt;/var&gt; to the first elements of the &lt;var&gt;lseq&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt; parameters.
    If this application returns false, &lt;code&gt;lazy-every&lt;/code&gt; immediately returns false.
    Otherwise, it iterates, applying &lt;var&gt;pred&lt;/var&gt; to the second elements of the
    &lt;var&gt;lseq&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt; parameters, then the third, and so forth. The iteration stops
    when a false value is produced or one of the lseqs runs out of values.
    In the latter case, &lt;code&gt;lazy-every&lt;/code&gt; returns
    the true value produced by its final application of &lt;var&gt;pred&lt;/var&gt;. 
    The application of &lt;var&gt;pred&lt;/var&gt; to the last element of the lseqs 
    is a tail call.
&lt;/p&gt;&lt;p&gt;
    If one of the &lt;var&gt;lseq&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt; has no elements, &lt;code&gt;lazy-every&lt;/code&gt; simply returns &lt;code&gt;#t&lt;/code&gt;.
&lt;/p&gt;&lt;p&gt;
    Like &lt;code&gt;lazy-any&lt;/code&gt;, &lt;code&gt;lazy-every&lt;/code&gt;'s name does not end with a question mark — this is to
    indicate that it does not return a simple boolean (&lt;code&gt;#t&lt;/code&gt; or &lt;code&gt;#f&lt;/code&gt;), but a
    general value.

&lt;!--
==== lazy-index
============================================================================--&gt;
&lt;/p&gt;&lt;/dd&gt;&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-index&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-index&lt;/code&gt;&lt;var&gt; pred lseq&lt;sub&gt;1&lt;/sub&gt; lseq&lt;sub&gt;2&lt;/sub&gt; ... -&amp;gt; integer or false&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
    &lt;p&gt;Return the index of the leftmost element that satisfies &lt;var&gt;pred&lt;/var&gt;.
&lt;/p&gt;&lt;p&gt;
    If there are &lt;var&gt;n&lt;/var&gt; lseq arguments &lt;var&gt;lseq&lt;sub&gt;1&lt;/sub&gt;&lt;/var&gt; ... &lt;var&gt;lseq&lt;sub&gt;n&lt;/sub&gt;&lt;/var&gt;, then &lt;var&gt;pred&lt;/var&gt; must be a
    function taking &lt;var&gt;n&lt;/var&gt; arguments and returning a boolean result.
&lt;/p&gt;&lt;p&gt;
    &lt;code&gt;lazy-index&lt;/code&gt; applies &lt;var&gt;pred&lt;/var&gt; to the first elements of the &lt;var&gt;lseq&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt; parameters.
    If this application returns true, &lt;code&gt;lazy-index&lt;/code&gt; immediately returns zero.
    Otherwise, it iterates, applying &lt;var&gt;pred&lt;/var&gt; to the second elements of the
    &lt;var&gt;lseq&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt; parameters, then the third, and so forth. When it finds a tuple of
    lseq elements that cause &lt;var&gt;pred&lt;/var&gt; to return true, it stops and returns the
    zero-based index of that position in the lseqs.
&lt;/p&gt;&lt;p&gt;
    The iteration stops when one of the lseqs runs out of values; in this
    case, &lt;code&gt;lazy-index&lt;/code&gt; returns &lt;code&gt;#f&lt;/code&gt;.

&lt;/p&gt;&lt;pre class=&quot;code-example&quot;&gt;(lazy-index even? (lq 3 1 4 1 5 9)) =&amp;gt; 2
(lazy-index &amp;lt; (lq 3 1 4 1 5 9 2 5 6) (lq 2 7 1 8 2)) =&amp;gt; 1
(lazy-index = (lq 3 1 4 1 5 9 2 5 6) (lq 2 7 1 8 2)) =&amp;gt; #f
&lt;/pre&gt;

&lt;!--
==== lazy-member lazy-memq lazy-memv
============================================================================--&gt;
&lt;/dd&gt;&lt;dt class=&quot;proc-def1&quot;&gt;
&lt;a name=&quot;lazy-member&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-member&lt;/code&gt;&lt;var&gt; x lseq [=] -&amp;gt; lseq&lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-memq&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-memq&lt;/code&gt;&lt;var&gt; x lseq -&amp;gt; lseq&lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defn&quot;&gt;
&lt;a name=&quot;lazy-memv&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-memv&lt;/code&gt;&lt;var&gt; x lseq -&amp;gt; lseq&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
     

    &lt;p&gt;These procedures return the longest tail of &lt;var&gt;lseq&lt;/var&gt; whose first element is
    &lt;var&gt;x&lt;/var&gt;, where the tails of &lt;var&gt;lseq&lt;/var&gt; are the 
    non-empty lseqs returned by 
        &lt;code&gt;(lazy-drop &lt;var&gt;lseq&lt;/var&gt; &lt;var&gt;i&lt;/var&gt;)&lt;/code&gt;
    for &lt;var&gt;i&lt;/var&gt; less than the length of &lt;var&gt;lseq&lt;/var&gt;.  
    If &lt;var&gt;x&lt;/var&gt; does
    not occur in &lt;var&gt;lseq&lt;/var&gt;, then &lt;code&gt;#f&lt;/code&gt; is returned.  
    &lt;code&gt;lazy-memq&lt;/code&gt; uses &lt;code&gt;eq?&lt;/code&gt; to compare &lt;var&gt;x&lt;/var&gt;
    with the elements of &lt;var&gt;lseq&lt;/var&gt;, 
    while &lt;code&gt;lazy-memv&lt;/code&gt; uses &lt;code&gt;eqv?&lt;/code&gt;, and
    &lt;code&gt;lazy-member&lt;/code&gt; uses &lt;var&gt;=&lt;/var&gt;, which defaults to &lt;code&gt;equal?&lt;/code&gt;.&lt;/p&gt;

&lt;pre class=&quot;code-example&quot;&gt;    (lazy-memq 'a (lq a b c))           =&amp;gt;  (a b c)
    (lazy-memq 'b (lq a b c))           =&amp;gt;  (b c)
    (lazy-memq 'a (lq b c d))           =&amp;gt;  #f
    (lazy-memq (lseq 'a) (lq b (a) c)) =&amp;gt;  #f
    (lazy-member (lseq 'a)
            (lq b (a) c))           =&amp;gt;  ((a) c)
    (lazy-memq 101 (lq 100 101 102))    =&amp;gt;  *unspecified*
    (lazy-memv 101 (lq 100 101 102))    =&amp;gt;  (101 102)
&lt;/pre&gt;

    
&lt;p&gt;
    The comparison procedure is used to compare the elements &lt;var&gt;e&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt; of &lt;var&gt;lseq&lt;/var&gt;
    to the key &lt;var&gt;x&lt;/var&gt; in this way:
&lt;/p&gt;&lt;div class=&quot;indent&quot;&gt;&lt;code&gt;
(= &lt;var&gt;x&lt;/var&gt; &lt;var&gt;e&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt;)		; lseq is (E1 ... En)
&lt;/code&gt;&lt;/div&gt;
    &lt;p&gt;That is, the first argument is always &lt;var&gt;x&lt;/var&gt;, and the second argument is
    one of the lseq elements. Thus one can reliably find the first element
    of &lt;var&gt;lseq&lt;/var&gt; that is greater than five with
	&lt;code&gt;(lazy-member 5 &lt;var&gt;lseq&lt;/var&gt; &amp;lt;)&lt;/code&gt;

&lt;/p&gt;&lt;p&gt;
    Note that fully general lseq searching may be performed with
    the &lt;code&gt;lazy-find-tail&lt;/code&gt; and &lt;code&gt;lazy-find&lt;/code&gt; procedures, &lt;em&gt;e.g.&lt;/em&gt;
&lt;/p&gt;&lt;pre class=&quot;code-example&quot;&gt;(lazy-find-tail even? lseq) ; Find the first elt with an even key.
&lt;/pre&gt;

&lt;/dd&gt;&lt;/dl&gt;

&lt;!--========================================================================--&gt;
&lt;h2&gt;&lt;a name=&quot;LazyAssociationLists&quot;&gt;Lazy association lists&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;
An &quot;lazy association list&quot; (or &quot;lazy alist&quot;) is an lseq of pairs. The car of each pair
contains a key value, and the cdr contains the associated data value. They can
be used to construct simple look-up tables in Scheme.
Note that lazy alists are probably inappropriate for performance-critical use on large data;
in these cases, immutable maps or some other alternative should be employed.

&lt;/p&gt;&lt;dl&gt;
&lt;!--
==== lazy-assoc lazy-assq lazy-assv
============================================================================--&gt;
&lt;dt class=&quot;proc-def1&quot;&gt;
&lt;a name=&quot;lazy-assoc&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-assoc&lt;/code&gt;&lt;var&gt; key lazy-alist [=] -&amp;gt; lseq or #f&lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defi&quot;&gt;
&lt;a name=&quot;lazy-assq&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-assq&lt;/code&gt;&lt;var&gt; key lazy-alist -&amp;gt; lseq or #f&lt;/var&gt;
&lt;/dt&gt;&lt;dt class=&quot;proc-defn&quot;&gt;
&lt;a name=&quot;lazy-assv&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-assv&lt;/code&gt;&lt;var&gt; key lazy-alist -&amp;gt; lseq or #f&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;

  
    &lt;p&gt;These procedures
    find the first pair in &lt;var&gt;lazy-alist&lt;/var&gt; whose car field is &lt;var&gt;key&lt;/var&gt;, 
    and returns that pair.  
    If no pair in &lt;var&gt;lazy-alist&lt;/var&gt; has &lt;var&gt;key&lt;/var&gt; as its icar, 
    then &lt;code&gt;#f&lt;/code&gt; is returned.  
    &lt;code&gt;lazy-assq&lt;/code&gt; uses &lt;code&gt;eq?&lt;/code&gt; to compare &lt;var&gt;key&lt;/var&gt; 
    with the car fields of the ipairs in &lt;var&gt;lazy-alist&lt;/var&gt;, 
    while &lt;code&gt;lazy-assv&lt;/code&gt; uses &lt;code&gt;eqv?&lt;/code&gt; 
    and &lt;code&gt;lazy-assoc&lt;/code&gt; uses &lt;var&gt;=&lt;/var&gt;, which defaults to &lt;code&gt;equal?&lt;/code&gt;.&lt;/p&gt;

&lt;pre class=&quot;code-example&quot;&gt;(define e (lq (a 1) (b 2) (c 3)))
(lazy-assq 'a e)                              =&amp;gt;  (a 1)
(lazy-assq 'b e)                              =&amp;gt;  (b 2)
(lazy-assq 'd e)                              =&amp;gt;  #f
(lazy-assq (lseq 'a) (lq ((a)) ((b)) ((c))))  =&amp;gt;  #f
(lazy-assoc (lseq 'a) (lq ((a)) ((b)) ((c)))) =&amp;gt;  ((a))
(lazy-assq 5 (lq (2 3) (5 7) (11 13)))	      =&amp;gt;  *unspecified*
(lazy-assv 5 (lq (2 3) (5 7) (11 13)))	      =&amp;gt;  (5 7)
&lt;/pre&gt;
&lt;p&gt;
    The comparison procedure is used to compare the elements &lt;var&gt;e&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt; of &lt;var&gt;lseq&lt;/var&gt;
    to the &lt;var&gt;key&lt;/var&gt; parameter in this way:
&lt;/p&gt;&lt;div class=&quot;indent&quot;&gt;&lt;code&gt;
(= &lt;var&gt;key&lt;/var&gt; (lazy-first &lt;var&gt;e&lt;sub&gt;i&lt;/sub&gt;&lt;/var&gt;))	; lseq is (E1 ... En)
&lt;/code&gt;&lt;/div&gt;
    That is, the first argument is always &lt;var&gt;key&lt;/var&gt;, 
    and the second argument is one of the lseq elements. 
    Thus one can reliably find the first entry
    of &lt;var&gt;lazy alist&lt;/var&gt; whose key is greater than five with
	&lt;code&gt;(lazy-assoc 5 &lt;var&gt;lazy alist&lt;/var&gt; &amp;lt;)&lt;/code&gt;
     
&lt;/p&gt;&lt;p&gt;
    Note that fully general lazy alist searching may be performed with
    the &lt;code&gt;lazy-find-tail&lt;/code&gt; and &lt;code&gt;lazy-find&lt;/code&gt; procedures, &lt;em&gt;e.g.&lt;/em&gt;
&lt;/p&gt;&lt;pre class=&quot;code-example&quot;&gt;;; Look up the first association in &lt;var&gt;lazy alist&lt;/var&gt; with an even key:
(lazy-find (lambda (a) (even? (lazy-first a))) lazy alist)
&lt;/pre&gt;


&lt;!--========================================================================--&gt;
&lt;h2&gt;&lt;a name=&quot;Comparators&quot;&gt;Comparators&lt;/a&gt;&lt;/h2&gt;

&lt;dl&gt;
&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-comparator&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-pair-comparator&lt;/code&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
     
     &lt;p&gt;The &lt;code&gt;lazy-comparator&lt;/code&gt; object is a SRFI-114 comparator suitable for comparing lseqs.
     Note that it is &lt;em&gt;not&lt;/em&gt; a procedure.
     It compares lseqs using &lt;code&gt;default-comparator&lt;/code&gt; on their first elements.  If they are not equal, that value is returned.  If they are equal, &lt;code&gt;lazy-comparator&lt;/code&gt; is used on the &lt;code&gt;lazy-rest&lt;/code&gt; of the lseqs and that value is returned.&lt;/p&gt;
&lt;/dd&gt;
 
&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;make-lazy-comparator&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;make-lazy-comparator&lt;/code&gt;&lt;var&gt; comparator -&amp;gt; comparator&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
     
     &lt;p&gt;The &lt;code&gt;make-lazy-comparator&lt;/code&gt; procedure returns a comparator suitable for comparing lseqs
     using &lt;var&gt;element-comparator&lt;/var&gt; to compare the elements.&lt;/p&gt;
&lt;/dd&gt;
 
&lt;/dl&gt;
 
&lt;!--========================================================================--&gt;
&lt;h2&gt;&lt;a name=&quot;Realization&quot;&gt;Realization&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;These procedures have no directly visible effects on their lseq arguments.
However, they force the generator inside the lazy sequence to produce all its
arguments and store them internally, which means that later operations may be
faster, particularly if the generator is slow.  They return their argument.&lt;/p&gt;

&lt;dl&gt;
&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-realize&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-realize&lt;/code&gt;&lt;var&gt; lseq&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
     
     &lt;p&gt;Realizes all the values of &lt;var&gt;lseq&lt;/var&gt;.&lt;/p&gt;
&lt;/dd&gt;
 
&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-realize-once&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-realize-once&lt;/code&gt;&lt;var&gt; lseq&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
     
     &lt;p&gt;Realizes exactly one additional value of &lt;var&gt;lseq&lt;/var&gt;.  If no additional
values are available, does nothing.&lt;/p&gt;
&lt;/dd&gt;
 
&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-realize-steps&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-realize-steps&lt;/code&gt;&lt;var&gt; lseq n&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
     
     &lt;p&gt;Realizes at most &lt;var&gt;n&lt;/var&gt; values of &lt;var&gt;lseq&lt;/var&gt;.&lt;/p&gt;
&lt;/dd&gt;
 
&lt;dt class=&quot;proc-def&quot;&gt;
&lt;a name=&quot;lazy-realize-until&quot;&gt;&lt;/a&gt;
&lt;code class=&quot;proc-def&quot;&gt;lazy-realize-until&lt;/code&gt;&lt;var&gt; lseq pred&lt;/var&gt;
&lt;/dt&gt;&lt;dd class=&quot;proc-def&quot;&gt;
     
     &lt;p&gt;Realizes values of &lt;var&gt;lseq&lt;/var&gt; until at least one value satisfies &lt;var&gt;pred&lt;/var&gt;.&lt;/p&gt;
&lt;/dd&gt;
 
&lt;/dl&gt;
 
&lt;!--========================================================================--&gt;
&lt;h1&gt;&lt;a name=&quot;SampleImplementation&quot;&gt;Sample Implementation&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;The files in the implementation are as follows:&lt;/p&gt;

&lt;p&gt;FIXME&lt;/p&gt;



&lt;!--========================================================================--&gt;
&lt;h1&gt;&lt;a name=&quot;Acknowledgements&quot;&gt;Acknowledgements&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;
Without the work of Olin Shivers on &lt;a href=&quot;http://srfi.schemers.org/srfi-1/srfi-1.html&quot;&gt;SRFI 1&lt;/a&gt;,
this SRFI would not exist. Everyone acknowledged there is transitively acknowledged here.
This is not to imply that either Olin or anyone else necessarily endorses the final
results, of course. 


}}}</pre>
    <h2>time</h2>
    <pre>2015-02-11 07:09:44</pre>
    <h2>version</h2>
    <pre>16</pre></body></html>