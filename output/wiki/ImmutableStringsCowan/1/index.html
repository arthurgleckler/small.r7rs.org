
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Copyright 2013 by Arthur A. Gleckler. All rights reserved. -->
    <title>ImmutableStringsCowan</title>
    <link href="/trac.css" rel="stylesheet" type="text/css"></head>
  <body>
    <header>This site is a static rendering of the <a href="https://trac.edgewall.org/">Trac</a> instance that was used by <a href="http://scheme-reports.org/2015/working-group-1.html">R7RS-WG1</a> for its work on R7RS-small (<a href="/attachment/r7rs.pdf">PDF</a>), which was ratified in 2013. For more information, see <a href="/">Home</a>. For a version of this page that may be more recent, see <a href="https://github.com/johnwcowan/r7rs-work/blob/master/ImmutableStringsCowan.md">ImmutableStringsCowan</a> in WG2's repo for R7RS-large.</header>
    <ul class="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/ticket/">All tickets</a></li>
      <li><a href="/wiki/">All wiki pages</a></li></ul>
    <h1 class="wiki">Immutable&shy;Strings&shy;Cowan</h1>
    <div class="wiki metadata">
      <div class="author">cowan</div>
      <div class="time">2010-11-15 05:42:09</div>
      <div class="version">1<span class="comment"></span><a href="/wiki/ImmutableStringsCowan/history">history</a></div>
      <div class="source"><a href="/wiki/ImmutableStringsCowan/1/source.html">source</a></div></div>
    <div class="wiki text">
      <h2 id="Removing`string-set!`fromR7RSsmallScheme">Removing <span class="monospace">string-set!</span> from R7RS small Scheme</h2>
      <p>This is a proposal for the removal of <span class="monospace">string-set!</span> (and consequently <span class="monospace">string-fill!</span>) from the R7RS small Scheme language.  I believe that despite the prescription of the WG1 charter that no features of IEEE Scheme (a subset of R4RS) should be removed from R7RS small Scheme, an exception should be made for <span class="monospace">string-set!</span>, for at least the following reasons:</p>
      <p>Immutable strings are more purely functional, and allow many optimizations, such as being transparently and freely shareable between procedures and between threads without concern for uncontrolled mutation.  For this and other reasons, the general trend in new languages/runtimes such as Java and C# is toward immutable strings; unfortunately, this is the kind of argument that Schemers usually don't like, so I won't bother mentioning it.  :-)</p>
      <p>Algorithms where you want to modify strings in the middle are rare, and many of the classic devices (such as string-upcase!, a procedure that mutates a string in place) are awkward or impossible with string representations such as UTF-8 that make use of characters of variable length.  Programs that work with text generally want either an immutable string or an editable string into which characters can be inserted and deleted, which are not directly possible with classical Scheme strings.  Representations such as gap buffers (based on blobs) or trees of immutable strings serve such programs much better: complex algorithms expressed in terms of string-set! can be rewritten in terms of insert and delete operations with a great increase in clarity.</p>
      <p>If strings are immutable, it's possible to have both fast O(1) access to individual characters or substrings, and fairly space-efficient representation of full Unicode strings, by using different representations for strings drawn from different character repertoires.  (Of course, this does not mean that small Scheme implementations must support full Unicode.)  For example, an implementation might use 8-bit code units when all characters are less than <span class="monospace">\#x100</span>, 16-bit code units when all characters are less than <span class="monospace">\#x10000</span>, and 32-bit code units otherwise.</p>
      <p>Unfortunately, mutating even a single character in such a representation may require the entire string to be copied, which means that it also requires indirection through a separate header that can be redirected to point to the newly allocated code unit sequence.  Immutable strings can just be their sequences, with a few extra bits indicating the size of the code units, although this design does prevent easy sharing of substrings.</p>
      <p>Nothing will give you immutable strings if you don't already have them built into the implementation. On  the other hand, if the core Scheme strings were immutable and an editable strings library were provided on the lines outlined above, existing users of mutable strings could convert to using the latter representation with little effort, and writing programs which require an editable strings representation would be vastly simplified.</p>
      <p>Making strings immutable also permits a design in which all strings are Unicode-normalized.  Though this has its own costs (for example, appending two strings may create a new string whose length is different from the lengths of the two source strings), it would be effectively impossible where arbitrary mutation is allowed.</p>
      <p>If strings are immutable, there needs to be a way to construct them other than all at once, as make-string and string do.  The Builder pattern serves well here: use a general vector, which is mutable, to assemble the characters in the string one (or a few) at a time, not necessarily in order.  Then use <span class="monospace">vector-&gt;string</span> to produce the final result.  The complementary <span class="monospace">string-&gt;vector</span> procedure is useful for constructing such build vectors in the first place.  Alternatively string ports can be used as builders; they are unbounded in size, but can only accept appends, not arbitrary mutations.</p>
      <p>It is more expensive to use builders rather than using strings directly, but the cost is contained.  In existing Schemes, the mere possibility of applying <span class="monospace">string-set!</span> to any string at any time makes other string operations consume more resources, which reduces their value.  It's a choice between two costs which have different effects for different situations.</p>
      <p>As a consequence of removing <span class="monospace">string-set!</span>, <span class="monospace">string-fill!</span> (not in IEEE Scheme) becomes impossible and <span class="monospace">string-copy</span> less useful.  I do not propose to remove <span class="monospace">string-copy</span> for two reasons:</p>
      <p>(a) It can eliminate space leaks that are caused by taking a small shared substring of a large existing string: when the larger string should be GC'ed, it winds up being retained as a whole because of the still-live shared substring.  Ideally, garbage collectors should handle this case, but few of them do.  The judicious use of <span class="monospace">string-copy</span> can prevent such leaks.</p>
      <p>(b) <span class="monospace">String-copy</span> provides the ability to make a string that is not <span class="monospace">eqv?</span> to any existing string, which is sometimes useful.</p></div></body></html>