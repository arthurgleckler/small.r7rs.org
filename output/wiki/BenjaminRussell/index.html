
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Copyright 2013 by Arthur A. Gleckler. All rights reserved. -->
    <title>BenjaminRussell</title>
    <link href="/trac.css" rel="stylesheet" type="text/css"></head>
  <body>
    <header>This site is a static rendering of the <a href="https://trac.edgewall.org/">Trac</a> instance that was used by <a href="http://scheme-reports.org/2015/working-group-1.html">R7RS-WG1</a> for its work on R7RS-small (<a href="/attachment/r7rs.pdf">PDF</a>), which was ratified in 2013. For more information, see <a href="/">Home</a>. For a version of this page that may be more recent, see <a href="https://github.com/johnwcowan/r7rs-work/blob/master/BenjaminRussell.md">BenjaminRussell</a> in WG2's repo for R7RS-large.</header>
    <ul class="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/ticket/">All tickets</a></li>
      <li><a href="/wiki/">All wiki pages</a></li></ul>
    <h1 class="wiki">Benjamin&shy;Russell</h1>
    <div class="wiki metadata">
      <div class="author">DekuDekuplex</div>
      <div class="time">2010-03-19 00:15:46</div>
      <div class="version">1<span class="comment">Created page.</span><a href="/wiki/BenjaminRussell/history">history</a></div>
      <div class="source"><a href="/wiki/BenjaminRussell/1/source.html">source</a></div></div>
    <div class="wiki text">
      <p>My name is Benjamin L. Russell, and I currently work as a patent
translator in Tokyo, specializing in computer science- and IT-related
specifications.  I majored in computer science in college, specializing
in algorithms, and maintain a programming language theory blog,
<a href="http://dekudekuplex.wordpress.com/">&quot;Monadically Speaking:  Adventures in PLT Wonderland&quot;</a> (&quot;PLT&quot; referring
to &quot;Programming Language Theory,&quot; not to be confused with the PLT
Research Group) (also duplicated
as a <a href="http://dekudekuplex.sakura.ne.jp/blog/en/">WordPress.org private blog</a>).</p>
      <p>As a graduate of Yale University with a Bachelor of Science in Computer
Science, I have been a student of Scheme (originally, of T) since 1990.
Since then, I have been an active participant in various Scheme
discussion groups, including comp.lang.scheme, gmane.lisp.scheme.plt,
and gmane.lisp.scheme.gauche.</p>
      <p>Although professionally, I also work as a patent translator at
Shobayashi International Patent &amp; Trademark Office, personally, I am
actually against software patents, because I believe that they
can potentially inhibit free software (free as in &quot;intellectually free,&quot;
as opposed to &quot;free beer&quot;).</p>
      <p>Having read through many of the <a href="http://www.r6rs.org/ratification/results.html">opinions</a> both for and against the
ratification of draft 5.97 as R6RS, I am convinced that the
rushed ratification of R6RS was a mistake, and that more time should
have been given to adopting a less controversial version of the draft.
In particular, I feel that R6RS violates the spirit of Scheme, as
embodied in the first sentence of every recent Scheme Report as follows:
<br>
       &gt; Programming languages should be designed not by piling feature on top <br>
       &gt; of feature, but by removing the weaknesses and restrictions that make <br>
       &gt; additional features appear necessary.&quot; <br></p>
      <p>Specifically, I believe that the following features of R6RS go against
this spirit:</p>
      <ul>
        <li>case sensitivity</li></ul>
      <p>Scheme has never been a case-sensitive language, and case
  sensitivity is a fundamental change.  Case-sensitivity causes the
  language to be more difficult to learn for beginners, especially
  children, and interferes with the role of Scheme as a pedagogical
  language for computer science.</p>
      <ul>
        <li>the size of the standard library</li></ul>
      <p>While each individual library is useful, the sum of all the standard
  libraries put together is too much.  For certain other programming
  languages, such as PERL, there is a common repository of libraries
  available, coupled with a relatively small core language.  Requiring
  such a large set of libraries as part of the standard has at least
  two major disadvantages:</p>
      <p>1) Any implementation conforming with R6RS much devote many resources to implementing those libraries, discouraging small organizations and vendors from creating an R6RS-compliant Scheme.</p>
      <p>2) So many standard libraries render R6RS Scheme impractical for most current embedded systems, which are limited in available memory and processing power.  Since Scheme is often used as a scripting language, a small collection of standard libraries would encourage the use of Scheme for developing embedded systems; the set of standard libraries in R6RS Scheme, on the other hand, discourages such development.  Instead, Chris Hanson proposed an <a href="http://www.r6rs.org/ratification/results.html#X78">alternative</a> to the current module system, as follows:</p>
      <p>&gt; Rather than invent a new language to do this, it's possible to build <br>
       &gt; the linker such that the programmer can insert code to control aspects <br>
       &gt; of the linking process.  Such code could do _more_ than the current <br>
       &gt; module system does, and because of the added expressivity, it could do <br>
       &gt; so more concisely in many cases.  For example, I sometimes use a <br>
       &gt; trivial module system in which names starting with &quot;%&quot; are local, and <br>
       &gt; all other names are exported.  This is a trivial program to write, and <br>
       &gt; doesn't depend on the details of the names, but it can't be said at all <br>
       &gt; with the proposed module system.<br></p>
      <p>Hanson's alternative is, I believe, much more in keeping with the spirit
of Scheme than the current module system, since it allows writing more
concise code that simultaneously allows a finer degree of control.</p>
      <p>Recently, MIT has ceased using Scheme in its introductory 6.001 computer
science course, and has chosen to replace Scheme with Python.  Further,
Scheme has recently been criticized for not being a language capable of
coping with the modern style of software development, which focuses on
using teams of developers to use and modify existing code without fully
understanding how the existing code works, rather than having individual
developers creatively write code from scratch.</p>
      <p>Furthermore, Scheme has been criticized for not having features demanded
by most modern languages in order to support such needs as developing
Web applications, networking, and graphical user interfaces.  Most
modern applications require some sort of interaction with the Web, which
requires communication with the external environment.  Since Scheme's
strengths lie in continuations and syntactic abstraction, rather than in
interaction with the external environment, in order for Scheme to
survive as Scheme, the language must simultaneously move in two opposite
directions:</p>
      <p>1) Scheme must provide certain features demanded in most modern
    programming languages; specifically, some sort of package repository
    containing libraries useful for writing Web applications, networking
    tools, and applications that provide graphical user interface
    elements should be provided, and the standard should provide a basis
    for such a repository.</p>
      <p>2) At the same time, Scheme must continue to adhere to the original
    spirit of Scheme, by avoiding &quot;piling feature upon feature,&quot; and
    instead by &quot;removing the weaknesses and restrictions that make
    additional features appear necessary.&quot;</p>
      <p>While at first sight, these appear to be conflicting goals, I believe
that they can be reconciled.  What is needed is a small language that
nevertheless has a large common repository full of libraries useful for
developing Web applications, networking applications, applications with
graphical user interface elements, robotics, and the like; which
encourages individual Scheme developers to be creative in using such
features as syntactic abstraction and continuations within their
programs, while still mandating a certain style of interfacing with
other Scheme programs; and which is conducive to allowing teams of
programmers to share code without needing to understand all the details
of the behavior within, while still allowing individual programmers to
be creative in using syntactic abstractions and manipulating control
flow within.</p>
      <p>For R7RS, I believe that some of the design goals of the Scheme
programming language should be the following:</p>
      <p>A) Find a way to overcome what such schools as MIT apparently
    currently see as weaknesses in Scheme vis–à–vis such other
    programming languages as Python, by supporting such needs as Web
    application development, networking, GUI support, and robotics,
    without bloating the language with a huge module system.  Build the
    linker such that the programmer can insert code to control aspects
    of the linking process.  Provide a common repository of packages for
    Scheme, similar to that currently available for Python.</p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B) Find a way of reconciling the conflicting goals of encouraging programmer collaboration and encouraging creativity.  One of the reasons that MIT dropped Scheme for its introductory <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;course in computer science was that Scheme did not provide any means for supporting software development by teams of programmers.  According to the <a href="http://www.cs.berkeley.edu/~bh/ssch0/preface.html">Preface</a> of _Simply Scheme: <BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Introducing Computer Science, Second Edition_ <a href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=3662">&#91;1&#93;</a>, by Brian Harvey and Matthew Wright:  <BR>

      <p>&gt; There are two schools of thought about teaching computer science.<br>
       &gt; We might caricature the two views this way:<br>
       &gt; <br>
       &gt; •	    	The conservative view: Computer programs have become too<br>
       &gt; large and complex to encompass in a human mind. Therefore, the job<br>
       &gt; of computer science education is to teach people how to discipline<br>
       &gt; their work in such a way that 500 mediocre programmers can join<br>
       &gt; together and produce a program that correctly meets its<br>
       &gt; specification.<br>
       &gt; <br>
       &gt; •	    	The radical view: Computer programs have become too<br>
       &gt; large and complex to encompass in a human mind. Therefore, the job<br>
       &gt; of computer science education is to teach people how to expand<br>
       &gt; their minds so that the programs can fit, by learning to think in<br>
       &gt; a vocabulary of larger, more powerful, more flexible ideas than<br>
       &gt; the obvious ones. Each unit of programming thought must have a big<br>
       &gt; payoff in the capabilities of the program.<br></p>
      <p>I believe that, historically, Scheme has represented &quot;the radical
    view,&quot; while Python, at least as it is currently used in teaching
    computer science at MIT, now represents &quot;the conservative view&quot;
    (replacing Pascal in its historical role).</p>
      <p>While personally in favor of the former school of thought, I believe
    that some provision must also be made for support for the latter in
    order to provide a viable alternative to Python as a tool for
    teaching introductory computer science courses at such schools as
    MIT, yet without sacrificing support for the former.</p>
      <p>To this end, I belive that students should be taught to be creative
    without re-inventing the wheel.  One of the main problems with the
    latter school of thought, in the manner described by Harvey and
    Wright, is that it encourages inefficiency and silliness.</p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For example, consider the following examples of code defining the square function (quoted from <a href="http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=3662">&#91;1&#93;</a>):  

      <p>[In Scheme:]</p>
      <p><span class="monospace">(define (square num)</span><br>
      <span class="monospace">(* num num))</span><br></p>
      <p>[In Pascal:]</p>
      <p><span class="monospace">function SquareOfWholeNumber(num: integer): integer;</span><br>
      <span class="monospace">begin</span><br>
        <span class="monospace">SquareOfWholeNumber := num * num</span><br>
      <span class="monospace">end;</span><br>
    <span class="monospace">function SquareOfDecimalNumber(num: real): real;</span><br>
      <span class="monospace">begin</span><br>
        <span class="monospace">SquareOfDecimalNumber := num * num</span><br>
      <span class="monospace">end;</span><br></p>
      <p>In Scheme, when we want to tell the computer to multiply a number by
    itself, we just tell it to do so.</p>
      <p>By contrast, in Pascal, when we want to tell the computer to
    multiply a number by itself, we first need to tell it how to do so
    for one type of number (integers), and then tell it how to do so for
    another type of number (reals).  The reason for this distinction,
    according to Harvey and Wright, is that proponents of the
    &quot;500-mediocre-programmer school&quot; (as Harvey and Wright term it) are:</p>
      <p>&gt; afraid that you might write the square program with whole numbers <br>
       &gt; in mind, and then apply it to a decimal fraction by mistake. If <br>
       &gt; you're on a team with 499 other programmers, it's easy to have <br>
       &gt; failures of communication so that one programmer uses another's <br>
       &gt; program in unintended ways.&quot; <br></p>
      <p>However, this style of development stifles creativity and encourages
    inefficiency.  It's hard to be creative when forced to think in the
    same way as every other programmer.  This is silly.</p>
      <p>One solution is to alleviate the need for Scheme programmers to
    reinvent the wheel by providing means to develop a rich repository
    of packages common to all implementations of Scheme.</p>
      <p>One of the problems with the current state of Scheme is that while
    each implementation has its own advantages, each implementation also
    has disadvantages sufficient enough to discourage widespread use,
    and implementations cannot be combined easily.  This state of
    affairs needs to be overcome if Scheme is to prosper as a language.
    While I'm not advocating establishing a reference implementation, I
    do believe that a much wider set of cross-implementation features
    than is currently available should be established.  Instead of
    creating many implementation-specific features, Scheme programmers
    should be able to create many cross-implementation features.</p>
      <p>In order for this to happen, a suitable framework needs to be
    developed without bloating the language.  I believe that the
    combination of a linker with a rich cross-implementation repository
    of packages could help to address this need.</p>
      <p>C) Remain true to the original spirit of Scheme, by avoiding &quot;piling
    feature upon feature,&quot; and instead by &quot;removing the weaknesses and
    restrictions that make additional features appear necessary.&quot;
    Specifically, features of R6RS that either inhibit its use by
    beginners (such as case-sensitivity) or bloat the language (the
    module system) should be reduced and, if necessary, replaced by more
    elegant features (such as a linker).</p>
      <p>One controversial issue, which I didn't mention in my original statement
in volunteering for working group 1, but which I am interested in
covering, is that of Unicode.  As a translator, I work with many
bilingual Japanese/English documents, and for most people whose native
language is not English, lack of Unicode is at least somewhat
detrimental to reading code.  One reason that <a href="http://practical-scheme.net/gauche/index.html">Gauche Scheme</a>, an implementation of
R5RS Scheme with Unicode support, is one of the most popular
implementations of Scheme in Japan is that it supports Unicode.</p>
      <p>For example, there is an online textbook for Gauche Scheme, entitled
<a href="http://karetta.jp/book-cover/gauche-hacks">&quot;Karetta | Gauche Programming (Browsing Version)&quot;</a> (in Japanese), in which one
section, entitled &quot;Generate HTML Easily,&quot; describes writing a script to
use the text.html-lite library to output the first three days of the
week in Japanese.  It turns out that the first three days of the week in
Japanese are not represented by &quot;Sunday, &quot;Monday,&quot; and &quot;Tuesday,&quot; but by
the corresponding Japanese Kanji characters (&quot;日&quot; (&quot;Nichi&quot;), &quot;月&quot;
(&quot;Getsu&quot;), and &quot;火&quot; (&quot;Ka&quot;)).  Here is the commented code for the listed
function:
<br>
       &gt; (html:tr (map html:td (list &quot;日&quot; &quot;月&quot; &quot;火&quot;))) ;; html:tdをmapでリストに適用</p>
      <p>This code performs a useful function, and requires Unicode support in
order to be useful.  The comment reads &quot;apply html:td with map to the
list&quot; in Japanese.  Notice that the comment also requires Unicode.
Without Unicode, neither the days of the week nor the comment could not
be written in Japanese, thus alienating beginning native Scheme
programmers interested in referring to the days of the week in the
vernacular who also need a line-by-line commentary, preferably in-line,
in a language that they can understand.</p>
      <p>The same situation applies to almost any other alphabet which contains
characters not representable in ASCII:  Hebrew, Latin, Cyrillic, Greek,
Georgian, Armenian, Ethiopic, Arabic, Devanagari, Bengali, Gurmukhi,
Gujarati, Oriya, Tamil, Telugu, Kannada, Malayalam, Sinhala, Myanmar,
Khmer, Thai, Lao, Tibetan, Chinese, Hangul, and Mongolian, to name a few
examples (see <a href="http://homepage2.nifty.com/PAF00305/lib/unicode.html">&quot;Unicode Test Page ♦ ユニコード テスト ページ [Unicode Test Page</a>&quot;]).</p>
      <p>Therefore, I believe that support for Unicode does not constitute an
instance of &quot;piling feature upon feature,&quot; but provides functionality
necessary for internationalization.</p>
      <p>I hope to contribute to the success of working group 1 by helping to
guide discussion, and by providing documentation of any features agreed
to by the group consensus.  This documentation could then be used as a
basis by working group 2.</p>
      <p>-- Benjamin L. Russell</p>
      <p>[1] Harvey, Brian and Matthew Wright.  _Simply Scheme: Introducing
Computer Science, Second Edition._ Cambridge, MA: The MIT Press,</p>
      <ol class="number" start="1999">
        <li>&lt;http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&amp;tid=3662&gt;.</li></ol></div></body></html>