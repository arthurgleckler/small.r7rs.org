
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Copyright 2013 by Arthur A. Gleckler. All rights reserved. -->
    <title>Source for wiki AdvancedArraysCowan version 4</title>
    <link href="/trac.css" rel="stylesheet" type="text/css"></head>
  <body>
    <header>This site is a static rendering of the <a href="https://trac.edgewall.org/">Trac</a> instance that was used by <a href="http://scheme-reports.org/2015/working-group-1.html">R7RS-WG1</a> for its work on R7RS-small (<a href="/attachment/r7rs.pdf">PDF</a>), which was ratified in 2013. For more information, see <a href="/">Home</a>.</header>
    <ul class="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/ticket/">All tickets</a></li>
      <li><a href="/wiki/">All wiki pages</a></li></ul>
    <h1>Source for wiki AdvancedArraysCowan version 4</h1>
    <h2>author</h2>
    <pre>cowan</pre>
    <h2>comment</h2>
    <pre></pre>
    <h2>ipnr</h2>
    <pre>198.185.18.207</pre>
    <h2>name</h2>
    <pre>AdvancedArraysCowan</pre>
    <h2>readonly</h2>
    <pre>0</pre>
    <h2>text</h2>
    <pre>This is a continuation of ArraysCowan, put on a separate page for convenience.

== Advanced procedures ==

These procedures are mostly derived in function, and sometimes in name, from ISO/IEC 8485 and ISO 17351, which standardize basic and extended APL respectively.

`(array-collapse `''array''` `''j''`)`

Let ''k'' be the rank of ''array''.  This procedure returns an array of rank ''j'', which MUST be less than or equal to ''k'', whose components are arrays of rank ''k'' - ''j''.  The shape of the returned array is equal to the first ''j'' components of the shape of ''array'', and the shapes of its subarrays are equal to the remaining ''k''-''j'' components.

`(array-explode `''array''` `''j''`)`

Let ''k'' be the rank of ''array''.  This procedure constructs and returns an array of rank ''j'', which MUST be greater than or equal to ''k''.  Each component of ''array'' MUST be an array of rank ''j'' - ''k'', all of which MUST have the same shape.  The shape of the returned array is the shape of ''array'' concatenated with the shape of any of its components, and each component is the corresponding component of the corresponding subarray of ''array''.

`(array-reshape `''shape''` `''array''`)`

Constructs and returns a new array of shape ''shape'' whose components in row-major order are the same (in the sense of `eqv?`) as the components of ''array'' in row-major order.

`(array-reverse `''array''` `''axis''`)`

Constructs and returns a new array with the same shape as ''array'', but whose elements on the specified ''axis'' are reversed.  ''Axis'' must be a non-negative integer less than the rank of ''array''.

`(array-reverse! `''array''` `''axis''`)`

Overwrites ''array'' with the value of `(array-reverse `''array''` `''axis''`)`, but without allocating storage.

`(array-compress `''array''` `''booleans''` `''axis''`)`

`(array-expand `''array''` `''booleans''` `''nil''` `''axis''`)`

`(array-rearrange `''array''` `''vector''` `''axis''`)`

`(array-rearrange-axes `''array''` `''vector''`)`

`(subarray `''array''` `''start-subscripts''` `''end-subscripts''`)`

`(array-recursive-ref `''array''` `''subscript'' ...`)`

Apply `array-ref` to the ''array'' using the first ''i'' subscripts, where ''i'' is the rank of ''array''.  If there are more subscripts, the result MUST be an array. Apply `array-ref` to the result using the next ''j'' subscripts, where ''j'' is the rank of the result.  Repeat until there are no more subscripts, returning the last result.


== Higher-order procedures ==

These procedures are mostly derived in function, and sometimes in name, from ISO/IEC 8485 and ISO 17351, which standardize basic and extended APL respectively.

`(array-reduce `''proc''` `''array''` `''axis''`)`

Construct and return a new array whose rank is one less than the rank of ''array'', by combining all the elements along ''axis'' using ''proc'', which MUST be a two-argument procedure.  The order and number of invocations of ''proc'' is unspecified.  If there is only one such element, it is unchanged.

`(array-reduce-subarrays `''proc''` `''array''` `''axis''` `''n''`)`

Construct and return a new array with the same rank as the rank of ''array'', by combining all the groups of elements of length ''n'' along ''axis'' using ''proc'', which MUST be a two-argument procedure.  The order and number of invocations of ''proc'' is unspecified.  If there is only one such group of elements, it is unchanged.

`(array-scan `''proc''` `''array''` `''axis''`)`

Construct and return a new array whose shape is the same as the shape of ''array''.  Each element along ''axis'' is constructed by reducing (as if by `array-reduce`) successive prefixes of the elements of ''array'' along that axis.

`(array-outer-product `''proc''` `''array1''` `''array2''`)`

Construct and return a new array whose shape is the concatenation of the shapes of ''array1'' and ''array2''.  Each component of the new array is the result of applying ''proc'' to every element of ''array1'' and every element of ''array2'' in unspecified order.  The order and number of invocations of ''proc'' is unspecified.

`(array-inner-product `''proc1''` `''proc2''` `''array1''` `''array2''`)`

</pre>
    <h2>time</h2>
    <pre>2010-10-02 01:10:59</pre>
    <h2>version</h2>
    <pre>4</pre></body></html>