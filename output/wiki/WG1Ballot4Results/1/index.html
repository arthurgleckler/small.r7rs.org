
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Copyright 2013 by Arthur A. Gleckler. All rights reserved. -->
    <title>WG1Ballot4Results</title>
    <link href="/trac.css" rel="stylesheet" type="text/css"></head>
  <body>
    <header>This site is a static rendering of the <a href="https://trac.edgewall.org/">Trac</a> instance that was used by <a href="http://scheme-reports.org/2015/working-group-1.html">R7RS-WG1</a> for its work on R7RS-small (<a href="/attachment/r7rs.pdf">PDF</a>), which was ratified in 2013. For more information, see <a href="/">Home</a>. For a version of this page that may be more recent, see <a href="https://github.com/johnwcowan/r7rs-work/blob/master/WG1Ballot4Results.md">WG1Ballot4Results</a> in WG2's repo for R7RS-large.</header>
    <ul class="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/ticket/">All tickets</a></li>
      <li><a href="/wiki/">All wiki pages</a></li></ul>
    <h1 class="wiki">WG1Ballot4Results</h1>
    <div class="wiki metadata">
      <div class="author">alexshinn</div>
      <div class="time">2011-09-11 07:16:32</div>
      <div class="version">1<span class="comment">adding fourth ballot results</span><a href="/wiki/WG1Ballot4Results/history">history</a></div>
      <div class="source"><a href="/wiki/WG1Ballot4Results/1/source.html">source</a></div></div>
    <div class="wiki text">
      <h2 id="WG1-Core">WG1 - Core</h2>
      <h3 id="#102modulesyntaxname"><a href="/ticket/102">#102</a> module syntax name</h3>
      <p>We decided on <span class="monospace">module</span> earlier, and the current draft reflects that,
but some comments from the community suggest we revisit this issue.</p>
      <p>Emails from Aaron Hsu and Denis Washington:</p><span class="monospace">[AH] I do not buy the argument that we are making things better by
using `module` instead of `library` in this case. The module term is
much more common throughout, including systems in Chez, PLT, Scheme48
(I believe), among others.

[...]

[DW] (Bigloo and Chicken are two others which use `module` for
existing forms.) I feel that clashing with all of these
implementations substantially increases the burden for these systems'
implementors to adopt to R7RS.

[...]

[DW] What about `define-library`? It might be slightly confusing as it
sounds a bit procedural for a purely syntactic construct, but it does
not seem to clash with any existing implementation (as far as a quick
Google search reveals, at least [as well as direct testing --JC]) and
preserves the &quot;library&quot; term, which is common, well-known, clear and
in line with previous Scheme specs (R6RS and, in a way, R5RS' usage of
the term &quot;library procedure&quot;).
</span>
      <p>If we choose a unique name such as <span class="monospace">define-library</span> then there is no
chance of conflicts, but the name itself may not be aesthetically
pleasing.</p>
      <p>If we choose an existing name, implementations may have difficulty
distinguishing between their native form and the R7RS module syntax,
possibly requiring a command-line flag for &quot;R7RS mode&quot; or some such.</p>
      <p>TODO: Create a list of existing names used, and ways implementations
may detect the difference in the event of a conflict.</p>
      <ul>
        <li><b>Options:</b> module, library, define-module, define-library</li>
        <li><b>Default:</b> module</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: define-library, define-module</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: library</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: define-library, define-module, module, library</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: r7rs-module, abstraction, library, component, undecided, define-library, define-module, module, package</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: define-library</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: (define-module define-library), library, module</li></ul></li>
        <li><b>Results:</b> <b>define-library</b>, define-module, library, module, r7rs-module, abstraction, component, undecided, package</li>
        <li><b>Ratios:</b> 4:0, 4:2, 5:0, 4:1, 4:1, 4:1, 4:1, 5:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I strongly dislike the term library, but R6RS has chosen it. We need to use something different than the <span class="monospace">library' form, though, to avoid compatibility problems, so I'm choosing </span>define-library'.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Other possible names without clashing: abstraction component r7rs-module Name clash occurs with: module package (<a href="/wiki/Snow">Snow</a>) define-module (Gauche)</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Reversed from my earlier decision, we need to avoid conflicts and I haven't seen any better names.</dd></dl>
      <h3 id="#145RFC2119compliance"><a href="/ticket/145">#145</a> RFC 2119 compliance</h3>
      <p>R6RS introduces a description of requirement levels following
<a href="http://tools.ietf.org/html/rfc2119">RFC 2119</a> use of the modal verbs
&quot;may&quot;, &quot;should&quot;, &quot;must&quot;, &quot;shall&quot;, &quot;should not&quot;, &quot;must not&quot;, &quot;shall
not.&quot;</p>
      <p>Do we want to incorporate this?  If so, we'll also need to revise
existing uses of those phrases, and possibly introduce them where
needed.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: no, undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes, undecided, no</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no, undecided</li>
        <li><b>Ratios:</b> 5:2, 5:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Best to avoid &quot;should&quot; and &quot;should not&quot; entirely.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>This is more trouble than it's worth. We haven't had this in all the previous revisions of the standard and we've been just fine.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>It's a weak yes. I like the idea of defining these terms more tightly.</dd></dl>
      <h3 id="#185Addsixth&quot;centered&quot;divisionoperator"><a href="/ticket/185">#185</a> Add sixth &quot;centered&quot; division operator</h3>
      <p>We are re-opening the sixth &quot;centered&quot; division operator:</p>
      <ul>
        <li><span class="monospace">(centered/ x y)</span></li>
        <li><span class="monospace">(centered-quotient x y)</span></li>
        <li><span class="monospace">(centered-remainder x y)</span></li></ul>
      <p>These correspond to the R6RS operators <span class="monospace">div0</span>, <span class="monospace">mod0</span> and
<span class="monospace">div0-and-mod0</span> defined as in the Guile manual:</p><span class="monospace">These procedures accept two real numbers x and y, where the divisor y
must be non-zero. centered-quotient returns the integer q and
centered-remainder returns the real number r such that x = q*y + r and
-|y/2| &lt;= r &lt; |y/2|. centered/ returns both q and r, and is more
efficient than computing each separately.

Note that centered-quotient returns x/y rounded to the nearest
integer. When x/y lies exactly half-way between two integers, the tie
is broken according to the sign of y. If y &gt; 0, ties are rounded
toward positive infinity, otherwise they are rounded toward negative
infinity. This is a consequence of the requirement that -|y/2| &lt;= r &lt;
|y/2|.
</span>
      <p>Vote <span class="monospace">centered</span> to add the sixth operator, <span class="monospace">no</span> to stick with the five
operators, and <span class="monospace">remove</span> to drop the full five sets of operators from
the small language.</p>
      <ul>
        <li><b>Options:</b> centered, no, remove, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: centered, no</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: centered, undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: centered, no</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: remove, no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: centered, no, undecided, remove</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: remove, no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: remove, centered, no</li></ul></li>
        <li><b>Results:</b> <b>centered</b>, no, undecided, remove</li>
        <li><b>Ratios:</b> 5:2, 5:1, 4:3</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>We should have the complete set, and it's not hard to implement.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>I don't understand these well enough to vote on them yet.</dd>
        <dt><span class="monospace">Lucier</span></dt>
        <dd>(1) I don't see the &quot;centered-*&quot; operators as somehow a &quot;completion&quot; of the other division operators. (2) In the small language I'd recommend only the &quot;truncate-*&quot; and &quot;floor-*&quot; operators for two reasons: they are the only division operators that have an established history of use in computer programming and mathematics, and they form a minimal extension of R5RS. (I'm not saying that the other division operators have never been used in mathematics or programming (see CL), but small Scheme is not supposed to be a kitchen-sink language.)</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>We need to use and understand all of these operators more before deciding. Some of the newly proposed operators have no known use in existing programs to my knowledge.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I used to be for these, but I'm starting to veer towards having a simple set in WG1, and having the full set as a module in WG2 or an SRFI.</dd></dl>
      <h3 id="#193valuesandprocedurearguments"><a href="/ticket/193">#193</a> values and procedure arguments</h3>
      <p>A suggestion was made to specify that arguments in a procedure call
and &quot;init bindings&quot; (presumably in <span class="monospace">let</span> and friends) should evaluate
to exactly one value.  Currently it is &quot;an error&quot; to pass a non-single
value to any continuation not created with call-with-values, which
means implementations are free to add their own handling of this
(e.g. raising an error or taking just the first value as in CL).</p>
      <p>Do we want to require implementations to signal an error in these
cases?  Not currently many implementations of MV would not be able to
detect these cases efficiently.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: no</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: no, undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: no</li></ul></li>
        <li><b>Results:</b> <b>no</b>, undecided</li>
        <li><b>Ratios:</b> 7:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>As John points out, there are few places where we require signaling an error. This situation doesn't merit special treatment.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>The current situation is that some implementations truncate values to the first one, others signal an error, others reifie values, etc. Hence we cannot reach a consensus on this issue and as such one could not rely on it to write portable robust code using multiple values in a single value context. Ok I agree now that signaling an error is a bit too much.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>No, this is silly.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I think this should be allowed behaviour, in fact, with the defined semantics of taking the first value and discarding others; this allows future extension by returning extra values that old code can then easily discard. Returning zero values should be an error, of course, but for implementation convenience, I would be inclined to allow it to return a value that causes an error if it's actually used for anything (eg, allow zero return values to be implemented by returning a special sentinel value; it needn't fail at the binding site and may fail on the first type dispatch).</dd></dl>
      <h3 id="#202Semi-Editorial:ShouldweremovethespecificsyntaxesfromtheBNFinsection7?"><a href="/ticket/202">#202</a> Semi-Editorial: Should we remove the specific syntaxes from the BNF in section 7?</h3>
      <p>These date back to R4RS, when Scheme had a fixed syntax and it made
sense to enumerate it here.  Are they still doing useful work, now
that syntax forms can be changed at will?</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: no</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: no, undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no, yes, undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>no</b>, yes, undecided</li>
        <li><b>Ratios:</b> 5:2, 5:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Don't remove. Standard syntax provides better grounding than &quot;floating&quot; nonterminals.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Even if they can be changed, it's good to have them enumerated for reference.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>This is intended to describe fundamental Scheme with no macro extensions.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Drop these, they don't belong when describing a language without fixed syntax.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Yes, they should go, or else the syntax is not correct.</dd></dl>
      <h3 id="#212LetLOADtakeanoptionalenvironmentargument"><a href="/ticket/212">#212</a> Let LOAD take an optional environment argument</h3>
      <p>Change <span class="monospace">load</span> to take a second argument which is the environment to
load into.  The default is <span class="monospace">(interaction-environment)</span>.</p>
      <p>See also <a href="/ticket/161">#161</a>.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes, undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes, no, undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: no</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no, undecided</li>
        <li><b>Ratios:</b> 5:1, 5:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I agree with Aaron's comments about also allowing for an evaluator (but one of two arguments).</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>This makes `load' much more useful.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>It is a change worth to consider.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>This just doesn't feel right to me. Hard to put my finger on exactly why, though.</dd></dl>
      <h3 id="#220NewDIGIT-VALUEprocedure"><a href="/ticket/220">#220</a> New DIGIT-VALUE procedure</h3>
      <p>This accepts a character which is a numeric digit and returns its
value as a digit, or <span class="monospace">#f</span> if it's not a digit:</p><span class="monospace">(digit-value #\3) =&gt; 3
(digit-value #\x0664) =&gt; 4
(digit-value #\x0EA6) =&gt; 0
</span>
      <p>You need the following list of zero-value characters to implement this
for all of Unicode (currently); implementations that support only a
subset of Unicode need only a subset of the list, of course:</p><span class="monospace">(define zeros '(
  #\x0030 ;DIGIT ZERO
  #\x0660 ;ARABIC-INDIC DIGIT ZERO
  #\x06F0 ;EXTENDED ARABIC-INDIC DIGIT ZERO
  #\x07C0 ;NKO DIGIT ZERO
  #\x0966 ;DEVANAGARI DIGIT ZERO
  #\x09E6 ;BENGALI DIGIT ZERO
  #\x0A66 ;GURMUKHI DIGIT ZERO
  #\x0AE6 ;GUJARATI DIGIT ZERO
  #\x0B66 ;ORIYA DIGIT ZERO
  #\x0BE6 ;TAMIL DIGIT ZERO
  #\x0C66 ;TELUGU DIGIT ZERO
  #\x0CE6 ;KANNADA DIGIT ZERO
  #\x0D66 ;MALAYALAM DIGIT ZERO
  #\x0E50 ;THAI DIGIT ZERO
  #\x0ED0 ;LAO DIGIT ZERO
  #\x0F20 ;TIBETAN DIGIT ZERO
  #\x1040 ;MYANMAR DIGIT ZERO
  #\x1090 ;MYANMAR SHAN DIGIT ZERO
  #\x17E0 ;KHMER DIGIT ZERO
  #\x1810 ;MONGOLIAN DIGIT ZERO
  #\x1946 ;LIMBU DIGIT ZERO
  #\x19D0 ;NEW TAI LUE DIGIT ZERO
  #\x1A80 ;TAI THAM HORA DIGIT ZERO
  #\x1A90 ;TAI THAM THAM DIGIT ZERO
  #\x1B50 ;BALINESE DIGIT ZERO
  #\x1BB0 ;SUNDANESE DIGIT ZERO
  #\x1C40 ;LEPCHA DIGIT ZERO
  #\x1C50 ;OL CHIKI DIGIT ZERO
  #\xA620 ;VAI DIGIT ZERO
  #\xA8D0 ;SAURASHTRA DIGIT ZERO
  #\xA900 ;KAYAH LI DIGIT ZERO
  #\xA9D0 ;JAVANESE DIGIT ZERO
  #\xAA50 ;CHAM DIGIT ZERO
  #\xABF0 ;MEETEI MAYEK DIGIT ZERO
  #\xFF10 ;FULLWIDTH DIGIT ZERO
  #\x104A0 ;OSMANYA DIGIT ZERO
  #\x11066 ;BRAHMI DIGIT ZERO
  #\x1D7CE ;MATHEMATICAL BOLD DIGIT ZERO
  #\x1D7D8 ;MATHEMATICAL DOUBLE-STRUCK DIGIT ZERO
  #\x1D7E2 ;MATHEMATICAL SANS-SERIF DIGIT ZERO
  #\x1D7EC ;MATHEMATICAL SANS-SERIF BOLD DIGIT ZERO
  #\x1D7F6 ;MATHEMATICAL MONOSPACE DIGIT ZERO
))

(define (digit-value ch) (digit-value* ch zeros))

(define (digit-value* ch zeros)
  (if
    (null? zeros)
    #f
    (let*
      ((val (char-&gt;integer ch))
       (val0 (char-&gt;integer (car zeros)))
       (val9 (+ val0 9)))
        (if
          (and (&lt;= val0 val) (&lt;= val val9))
          (- val val0)
          (digit-value* ch (cdr zeros))))))

</span>
      <p>CL provides this as <span class="monospace">digit-char-p</span>, which is its substitute for
<span class="monospace">char-numeric?</span>.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes, undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes, undecided, no</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, undecided, no</li>
        <li><b>Ratios:</b> 6:0, 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>As John points out, this is essential now for implementations that support Unicode now that we support non-ASCII digits.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This belongs in the <span class="monospace">(scheme char)</span> module.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>This is a useful feature, and essential for practical working in international environments, I suspect.</dd></dl>
      <h3 id="#221Editorial:Consolidateandclarifyformal-parameterconventions"><a href="/ticket/221">#221</a> Editorial: Consolidate and clarify formal-parameter conventions</h3>
      <p>Page 4 shows a naming convention for procedure
parameters:</p>
      <ul>
        <li>obj - any object</li>
        <li>list - list</li>
        <li>z - complex</li></ul>
      <p>and so on.</p>
      <p>There is no notation convention for characters and strings.
It feels a bit funny that the document uses this notation and
then x, x_1, x_2 are used for reals, but then uses &quot;char_1&quot;
and &quot;char_2&quot; for characters.</p>
      <ul>
        <li><b>Proposals:</b>
          <ul>
            <li><b>abbrev:</b> abbreviate <span class="monospace">char</span> =&gt; <span class="monospace">ch</span> and <span class="monospace">string</span> =&gt; <span class="monospace">str</span></li>
            <li><b>list:</b> just add <span class="monospace">char</span> and <span class="monospace">string</span> to the list of conventions</li></ul></li>
        <li><b>Options:</b> abbrev, list, none, undecided</li>
        <li><b>Default:</b> none</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: list, abbrev</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: abbrev, list, undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: list, abbrev</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: list, no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: abbrev, list</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: abbrev, list</li></ul></li>
        <li><b>Results:</b> <b>list</b>, abbrev, no, undecided</li>
        <li><b>Ratios:</b> 3:3, 6:1, 6:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>This will make the document clearer. The abbreviations don't save enough space to be worth doing.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I think this is self-explanatory.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>It makes sense to be consistent.</dd></dl>
      <h3 id="#222Renamecharacterportstotextualports"><a href="/ticket/222">#222</a> Rename character ports to textual ports</h3>
      <p>The term &quot;textual port&quot; is R6RS compatible.</p>
      <ul>
        <li><b>Options:</b> textual, character, undecided</li>
        <li><b>Default:</b> character</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: textual</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: character</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: textual, character</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: character</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: textual, character, undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: textual</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: undecided</li></ul></li>
        <li><b>Results:</b> <b>textual</b>, character, undecided</li>
        <li><b>Ratios:</b> 4:2, 4:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I prefer character, but there's no reason to be different than R6RS here.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Bikeshed, go with R6RS.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>What colour to paint the bikeshed, eh?</dd></dl>
      <h3 id="#223Convertingcurrent-{input,output}-portstobinary"><a href="/ticket/223">#223</a> Converting current-{input,output}-ports to binary</h3>
      <p>The standard input and output ports which <span class="monospace">current-input-port</span> and
<span class="monospace">current-output-port</span> are initially bound to are not opened
explicitly.  They default to character ports.  Should they be
replaceable with equivalent binary ports using the following
procedures?</p>
      <ul>
        <li>(standard-input-is-binary!)</li>
        <li>(standard-output-is-binary!)</li></ul>
      <p>It is an error to call either of these if the corresponding
<span class="monospace">current-{input,output}-port</span> is not the original value, or if any I/O
has been performed on them, or if they cannot reasonably be treated as
binary.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: no</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: no</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: no</li></ul></li>
        <li><b>Results:</b> <b>no</b>, undecided</li>
        <li><b>Ratios:</b> 5:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>This feels super kludgy. I'd rather leave it to implementations than specify something like this.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>It would be nice to do so but we need a better interface than this either to generally change port type or why not something like converting it whan read-u8 as soon as is used ?</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This needs more thought.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Ugly hack. Standard input and output are defined as character streams for the good of repls and the like. Having them as binary streams should be done with some kind of whole-program pragma/option, which we currently have no mechanism in place for, and IMHO this should leave current-input-port and current-output-port still pointing to character ports (current-output-port can be stderr under POSIX, and current-input-port either exist but start off closed or something like that. Windows systems may be perfectly capable of having binary stdin and stdout while presenting a textual console in a window, for example.</dd></dl>
      <h3 id="#224AdditionalblobI/O"><a href="/ticket/224">#224</a> Additional blob I/O</h3>
      <p>See <a href="/wiki/BlobIoShinn">BlobIoShinn</a>, which provides the ability to read and write blobs,
and simple conversions between blobs (interpreted as UTF-8) and
strings.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no</li>
        <li><b>Ratios:</b> 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Yes, but the names should use &quot;bytevector&quot; instead of &quot;blob.&quot;</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Absolutely needed</dd></dl>
      <h3 id="#226Removeproperty-listfilespecsfromWG1"><a href="/ticket/226">#226</a> Remove property-list file specs from WG1</h3>
      <p>Getting rid of file-specs was the motivation for the new binary I/O
API we agreed on, but it was not made explicit in the proposal.
Consequently, although all references to <span class="monospace">file-spec</span> have been removed
from the current draft, we should vote on this for completeness.</p>
      <ul>
        <li><b>Options:</b> remove, keep, undecided</li>
        <li><b>Default:</b> remove</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: remove</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: remove</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: remove</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: remove</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: remove</li></ul></li>
        <li><b>Results:</b> <b>remove</b></li>
        <li><b>Ratios:</b></li></ul>
      <h3 id="#229EQV?andNaN"><a href="/ticket/229">#229</a> EQV? and NaN</h3>
      <p>For good reasons, <span class="monospace">+nan.0</span> is not <span class="monospace">=</span> to any other number, including
itself.  However, <span class="monospace">eqv?</span> is about &quot;sameness&quot; rather than &quot;equality&quot;.</p>
      <p>The <span class="monospace">same</span> proposal is that we add two clauses to the definition of
<span class="monospace">eqv?</span>, one saying that if both arguments are <span class="monospace">+nan.0</span>, <span class="monospace">eqv?</span> must
return <span class="monospace">#t</span>, and if one argument is <span class="monospace">+nan.0</span> and the other is not,
<span class="monospace">eqv?</span> must return <span class="monospace">#f</span>.  This is what R6RS specifies.</p>
      <p>The <span class="monospace">different</span> proposal is that we add a single clause requiring
<span class="monospace">(eqv? +nan.0 x)</span> to return <span class="monospace">#f</span> for any <span class="monospace">x</span>.  This is the behavior
that results for any R5RS implementation that adds support for +nan.0
as an IEEE float without any special handling for it in <span class="monospace">eqv?</span>.</p>
      <p>Note the second clause in the <span class="monospace">same</span> proposal is universally supported
by all implementations with <span class="monospace">+nan.0</span> except for SISC, which appears to
have a bug (see below), so the only thing to decide is the first
clause.</p>
      <p>The following 7 implementations return <span class="monospace">#t</span>: chez, gambit, guile,
ikarus, kawa, racket, stklos.</p>
      <p>The following 7 implementations return <span class="monospace">#f</span>: bigloo, chibi, chicken,
gauche, larceny, mit-scheme, scheme48.</p>
      <p>SigScheme and Scheme 9 don't have +nan.0.  SISC currently has a bug
where <span class="monospace">(= nan.0 x)</span> is true for any <span class="monospace">x</span>.</p>
      <p>Since implementations currently disagree on these semantics, it may
make the most sense to leave this <span class="monospace">unspecified</span>.</p>
      <ul>
        <li><b>Options:</b> same, different, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: same, unspecified</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: same</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: same, unspecified</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: same*</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: same, unspecified, undecided, different</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: unspecified</li></ul></li>
        <li><b>Results:</b> <b>same</b>, unspecified, same*, undecided, different</li>
        <li><b>Ratios:</b> 4:2, 4:1, 4:0, 4:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Let's match R6RS since this is easy to implement. Otherwise, then since implementation differ so much on the semantics, it would better to leave this unspecified than to specify something different than R6RS.</dd>
        <dt><span class="monospace">Lucier</span></dt>
        <dd>*There are possibly many NaNs generated by IEEE-conforming arithmetics; for example Apple used to (and may still) use different NaNs in its arithmetic libraries to indicate which routine generated the initial NaN (which is passed along unchanged in later operations). So +nan.0 may be the textual representation of floating point numbers with different bit patterns. So I would recommend that (let ((x (/ 0. 0.))) (eqv? x x)) =&gt; #t but allow (if (and (real? x) (nan? x) (real? y) (nan? y)) (eqv? x y) #t) to return #f. In other words, two NaNs with the same bit patterns are eqv?, and we still have (eq? x y) implies (eqv? x y). This is such a small thing that I think implementors can do it without much trouble and it's time to get it right.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>It is de facto unspecified.</dd></dl>
      <h3 id="#230Reservemodulenamesforcurrentandfuturestandards"><a href="/ticket/230">#230</a> Reserve module names for current and future standards</h3>
      <p>Do we want to add a clause stating that all module names under the
<span class="monospace">(scheme ...)</span> name are reserved for current and future standards?
Do we want to reserve the <span class="monospace">(srfi ...)</span> names?</p>
      <p>Note the name <span class="monospace">scheme</span> may be changed pending the result of <a href="/ticket/237">#237</a>.</p>
      <ul>
        <li><b>Options:</b> scheme, srfi, both, neither, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: both, scheme, srfi</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: both, scheme, no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: both, scheme, undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: both</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: both</li></ul></li>
        <li><b>Results:</b> <b>both</b>, scheme, undecided, srfi, no, yes</li>
        <li><b>Ratios:</b> 5:0, 5:0, 5:0, 5:0, 5:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Yes, let's keep the way clear for future implementations and SRFIs. But if we don't reserve for future implementations, we shouldn't reserve for SRFIs.</dd></dl>
      <h3 id="#232define-values"><a href="/ticket/232">#232</a> define-values</h3>
      <p>Several implementations provide a <span class="monospace">define-values</span> macro.  This allows
cleanly writing multiple definitions with a shared state for example.</p>
      <p>Should we have it on WG1 or not?</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: undecided</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no, undecided</li>
        <li><b>Ratios:</b> 5:1, 5:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Avoids polluting the global environment.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I don't have a strong preference for including it, but since it is useful, its definition is tiny, and it is supported by several implementations, there's no reason not to.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Enough with the syntactic sugar! Let people write their own, or refer to the large language for common macros.</dd></dl>
      <h3 id="#234AddEAGERfromSRFI45"><a href="/ticket/234">#234</a> Add EAGER from SRFI 45</h3>
      <p><span class="monospace">eager</span>, like <span class="monospace">delay</span>, returns a promise object that can be forced by
<span class="monospace">force</span>, but it evaluates its argument up front (it is a procedure,
not syntax) and stashes it in the promise in such a way that <span class="monospace">force</span>
can access it.</p>
      <p>Semantically, writing <span class="monospace">(eager expression)</span> is equivalent to writing
<span class="monospace">(let ((value expression)) (delay value))</span>.</p>
      <p>Some debate was given as to how useful <span class="monospace">eager</span> is - generally, if
something is known in advance to be eager you don't want to make it a
promise to begin with.  Use cases should be provided if we want to
include this.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes, no, undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: no</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no, undecided</li>
        <li><b>Ratios:</b> 4:3, 4:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>The point is not whether you know in advance that something is to be eager or not. It is that one should be able to feed into a routine over promises that doesn't know or care.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>This is a good symmetry.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>John's example convinced me that this has its place inside the (scheme lazy) module.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I'm not convinced the uses for this are common enough to add it as a procedure instead of just writing <span class="monospace">(let ((value expression)) (delay value))</span>.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I have no interesting use cases.</dd></dl>
      <h3 id="#235Shouldbytevectorconstantsbeself-quoting?"><a href="/ticket/235">#235</a> Should bytevector constants be self-quoting?</h3>
      <p>They are in R6RS, apparently because they are considered more closely
related to strings rather than vectors.</p>
      <p>Note currently vectors are not self-quoting.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: no</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: no</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no</li>
        <li><b>Ratios:</b> 4:3</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>They seem closer to vectors than strings, and in any case that is what the name implies.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Let's not be different from R6RS when it's easy not to be and there aren't good reasons to be.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>There's no reason they shouldn't be.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I think vectors ought to be self-quoting, anyway. What other semantics do they have, other than their own value? There is at most an argument that records ought not to be self quoting, purely so they are useless as unquoted literals, so that they can be used as special markers for code transformers that then cannot be confused for anything in the code. Even then, though, such transformers can just create a private disjoint type and be confident they have full control of the appearance of instances of it.</dd></dl>
      <h3 id="#237Change&quot;scheme&quot;inmodulenamesto&quot;rsn&quot;or&quot;rs11&quot;orsomethingelse"><a href="/ticket/237">#237</a> Change &quot;scheme&quot; in module names to &quot;rsn&quot; or &quot;rs11&quot; or something else</h3>
      <p>The term &quot;scheme&quot; is already in use in module names on some Scheme
implementations.  We need to pick something that nobody is using.</p>
      <p>The term &quot;rnrs&quot; was used by R6RS, but this was integrated with the
library versioning mechanism.  It therefore may not be suitable, and
either way would cause conflicts with existing R6RS modules.</p>
      <p>Feel free to write in a name.</p>
      <ul>
        <li><b>Options:</b> scheme, r7rs, scheme2011, undecided</li>
        <li><b>Default:</b> scheme</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: scheme2011</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: scheme</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: scheme, r7rs, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: scheme, r7rs, undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: r7rs, scheme</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: r7rs</li></ul></li>
        <li><b>Results:</b> <b>scheme</b>, r7rs, undecided, scheme2011</li>
        <li><b>Ratios:</b> 3:2, 4:0, 4:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>&quot;Scheme&quot; is just the right term. I certainly don't want scheme2011, which needlessly emphasizes the year.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Scheme or r7rs are the most natural and expected terms</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>&quot;r7rs&quot; avoids the issue that we don't have explicit versioning capabilities. When and if we have the same modules unchanged across two or more standards, we can use the &quot;scheme&quot; name.</dd></dl>
      <h3 id="#238Reserve#!forreaddirectives"><a href="/ticket/238">#238</a> Reserve #! for read directives</h3>
      <p>From Denis Washington:</p><span class="monospace">Reading chapter 2 of the third draft, I was thinking: now that we have
`#!fold-case` and `#!no-fold-case` and other directives might follow
in WG2, wouldn't it be appropriate for section 2.3 (Other notations)
to define `#!` as generally introducing a &quot;read directive&quot;? That would
encourage implementations to use the same syntax for their own
directives, which helps portability (an implementation could just
ignore unknown directives which might just be used by another for
optimization purposes).
</span>
      <p>Note that since the only use we have alters the reader, the <span class="monospace">!</span> is
consistent with the existing convention for <span class="monospace">!</span>.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: no</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no, undecided, yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>no</b>, yes, undecided</li>
        <li><b>Ratios:</b> 4:3, 4:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>As John points out, some implementations already use the &quot;#!&quot; prefix for other purposes.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This conflicts with other uses of &quot;#!&quot;.</dd></dl>
      <h3 id="#240Renamecurrent-secondtocurrent-tai"><a href="/ticket/240">#240</a> Rename current-second to current-tai</h3>
      <p>The procedure, as currently spec'd, may return a fraction of a second,
and there should be a mention of TAI in it.  <span class="monospace">Current-tai-time</span> is
redundant, since the T in TAI stands for Time (or <i>Temps</i>).</p>
      <ul>
        <li><b>Options:</b> current-second, current-tai-time, current-tai, undecided</li>
        <li><b>Default:</b> current-second</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: current-tai</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: current-tai</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: current-second, current-tai</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: current-second</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: current-second</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: current-second</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: current-tai</li></ul></li>
        <li><b>Results:</b> <b>current-second</b>, current-tai</li>
        <li><b>Ratios:</b> 4:3</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>current-tai identifies the earliest representable time in a way that current-second does not.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>There's no reason that <span class="monospace">current-second' is incompatible with returning fractional second values. And we certainly don't want the redundant </span>current-tai-time'.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>current-second is a good naming choice, describing that this is indeed TAI in the function description is enough.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Yeah, that sounds sensible. I know somebody who goes by the name of &quot;Tai&quot; anyway, and he might be amused by this.</dd></dl>
      <h3 id="#243Addoptionalsupportfor-0.0"><a href="/ticket/243">#243</a> Add optional support for -0.0</h3>
      <p>Implementations should be permitted to distinguish 0.0 from -0.0 in
accordance with IEEE 754.  <span class="monospace">0.0</span> and <span class="monospace">-0.0</span> should be the same to <span class="monospace">=</span>
and friends, but should be distinguishable by <span class="monospace">eqv?</span>.</p>
      <p>Mathematically, negative inexact zero represents a number greater than
the largest representable negative inexact number and less than or
equal to 0.  This is different from positive inexact zero, which
represents a number greater than or equal to 0 and less than the
smallest representable positive inexact number.</p>
      <p>Vote <span class="monospace">yes</span> to adapt the description of -0.0 from R6RS and include
examples where appropriate.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, undecided</li>
        <li><b>Ratios:</b> 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Let's be compatible with R6RS.</dd>
        <dt><span class="monospace">Lucier</span></dt>
        <dd>I can't find what is meant in this issue by &quot;the description of -0.0 from R6RS&quot; after searching for all instances of &quot;-0.0&quot; in r6rs.pdf and r6rs-lib.pdf. There are many helpful examples and statements in R6RS about -0.0, but I don't know what is meant here. The description given in the second paragraph above is descriptive, but it is certainly not proscriptive; in other words, if epsilon is the smallest positive inexact number then (and (&lt;= 0 +0.) (&lt; +0. epsilon)) =&gt; #t but also (and (&lt;= 0 -0.) (&lt; -0. epsilon)) =&gt; #t So I don't know what this ticket means.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>By conformance to IEEE 754</dd></dl>
      <h3 id="#244Extended&quot;OverviewofScheme&quot;chapter"><a href="/ticket/244">#244</a> Extended &quot;Overview of Scheme&quot; chapter</h3>
      <p>Denis Washington said (&lt;http://lists.scheme-reports.org/pipermail/scheme-reports/2011-August/001255.html&gt;):</p><span class="monospace">I would love to see a ticket added about possibly including (some of)
the detailed &quot;Overview of Scheme&quot; chapter from R6RS into the report;
it helps very much to understand the rest of the report and is
invaluable for e.g. students. Would someone from the working group do
this (provided that anyone actually agrees with me)? It would be sad
if this consideration were forgotten.
</span>
      <p>The &quot;Overview of Scheme&quot; in R6RS contains a similar introduction as in
the section of the same name in R5RS, followed by a rough tutorial
describing the basic syntax and data types.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes, undecided, no</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no, undecided</li>
        <li><b>Ratios:</b> 6:1, 6:0, 6:0, 6:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I'd leave out examples unless we can be sure of reasonably complete coverage, which may take a lot of space.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>We should be certainly include the first section of the Overview of Scheme from R6RS, and should include more if possible. I can help adapt the old text.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This is not a normative part of the report, nor do I feel does it provide a particularly good tutorial, which should be tailored to different types of students. It just presents a watered-down version of the same descriptions provided later in the same, relatively short document.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>This is a fine idea, and will help people who are not experienced Schemers to read the spec. This can only help us to publicise R7RS in the wider world.</dd></dl>
      <h3 id="#245Editorial:Case-foldingshouldrefertoUAX"><a href="/ticket/245">#245</a> Editorial: Case-folding should refer to UAX</h3>
      <p>In the string case conversion, it mentions the context sensitivity of
Greek sigma: A small final sigma needs to be used when it is at the
end of the word.  However, there's no definition of &quot;word&quot;, which can
lead inconsistent behavior among implementations.  We can refer to UAX
<a href="/ticket/29">#29</a>, as R6RS does.</p>
      <p>Vote <span class="monospace">uax-29</span> for the reference, or <span class="monospace">unspecified</span> to leave this up to
the implementation.</p>
      <ul>
        <li><b>Options:</b> uax-29, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: uax-29</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: uax-29</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: uax-29</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: uax-29</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: undecided, uax-29</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: uax-29</li></ul></li>
        <li><b>Results:</b> <b>uax-29</b>, unspecified, undecided</li>
        <li><b>Ratios:</b> 6:1, 5:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>We can say &quot;_should_ follow UAX-29&quot; here.</dd></dl>
      <h3 id="#248fill-stringandfill-vector:optionalstart/endarguments?"><a href="/ticket/248">#248</a> fill-string and fill-vector: optional start/end arguments?</h3>
      <p>Should we provide the obvious way to fill part of a string or vector?</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no</li>
        <li><b>Ratios:</b> 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>These are easy to implement, useful, and may be faster if the implementation provides them.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Fill-string is an abomination, fill-vector belongs in a larger vector library.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Much as I hate the imperativity of these, they should be general rather than specific.</dd></dl>
      <h3 id="#254Behaviorofopen-output-fileonexistingfiles"><a href="/ticket/254">#254</a> Behavior of open-output-file on existing files</h3>
      <p>Currently this is unspecified, and different implementations behave
differently.  WG2 will likely provide explicit control for this, but
we may want to specify the default behavior in WG1.</p>
      <p>Vote <span class="monospace">overwrite</span> to truncate and overwrite the existing file, or
<span class="monospace">error</span> to require an error be signalled.</p>
      <ul>
        <li><b>Options:</b> overwrite, error, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: unspecified, overwrite</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: overwrite</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: overwrite</li></ul></li>
        <li><b>Results:</b> <b>unspecified</b>, overwrite, undecided</li>
        <li><b>Ratios:</b> 3:2, 3:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>This seems too important to be left unspecified. The mechanism for explicit control should be in wg1.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Don't break existing programs.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Relegate control on opening files to WG2.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This seems to be the most common behavior among implementations.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>It's the sensible and useful thing to do, IMHO.</dd></dl>
      <h3 id="#262modulefactoring(schemeio)"><a href="/ticket/262">#262</a> module factoring (scheme io)</h3>
      <p>This is one of several issues raised by <a href="/wiki/ModuleFactoringSummary">ModuleFactoringSummary</a>.</p>
      <p>This and the following items ask you to decide whether a current set
of procedures under discussion belongs in the core or a separate
module.  The default is <span class="monospace">core</span> reflecting the fact that R5RS had no
separate modules at all.</p>
      <p>Should the basic I/O procedures (not involving file I/O or reading or
writing) be in the core or a separate module?</p>
      <ul>
        <li><b>Options:</b> core, separate</li>
        <li><b>Default:</b> core</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: core</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: core</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: core</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: core</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: separate</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: separate</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: separate</li></ul></li>
        <li><b>Results:</b> <b>core</b>, separate</li>
        <li><b>Ratios:</b> 4:3</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>These forms have been part of the language for a long time and are a fundamental idea.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Rename (scheme io) to (scheme ports) as it deals with ports management, which are not exclusively used for I/O (as strings ports for example). Don't require it into the base because some implementation don't need this.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>The I/O system is controversial, hence the complete (though unpopular) rewrite in R6RS. We should leave room for people to experiment with alternatives without them being second-class.</dd></dl>
      <h3 id="#263modulefactoring(schemerepl)"><a href="/ticket/263">#263</a> module factoring (scheme repl)</h3>
      <p>This is one of several issues raised by <a href="/wiki/ModuleFactoringSummary">ModuleFactoringSummary</a> (see <a href="/ticket/262">#262</a>).</p>
      <p>Should <span class="monospace">interaction-environment</span> be in the core, the REPL module, or
the <span class="monospace">eval</span> module?</p>
      <ul>
        <li><b>Options:</b> core, eval, repl</li>
        <li><b>Default:</b> core</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: repl</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: eval</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: repl, core</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: repl</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: eval</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: repl</li></ul></li>
        <li><b>Results:</b> <b>repl</b>, eval, core</li>
        <li><b>Ratios:</b> 4:2, 4:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>It's not really fundamentally tied to repl, anyway. Perhaps rename it 'implementation-environment'.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Embedded implementations, for example, may want a way to avoid including that code when they aren't using it.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd><span class="monospace">interaction-environment</span> is an abstract utility, not necessarily restricted to a traditional REPL.</dd></dl>
      <h3 id="#264modulefactoring(schemecase-lambda)"><a href="/ticket/264">#264</a> module factoring (scheme case-lambda)</h3>
      <p>This is one of several issues raised by <a href="/wiki/ModuleFactoringSummary">ModuleFactoringSummary</a>.</p>
      <p>Should <span class="monospace">case-lambda</span> be in the core or a separate module?</p>
      <ul>
        <li><b>Options:</b> core, separate</li>
        <li><b>Default:</b> core</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: core</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: core</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: separate</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: separate</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: separate</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: remove, separate</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: core</li></ul></li>
        <li><b>Results:</b> <b>separate</b>, core, remove</li>
        <li><b>Ratios:</b> 4:3, 3:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I see no reason to identify whether or not programs use this feature.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>`Case-lambda' is new, and some implementations may want to define their own extensions and make that clear through loading modules.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>This one has to be in a module: it poorly handles neither optional arguments nor pattern matching. It is the kind of feature we later regret having into the core.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd><span class="monospace">case-lambda</span> is one of the worst things that has ever happened to Scheme. It requires a quadratic explosion in duplicate code to handle the optional parameters case, yet it strictly less powerful than alternatives such as <span class="monospace">match-lambda</span> for more complex cases. It is only useful as a niche form for procedures whose behavior actually changes depending on the number of arguments - an uncommon and debatable type of API, which should not be encouraged.</dd></dl>
      <h3 id="#265modulefactoring(schememultiple-values)"><a href="/ticket/265">#265</a> module factoring (scheme multiple-values)</h3>
      <p>This is one of several issues raised by <a href="/wiki/ModuleFactoringSummary">ModuleFactoringSummary</a>.</p>
      <p>Should <span class="monospace">values</span> and <span class="monospace">call-with-values</span> be in the core or a separate
module?</p>
      <ul>
        <li><b>Options:</b> core, separate</li>
        <li><b>Default:</b> core</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: core</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: core</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: core</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: core</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: core</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: separate</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: core</li></ul></li>
        <li><b>Results:</b> <b>core</b>, separate</li>
        <li><b>Ratios:</b> 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>If these are in their own module, so should call-with-current-continuation be, and for that matter mutating forms. I'm not necessarily opposed to that -- it depends on what one thinks the purpose of the factoring is. But we may not want to go down that road.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Multiple values have been part of the language for a long time and are a fundamental idea.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Multiple values are another wart in the language, which unecessarily complicate both the implementation and all user code which deals with HOFs.</dd></dl>
      <h3 id="#266modulefactoring(schemecharnormalization)"><a href="/ticket/266">#266</a> module factoring (scheme char normalization)</h3>
      <p>This is one of several issues raised by <a href="/wiki/ModuleFactoringSummary">ModuleFactoringSummary</a>.</p>
      <p>Should the Unicode normalization procedures be in the core, the <span class="monospace">char</span>
module, or their own separate module?</p>
      <ul>
        <li><b>Options:</b> core, char, separate</li>
        <li><b>Default:</b> core</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: separate</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: char</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: separate, char</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: separate</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: separate, char</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: separate, char</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: char</li></ul></li>
        <li><b>Results:</b> <b>separate</b>, char</li>
        <li><b>Ratios:</b> 5:2</li></ul>
      <h3 id="#267modulefactoringallI/O"><a href="/ticket/267">#267</a> module factoring all I/O</h3>
      <p>This is one of several issues raised by <a href="/wiki/ModuleFactoringSummary">ModuleFactoringSummary</a>.</p>
      <p>Should we provide an aggregate module for the three (or four) proposed
I/O modules, where <span class="monospace">(scheme io)</span> provides all of:</p>
      <ul>
        <li><span class="monospace">(scheme io base)</span>   (if not in the core)</li>
        <li><span class="monospace">(scheme file)</span></li>
        <li><span class="monospace">(scheme read)</span></li>
        <li><span class="monospace">(scheme write)</span></li></ul>
      <ul>
        <li><b>Options:</b> yes, no</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: no</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>no</b>, yes</li>
        <li><b>Ratios:</b> 4:3</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>As long as we are providing the hierarchical structure, might as well use it.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>It's better to be explicit.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I've changed my mind here. We can leave aggregate modules up to WG2.</dd></dl>
      <h3 id="#268modulefactoring(schemeparameter)"><a href="/ticket/268">#268</a> module factoring (scheme parameter)</h3>
      <p>This is one of several issues raised by <a href="/wiki/ModuleFactoringSummary">ModuleFactoringSummary</a>.</p>
      <p>Should <span class="monospace">make-parameter</span> and <span class="monospace">parameterize</span> be in the core or their own
separate module?</p>
      <p>Note <span class="monospace">current-in/output/error-port</span> are parameters, though they do not
require the parameter API to be useful as is.</p>
      <ul>
        <li><b>Options:</b> core, separate</li>
        <li><b>Default:</b> core</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: core</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: core</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: core</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: core</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: separate</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: core</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: core</li></ul></li>
        <li><b>Results:</b> <b>core</b>, separate</li>
        <li><b>Ratios:</b> 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Comments regarding <a href="/ticket/265">#265</a> apply.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>They're so simple and few in number (two) that there's no reason to separate them.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>These functions allow creation and management of dynamic bindings, let put these in a module so people wanting them know what they are doing. (Moreover as stated above, <span class="monospace">current-in/output/error-port</span> have their own API)</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This is intertwined with the core language.</dd></dl>
      <h3 id="#269modulefactoring(schemerecord)"><a href="/ticket/269">#269</a> module factoring (scheme record)</h3>
      <p>This is one of several issues raised by <a href="/wiki/ModuleFactoringSummary">ModuleFactoringSummary</a>.</p>
      <p>Should <span class="monospace">define-record-type</span> be in the core or in its own separate module?</p>
      <ul>
        <li><b>Options:</b> core, separate</li>
        <li><b>Default:</b> core</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: core</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: core</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: separate</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: core</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: separate</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: separate</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: core</li></ul></li>
        <li><b>Results:</b> <b>core</b>, separate</li>
        <li><b>Ratios:</b> 4:3</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Users may want to use more elaborate versions of `define-record-type' and make that clear through loading modules.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>As this is a sensible issue, I would prefer not to write SRFI-9 in stone into the core but let open the (scheme record *) namespace for all kind of record implementations (in WG2 maybe).</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>No one thinks SRFI-9 is the one true record system, just that it's the only one we can agree on. We should leave room for other record systems, and not give this one special status.</dd></dl>
      <h3 id="#270modulefactoring(schemechar)"><a href="/ticket/270">#270</a> module factoring (scheme char)</h3>
      <p>This is one of several issues raised by <a href="/wiki/ModuleFactoringSummary">ModuleFactoringSummary</a>.</p>
      <p>Should the Unicode character case and property utilities be in the
core or their own separate module?</p>
      <ul>
        <li><b>Options:</b> core, separate</li>
        <li><b>Default:</b> core</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: separate</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: char</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: separate</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: separate</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: separate</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: separate</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: separate</li></ul></li>
        <li><b>Results:</b> <b>separate</b>, char</li>
        <li><b>Ratios:</b> 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>This is new.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Separate and optional as not all Scheme implementations will support Unicode.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>These require pretty large tables to load into a small implementation.</dd></dl>
      <h3 id="#231WG1/WG2Schemenamingproposal"><a href="/ticket/231">#231</a> WG1/WG2 Scheme naming proposal</h3>
      <p>Denis Washington made the following proposal for the names of the
variants of Scheme defined by WG1 and WG2:</p>
      <ul>
        <li>WG1: &quot;Report on the Algorithmic Language Scheme, Revised 2011&quot; (abbr.: RS11)</li></ul>
      <ul>
        <li>WG2: &quot;Report on Standard Extensions to the Algorithmic Language Scheme, Revised 2011&quot; (abbr.: RSES11; alternatively, &quot;[...] Commobn Extensions [...]&quot;, abbr. RCES11; should probably be &quot;Published 2011&quot; as there is no original document to revise.)</li></ul>
      <p>The current draft is written in the same style and layout as all the
drafts through R5RS, and by default has kept the same naming
convention.  Do we want to change the name?</p>
      <p>Note the name for WG2 is beyond the scope of this ballot.</p>
      <ul>
        <li><b>References:</b>
          <ul>
            <li>http://lists.scheme-reports.org/pipermail/scheme-reports/2011-July/001170.html</li></ul></li>
        <li><b>Proposals:</b>
          <ul>
            <li><b>r7rs:</b> &quot;R7RS&quot; as in the current draft</li>
            <li><b>2011 :</b> &quot;Scheme 2011&quot; as in the proposal above</li></ul></li>
        <li><b>Options:</b> r7rs, 2011, undecided</li>
        <li><b>Default:</b> r7rs</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: 2011</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: r7rs</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: r7rs, undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: 2011, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: r7rs</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: r7rs</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: r7rs</li></ul></li>
        <li><b>Results:</b> <b>r7rs</b>, undecided, 2011</li>
        <li><b>Ratios:</b> 5:1, 5:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Changing the naming convention after all these years is bikeshedding and dropping a fun and respected tradition. Furthermore, we'll have to explain the break over and over again.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Putting the date is a bad idea IMHO, it wrongly makes the language look deprecated some years after. Just name it something like &quot;Report on the Core Scheme Language&quot; with a subtitle like &quot;2011 edition, 7th revision&quot; (not directly a part of the title).</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I think changing the name at this point would give the misleading impression that the new report somehow deviates from tradition even more so than R6RS.</dd></dl>
      <h3 id="#189ListchangesfromR6RS"><a href="/ticket/189">#189</a> List changes from R6RS</h3>
      <p>An incomplete list of the differences between this language and the
R6RS is available.  Do we want to include this directly into the
document?  Alternately it can go into a separate document, or be
included in the WG2 document.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: no</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: separate</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> ''yes'', no, separate, undecided</li>
        <li><b>Ratios:</b> 3:2, 3:1, 3:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Separate document.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Let's include this directly in the document. It's important to explain this clearly.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>As the language is now splitted in &quot;little WG1&quot; and &quot;big WG2&quot; languages, does it really make sense to compare WG1 to R6RS rather than WG2 ? Comparing WG1 to R5RS is a better idea IMHO.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This would be too long, and more properly belongs in WG2.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>It would make an interesting appendix, and allow us to rationalise what might otherwise seem arbitrary decisions to people who haven't followed the exciting history of the mailing list.</dd></dl>
      <h3 id="#227quasiquoteandcycles"><a href="/ticket/227">#227</a> quasiquote and cycles</h3>
      <p>Some doubts were raised as to whether reader label cycles were allowed
in <span class="monospace">quasiquote</span>.  Since cycles in code are &quot;an error&quot;, and
<span class="monospace">quasiquote</span> is just a macro expanding into code, then this case is
also an error (and thus implementation dependent).</p>
      <p>Do we want to explicitly state that the result is an error for
<span class="monospace">quasiquote</span>?  Or make a special exception and try to require handling
of some cases for <span class="monospace">quasiquote</span>?  Or make no special note of this since
it's already covered?</p>
      <p>Vote <span class="monospace">note</span> to add a note.</p>
      <ul>
        <li><b>References:</b>
          <ul>
            <li>http://lists.scheme-reports.org/pipermail/scheme-reports/2011-July/001142.html</li></ul></li>
        <li><b>Proposals:</b>
          <ul>
            <li><b>note:</b> make a note</li></ul></li>
        <li><b>Options:</b> note, nothing, undecided</li>
        <li><b>Default:</b> nothing</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: note</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: nothing</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: note</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: note</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: note</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: nothing</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: note</li></ul></li>
        <li><b>Results:</b> <b>note</b>, nothing</li>
        <li><b>Ratios:</b> 5:2</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I'm not so sure this is an error. Quoted objects expand to code, but quasiquote operates on a representation of data (with embedded code). If we're not prepared to define reasonable semantics, we should say nothing.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>If it's confusing, it's better to be explicit.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>If we include error examples for this case, we should include one for quasiquote.</dd></dl>
      <h2 id="WG1-ReaderSyntax">WG1 - Reader Syntax</h2>
      <h3 id="#214string/symbolescapesequenceconfusing"><a href="/ticket/214">#214</a> string/symbol escape sequence confusing</h3>
      <p>From Felix Winkelmann:</p><span class="monospace">Using &quot;\xX...;&quot; as escape sequence is suboptimal, as it confuses
syntax highlighters. I also have no knowledge of any precedent
of this syntax. Also: how is this sequence handled inside &quot;|...|&quot;?
</span>
      <p>Prior to R6RS no implementations to my knowledge used this syntax, and
&quot;\xXX&quot; with a fixed two characters and no trailing semi-colon, as well
as &quot;\x{X...}&quot; were used.  The semi-colon specifically conflicts with
the existing uses of &quot;\xXX&quot;, although this can't represent all
characters.  Braces would at least allow for backwards compatibility
with existing code.</p>
      <p>Note the escapes for symbols will be the same unless someone proposed
otherwise.</p>
      <ul>
        <li><b>Proposals:</b>
          <ul>
            <li><b>semi-colon:</b> the current draft and R6RS option</li>
            <li><b>brace:</b> &quot;\x{X...}&quot; where the braces are required</li>
            <li><b>brace-or-semi-colon:</b> either of the two above</li>
            <li><b>fixed-two:</b> &quot;\xXX&quot; with two fixed hex-digits (can't support all chars)</li>
            <li><b>optional-semi-colon:</b> use semi-colon as a terminator if present, otherwise only read the first two hex-digits</li></ul></li>
        <li><b>Options:</b> semi-colon, brace, brace-or-semi-colon, fixed-two, optional-semi-colon, undecided</li>
        <li><b>Default:</b> semi-colon</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: semi-colon, brace</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: semi-colon</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: semi-colon, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: brace, semi-colon</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: brace</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: brace-or-semi-colon</li></ul></li>
        <li><b>Results:</b> <b>semi-colon</b>, brace, brace-or-semi-colon, undecided</li>
        <li><b>Ratios:</b> 3:2, 4:1, 4:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>This is too minor an issue to bring in braces.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Syntax highlighters can be updated.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This is unambiguous and doesn't conflict with existing syntax.</dd></dl>
      <h3 id="#218infinity/nansyntax"><a href="/ticket/218">#218</a> infinity/nan syntax</h3>
      <p>The current BNF for symbol syntax is rather cumbersome, having to
account for the fact that +inf.0, -inf.0 and +nan.0 are numbers even
though they do not begin with a numeric prefix.</p>
      <p>A simple solution would be to use an alternative such as 0/1, 0/-1 and
0/0, respectively.  These are shorter, more self explanatory, and do
not conflict with the definition of symbol syntax.</p>
      <p>Alternately we can just require a numeric prefix on the existing
names.</p>
      <ul>
        <li><b>Proposals:</b>
          <ul>
            <li><b>r6rs:</b> +inf.0, -inf.0, +nan.0</li>
            <li><b>short:</b> 0/1, 0/-1, 0/0</li>
            <li><b>dotted:</b> 0/1.0, 0/-1.0, 0/0.0</li>
            <li><b>prefix:</b> 0+inf, 0-inf, 0+nan</li>
            <li><b>prefix-dotted:</b> 0+inf.0, 0-inf.0, 0+nan.0</li></ul></li>
        <li><b>Options:</b> r6rs, short, dotted, prefix, prefix-dotted, undecided</li>
        <li><b>Default:</b> r6rs</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: r6rs, prefix-dotted, dotted, prefix, short</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: r6rs</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: r6rs</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: r6rs, r6rs, r6rs, ...</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: r6rs</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: dotted, r6rs</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: dotted, prefix-dotted, short, prefix</li></ul></li>
        <li><b>Results:</b> <b>r6rs</b>, dotted, prefix-dotted, prefix, short, ...</li>
        <li><b>Ratios:</b> 5:2, 6:1, 6:1, 6:1, 6:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Ugh. Let's not be gratuitously incompatible with R6RS just because the BNF is cumbersome.</dd>
        <dt><span class="monospace">Lucier</span></dt>
        <dd>I presume that the short and dotted notation was meant to be I strongly feel that any notation that incorporates unadorned &quot;0&quot; (not &quot;+0.&quot; or &quot;-0.&quot;) is incredibly misleading, as (/ 1 0) =&gt; Error (/ 1.0 0) =&gt; Error etc. The R6RS notation is sub-optimal in my opinion, as it does not indicate the bit patterns in a NaN either on input or output, but it seems better than the alternatives.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This fits well with our definition of symbol syntax, and keeps the BNF simple and free of exceptions.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I reckon the dot is important (they're inexact), and forcing a numeric prefix will simplify the rules for symbols in a pleasing manner.</dd></dl>
      <h3 id="#219bringbackreadablebooleanliterals"><a href="/ticket/219">#219</a> bring back readable boolean literals</h3>
      <p>Scheme used to use <span class="monospace">#!true</span> and <span class="monospace">#!false</span> before abbreviating to the
unfortunate <span class="monospace">#t</span> and <span class="monospace">#f</span> syntax, which look far too much alike.</p>
      <p>We could add these back in as aliases, optionally without the &quot;!&quot; now
that tokens are required to be delimited so there would be no
ambiguity.</p>
      <p>Note - this proposal is to add alternate names.  <span class="monospace">#t</span> and <span class="monospace">#f</span> will be
kept however we vote.</p>
      <ul>
        <li><b>Proposals:</b>
          <ul>
            <li><b>long:</b> <span class="monospace">#true</span> and <span class="monospace">#false</span></li>
            <li><b>bang-long:</b> <span class="monospace">#!true</span> and <span class="monospace">#!false</span></li></ul></li>
        <li><b>Options:</b> long, bang-long, none, undecided</li>
        <li><b>Default:</b> none</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: no</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: long, no</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no, bang-long, undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: long, no, undecided, bang-long</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: long, no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: long, no, bang-long</li></ul></li>
        <li><b>Results:</b> <b>long</b>, no, bang-long, undecided</li>
        <li><b>Ratios:</b> 4:3, 4:1, 4:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Let's not do this. They've been removed. I don't have trouble distinguishing #t from #f. Anyone who does can define <span class="monospace">true' and </span>false'.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Alex convinced me that this is more readable (along with keepeing shortened forms for compatibility).</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Most languages use <span class="monospace">true</span> and <span class="monospace">false</span> spelled out, and <span class="monospace">#t</span> and <span class="monospace">#f</span> are maddenlingly difficult to distinguish.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd><span class="monospace">#!...</span> is unnecessarily verbose and clashes with using <span class="monospace">#!</span> for reader directives. But I like the longer names.</dd></dl>
      <h3 id="#22mantissawidthsandplaceholders"><a href="/ticket/22">#22</a> mantissa widths and placeholders</h3>
      <p>Previously we voted to keep the R5RS <span class="monospace">#</span> placeholders for &quot;unknown&quot;
digits, and leave out the new R6RS mantissa widths.</p>
      <p>Feedback suggests that this feature is never used in R5RS programs.
It was a leftover from R3RS procedures for formatting numbers when
more digits of precision were asked for than were available, and also
commonly used in papers on the subject of formatting numbers.  These
formatters are no longer in the language, and human-written code
rarely if ever takes advantage of the feature, so we may want to
reconsider removing it from the language.</p>
      <p>Vote <span class="monospace">no</span> to remove the <span class="monospace">#</span> placeholders.</p>
      <ul>
        <li><b>Options:</b> r5rs, no, undecided</li>
        <li><b>Default:</b> r5rs</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: no</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: no</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: no</li></ul></li>
        <li><b>Results:</b> <b>no</b></li>
        <li><b>Ratios:</b></li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>They don't need to be in the standard if no one uses them.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Let's be jewel-like.</dd></dl>
      <h3 id="#68&quot;Undefinedvalue&quot;vs.&quot;undefinedvalues&quot;"><a href="/ticket/68">#68</a> &quot;Undefined value&quot; vs. &quot;undefined values&quot;</h3>
      <p>Previously we voted to keep the R5RS semantics of returning a single,
unspecified value for the results of side-effecting expressions.</p>
      <p>Some implementors have raised concerns about this.  The R6RS semantics
allow implementations to return an unspecified number of unspecified
values, which allows for the R5RS semantics, as well as for returning
zero values.</p>
      <p>The argument is that a non-trivial amount of existing R5RS code
explicitly depends on these expressions returning a single value.</p>
      <p>The counter-argument is that using an unspecified value at all is bad
style, and there is likely a large overlap between the programmers who
do so and the implementations which will continue to return a single
value.  The hope is that code using &quot;good style&quot; would be portable,
whereas &quot;bad style&quot; would continue to work on existing implementations
but not be portable to others.</p>
      <p>We should reconsider this item.</p>
      <ul>
        <li><b>Options:</b> r5rs, r6rs, undecided</li>
        <li><b>Default:</b> r5rs</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: r5rs</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: r6rs</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: r5rs</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: r5rs</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: r6rs, undecided, r5rs</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: r5rs</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: r6rs</li></ul></li>
        <li><b>Results:</b> <b>r5rs</b>, r6rs, undecided</li>
        <li><b>Ratios:</b> 4:3, 4:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I like the idea of returning zero values.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Let's not break existing programs if there isn't widespread agreement.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>R6RS phrasing allows flexibility. With it implementations are free to return any useful value or to return no values instead of an unfortunate &quot;undefined&quot; value.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This is the de facto standard. Although R6RS loosened the requirements, existing implementations continue to return a single value.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I've made my views on this clear before!</dd></dl></div></body></html>