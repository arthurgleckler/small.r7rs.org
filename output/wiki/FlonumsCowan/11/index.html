
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Copyright 2013 by Arthur A. Gleckler. All rights reserved. -->
    <title>FlonumsCowan</title>
    <link href="/trac.css" rel="stylesheet" type="text/css"></head>
  <body>
    <header>This site is a static rendering of the <a href="https://trac.edgewall.org/">Trac</a> instance that was used by <a href="http://scheme-reports.org/2015/working-group-1.html">R7RS-WG1</a> for its work on R7RS-small (<a href="/attachment/r7rs.pdf">PDF</a>), which was ratified in 2013. For more information, see <a href="/">Home</a>. For a version of this page that may be more recent, see <a href="https://github.com/johnwcowan/r7rs-work/blob/master/FlonumsCowan.md">FlonumsCowan</a> in WG2's repo for R7RS-large.</header>
    <ul class="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/ticket/">All tickets</a></li>
      <li><a href="/wiki/">All wiki pages</a></li></ul>
    <h1 class="wiki">Flonums&shy;Cowan</h1>
    <div class="wiki metadata">
      <div class="author">cowan</div>
      <div class="time">2015-12-01 01:46:48</div>
      <div class="version">11<span class="comment"></span><a href="/wiki/FlonumsCowan/history">history</a></div>
      <div class="source"><a href="/wiki/FlonumsCowan/11/source.html">source</a></div></div>
    <div class="wiki text">
      <h2 id="Flonumspackage">Flonums package</h2>
      <p><i>Flonums</i> are a subset of the inexact real numbers provided by a Scheme implementation.  In most Schemes, the flonums and the inexact reals are the same.</p>
      <p>The procedures in this package don't have hard-coded prefixes.  The intent is that they be placed in a module.  Users can then import this module with their own prefix such as <span class="monospace">fl</span>, or <span class="monospace">Æ’</span> if their Scheme implementation supports that character, or with no prefix at all if the intent is to override the normal Scheme arithmetic routines.</p>
      <h2 id="R6RSflonumlibrary">R6RS flonum library</h2><p>
This section uses <i>fl</i>, <i>fl<sub>1</sub></i>, <i>fl<sub>2</sub></i>, etc., as
parameter names for flonum arguments, and <i>ifl</i>
as a name for integer-valued flonum arguments, i.e., flonums for which the
<tt>integer?</tt> predicate returns true.</p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_950"></a>flonum?<i> obj</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
Returns <tt>#t</tt> if <i>obj</i> is a flonum, <tt>#f</tt> otherwise.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_952"></a>real-&gt;flonum<i> x</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
Returns the best flonum representation of
<i>x</i>.</p>
<p>
The value returned is a flonum that is numerically closest to the
argument.</p>
<p>
</p>
<blockquote><em>Note:<span style="margin-left: .5em">&zwnj;</span></em>
If flonums are represented in binary floating point, then
implementations should break ties by preferring
the floating-point representation whose least significant bit is
zero.
</blockquote>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_954"></a>fl=?<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <i>fl<sub>3</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_956"></a>fl&lt;?<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <i>fl<sub>3</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_958"></a>fl&lt;=?<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <i>fl<sub>3</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_960"></a>fl&gt;?<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <i>fl<sub>3</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_962"></a>fl&gt;=?<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <i>fl<sub>3</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures return <tt>#t</tt> if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing,
monotonically nondecreasing, or monotonically nonincreasing,
<tt>#f</tt> otherwise.  These
predicates must be transitive.</p>
<p>
</p>

<tt>(fl=&nbsp;+inf.0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#t</tt>
<p class=nopadding>(fl=&nbsp;-inf.0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#f</tt></p>

<p class=nopadding>(fl=&nbsp;-inf.0&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#t</tt></p>

<p class=nopadding>(fl=&nbsp;0.0&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#t</tt></p>

<p class=nopadding>(fl&lt;&nbsp;0.0&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#f</tt></p>

<p class=nopadding>(fl=&nbsp;+nan.0&nbsp;<i>fl</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#f</tt></p>

<p class=nopadding>(fl&lt;&nbsp;+nan.0&nbsp;<i>fl</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;<tt>#f</tt></p>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_964"></a>flinteger?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_966"></a>flzero?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_968"></a>flpositive?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_970"></a>flnegative?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_972"></a>flodd?<i> ifl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_974"></a>fleven?<i> ifl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_976"></a>flfinite?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_978"></a>flinfinite?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_980"></a>flnan?<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These numerical predicates test a flonum for a particular property,
returning <tt>#t</tt> or <tt>#f</tt>.
The <tt>flinteger?</tt> procedure tests whether the number object is an integer,
<tt>flzero?</tt> tests whether
it is <tt>fl=?</tt> to zero, <tt>flpositive?</tt> tests whether it is greater
than zero, <tt>flnegative?</tt> tests whether it is less
than zero, <tt>flodd?</tt> tests whether it is odd, 
<tt>fleven?</tt> tests whether it is even,
<tt>flfinite?</tt> tests whether it is not an infinity and not a NaN,
<tt>flinfinite?</tt> tests whether it is an infinity, and
<tt>flnan?</tt> tests whether it is a NaN.</p>
<p>
</p>

<tt>(flnegative?&nbsp;-0.0)&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<tt>#f</tt>
<p class=nopadding>(flfinite?&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<tt>#f</tt></p>

<p class=nopadding>(flfinite?&nbsp;5.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<tt>#t</tt></p>

<p class=nopadding>(flinfinite?&nbsp;5.0)&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<tt>#f</tt></p>

<p class=nopadding>(flinfinite?&nbsp;+inf.0)&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<tt>#t</tt></p>
<p></tt></p>
<p>
</p>
<blockquote><em>Note:<span style="margin-left: .5em">&zwnj;</span></em>
<tt>(flnegative? -0.0)</tt> must return <tt>#f</tt>,
else it would lose the correspondence with
<tt>(fl&lt; -0.0 0.0)</tt>, which is <tt>#f</tt>
according to IEEE 754&nbsp;[<a href="r6rs-lib-Z-H-21.html#node_bib_7">7</a>].
</blockquote>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_982"></a>flmax<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_984"></a>flmin<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures return the maximum or minimum of their arguments.
They always return a NaN when one or more of the arguments is a NaN.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_986"></a>fl+<i> <i>fl<sub>1</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_988"></a>fl*<i> <i>fl<sub>1</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures return the flonum sum or product of their flonum
arguments.  In general, they should return the flonum that best
approximates the mathematical sum or product.  (For implementations
that represent flonums using IEEE binary floating point, the
meaning of &ldquo;best&rdquo; is defined by the IEEE standards.)</p>
<p>
</p>

<tt>(fl+&nbsp;+inf.0&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+nan.0
<p class=nopadding>(fl+&nbsp;+nan.0&nbsp;<i>fl</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+nan.0</p>

<p class=nopadding>(fl*&nbsp;+nan.0&nbsp;<i>fl</i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+nan.0</p>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_990"></a>fl-<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_992"></a>fl-<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_994"></a>fl/<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i> <tt>...</tt></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_996"></a>fl/<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
With two or more arguments, these procedures return the flonum
difference or quotient of their flonum arguments, associating to the
left.  With one argument, however, they return the additive or
multiplicative flonum inverse of their argument.  In general, they
should return the flonum that best approximates the mathematical
difference or quotient.  (For implementations that represent flonums
using IEEE binary floating point, the meaning of &ldquo;best&rdquo; is
reasonably well-defined by the IEEE standards.)</p>
<p>
</p>

<tt>(fl-&nbsp;+inf.0&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+nan.0<p></tt></p>
<p>
For undefined quotients, <tt>fl/</tt> behaves as specified by the
IEEE standards:</p>
<p>
</p>

<tt>(fl/&nbsp;1.0&nbsp;0.0)&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;+inf.0
<p class=nopadding>(fl/&nbsp;-1.0&nbsp;0.0)&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;-inf.0</p>

<p class=nopadding>(fl/&nbsp;0.0&nbsp;0.0)&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;+nan.0</p>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_998"></a>flabs<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
Returns the absolute value of <i>fl</i>.
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_1000"></a>fldiv-and-mod<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1002"></a>fldiv<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1004"></a>flmod<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1006"></a>fldiv0-and-mod0<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1008"></a>fldiv0<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1010"></a>flmod0<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures implement number-theoretic integer division and
return the results of the corresponding mathematical operations
specified in report section&nbsp;on &ldquo;Integer division&rdquo;.  For zero divisors, these
procedures may return a NaN or some unspecified flonum.</p>
<p>
</p>

<tt>(fldiv&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<i>fl<sub>1</sub></i>&nbsp;<em>d</em><em>i</em><em>v</em>&nbsp;<i>fl<sub>2</sub></i>
<p class=nopadding>(flmod&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<i>fl<sub>1</sub></i>&nbsp;<em>m</em><em>o</em><em>d</em>&nbsp;<i>fl<sub>2</sub></i></p>

<p class=nopadding>(fldiv-and-mod&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><span style="margin-left: 2em">&zwnj;</span><span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<i>fl<sub>1</sub></i>&nbsp;<em>d</em><em>i</em><em>v</em>&nbsp;<i>fl<sub>2</sub></i>,&nbsp;<i>fl<sub>1</sub></i>&nbsp;<em>m</em><em>o</em><em>d</em>&nbsp;<i>fl<sub>2</sub></i><br>
;&nbsp;two&nbsp;return&nbsp;values</p>

<p class=nopadding>(fldiv0&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<i>fl<sub>1</sub></i>&nbsp;<em>d</em><em>i</em><em>v</em><sub>0</sub>&nbsp;<i>fl<sub>2</sub></i></p>

<p class=nopadding>(flmod0&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<i>fl<sub>1</sub></i>&nbsp;<em>m</em><em>o</em><em>d</em><sub>0</sub>&nbsp;<i>fl<sub>2</sub></i></p>

<p class=nopadding>(fldiv0-and-mod0&nbsp;<i>fl<sub>1</sub></i>&nbsp;<i>fl<sub>2</sub></i>)&nbsp;&nbsp;&nbsp;<br><span style="margin-left: 2em">&zwnj;</span><span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<i>fl<sub>1</sub></i>&nbsp;<em>d</em><em>i</em><em>v</em><sub>0</sub>&nbsp;<i>fl<sub>2</sub></i>,&nbsp;<i>fl<sub>1</sub></i>&nbsp;<em>m</em><em>o</em><em>d</em><sub>0</sub>&nbsp;<i>fl<sub>2</sub></i><br>
;&nbsp;two&nbsp;return&nbsp;values</p>
<p></tt></p>
<p>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_1012"></a>flnumerator<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1014"></a>fldenominator<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures return the numerator or denominator of <i>fl</i>
as a flonum; the result is computed as if <i>fl</i> was represented as
a fraction in lowest terms.  The denominator is always positive.  The
denominator of 0.0 is defined to be 1.0.
</p>

<tt>(flnumerator&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+inf.0
<p class=nopadding>(flnumerator&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;-inf.0</p>

<p class=nopadding>(fldenominator&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;1.0</p>

<p class=nopadding>(fldenominator&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;1.0</p>

<p class=nopadding>(flnumerator&nbsp;0.75)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;3.0&nbsp;;&nbsp;probably</p>

<p class=nopadding>(fldenominator&nbsp;0.75)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;4.0&nbsp;;&nbsp;probably</p>
<p></tt></p>
<p>
Implementations should implement following behavior:</p>
<p>
</p>

<tt>(flnumerator&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;-0.0<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_1016"></a>flfloor<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1018"></a>flceiling<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1020"></a>fltruncate<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1022"></a>flround<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures return integral flonums for flonum arguments that are
not infinities or NaNs.  For such arguments, <tt>flfloor</tt> returns the
largest integral flonum not larger than <i>fl</i>.  The <tt>flceiling</tt>
procedure
returns the smallest integral flonum not smaller than <i>fl</i>.
The <tt>fltruncate</tt> procedure returns the integral flonum closest to <i>fl</i> whose
absolute value is not larger than the absolute value of <i>fl</i>.
The <tt>flround</tt> procedure returns the closest integral flonum to <i>fl</i>,
rounding to even when <i>fl</i> represents a number halfway between two integers.</p>
<p>
Although infinities and NaNs are not integer objects, these procedures return
an infinity when given an infinity as an argument, and a NaN when
given a NaN:</p>
<p>
</p>

<tt>(flfloor&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+inf.0
<p class=nopadding>(flceiling&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;-inf.0</p>

<p class=nopadding>(fltruncate&nbsp;+nan.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+nan.0</p>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_1024"></a>flexp<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1026"></a>fllog<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1028"></a>fllog<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1030"></a>flsin<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1032"></a>flcos<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1034"></a>fltan<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1036"></a>flasin<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1038"></a>flacos<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1040"></a>flatan<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1042"></a>flatan<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These procedures compute the usual transcendental functions.  
The <tt>flexp</tt> procedure computes the base-<em>e</em> exponential of <i>fl</i>.
The <tt>fllog</tt> procedure with a single argument computes the natural logarithm of
<i>fl</i> (not the base ten logarithm); <tt>(fllog <i>fl<sub>1</sub></i>
<i>fl<sub>2</sub></i>)</tt> computes the base-<i>fl<sub>2</sub></i> logarithm of <i>fl<sub>1</sub></i>.
The <tt>flasin</tt>, <tt>flacos</tt>, and <tt>flatan</tt> procedures compute arcsine,
arccosine, and arctangent, respectively.  <tt>(flatan <i>fl<sub>1</sub></i>
<i>fl<sub>2</sub></i>)</tt> computes the arc tangent of <i>fl<sub>1</sub></i>/<i>fl<sub>2</sub></i>.</p>
<p>
See report
section&nbsp;on &ldquo;Transcendental functions&rdquo; for the underlying
mathematical operations.  In the event that these operations do not
yield a real result for the given arguments, the result may be a NaN,
or may be some unspecified flonum.</p>
<p>
Implementations that use IEEE binary floating-point arithmetic 
should follow the relevant standards for these procedures.</p>
<p>
</p>

<tt>(flexp&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;+inf.0
<p class=nopadding>(flexp&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;0.0</p>

<p class=nopadding>(fllog&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;+inf.0</p>

<p class=nopadding>(fllog&nbsp;0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;-inf.0</p>

<p class=nopadding>(fllog&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;<i>unspecified</i><br>
;&nbsp;if&nbsp;-0.0&nbsp;is&nbsp;distinguished</p>

<p class=nopadding>(fllog&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;+nan.0</p>

<p class=nopadding>(flatan&nbsp;-inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><span style="margin-left: 2em">&zwnj;</span><span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;-1.5707963267948965<br>
;&nbsp;approximately</p>

<p class=nopadding>(flatan&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><span style="margin-left: 2em">&zwnj;</span><span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;1.5707963267948965<br>
;&nbsp;approximately</p>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_1044"></a>flsqrt<i> fl</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
Returns the principal square root of <i>fl</i>. For &minus;0.0,
<tt>flsqrt</tt> should return &minus;0.0; for other negative arguments,
the result may be a NaN or some unspecified flonum.</p>
<p>
</p>

<tt>(flsqrt&nbsp;+inf.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;+inf.0
<p class=nopadding>(flsqrt&nbsp;-0.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="margin-left: 2em">&zwnj;</span>&rArr;&nbsp;&nbsp;-0.0</p>
<p></tt>
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_1046"></a>flexpt<i> <i>fl<sub>1</sub></i> <i>fl<sub>2</sub></i></i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
Either <i>fl<sub>1</sub></i> should be non-negative, or, if <i>fl<sub>1</sub></i> is
negative, <i>fl<sub>2</sub></i> should be an integer object.
The <tt>flexpt</tt> procedure returns <i>fl<sub>1</sub></i> raised to the power <i>fl<sub>2</sub></i>.  If <i>fl<sub>1</sub></i> is
negative and <i>fl<sub>2</sub></i> is not an integer object, the result may be a
NaN, or may be some unspecified flonum.  If <i>fl<sub>1</sub></i> is zero, then
the result is zero.
</p>
<p></p>
<p>
</p>
<p><a name="node_idx_1048"></a></p>
<div align=left><tt><tt>&amp;no-infinities</tt></tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>condition type&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1050"></a>make-no-infinities-violation<i> obj</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1052"></a>no-infinities-violation?<i> obj</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<a name="node_idx_1054"></a><div align=left><tt><tt>&amp;no-nans</tt></tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>condition type&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1056"></a>make-no-nans-violation<i> obj</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>

<div align=left><tt>(<a name="node_idx_1058"></a>no-nans-violation?<i> obj</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
These condition types could be defined by the following code:</p>
<p>
</p>

<tt>(define-condition-type&nbsp;&amp;no-infinities
<p class=nopadding>&nbsp;&nbsp;&nbsp;&nbsp;&amp;implementation-restriction</p>

<p class=nopadding>&nbsp;&nbsp;make-no-infinities-violation</p>

<p class=nopadding>&nbsp;&nbsp;no-infinities-violation?)</p>

<p class=nopadding></p>

<p class=nopadding>(define-condition-type&nbsp;&amp;no-nans</p>

<p class=nopadding>&nbsp;&nbsp;&nbsp;&nbsp;&amp;implementation-restriction</p>

<p class=nopadding>&nbsp;&nbsp;make-no-nans-violation&nbsp;no-nans-violation?)</p>
<p></tt></p>
<p>
These types describe that a program has executed an arithmetic
operations that is specified to return an infinity or a NaN,
respectively, on a Scheme implementation that is not able to represent
the infinity or NaN.  (See report section&nbsp;on &ldquo;Representability of infinities and NaNs&rdquo;.)
</p>
<p></p>
<p>
</p>
<p></p>
<div align=left><tt>(<a name="node_idx_1060"></a>fixnum-&gt;flonum<i> fx</i>)</tt><span style="margin-left: .5em">&zwnj;</span><span style="margin-left: .5em">&zwnj;</span>procedure&nbsp;</div>
<p>
Returns a flonum that is numerically closest to <i>fx</i>.</p>
<p>
</p>
<blockquote><em>Note:<span style="margin-left: .5em">&zwnj;</span></em>
The result of this procedure may not be
numerically equal to <i>fx</i>, because the fixnum precision
may be greater than the flonum precision.
</blockquote>
<p></p>
<p>
</p>

      <h2 id="R7RS-small-compatibleprocedures">R7RS-small-compatible procedures</h2>
      <p>The following R7RS-small procedures have flonum equivalents:</p><span class="monospace">= &lt; &lt;= &gt; &gt;= 
integer? zero? positive? negative? odd? even? finite? infinite? nan?
+ - * /
abs numerator denominator floor ceiling truncate round
log sin cos tan asin acos atan
sqrt expt
</span>
      <p>TODO: need to see about integer division procedures</p>
      <h2 id="C99&lt;math.h&gt;constants">C99 &lt;math.h&gt; constants</h2>
      <p>The following constants are defined in terms of the constants of the &lt;math.h&gt; header of ISO/IEC 9899:1999 (C language).</p>
      <table><tr><td class="default">
            <p>Scheme name</p></td><td class="default">
            <p>C name</p></td><td class="default">
            <p>Comments</p></td></tr><tr><td class="default">
            <p><span class="monospace">e</span></p></td><td class="default">
            <p><span class="monospace">M_E</span></p></td><td class="default">
            <p>Value of e</p></td></tr><tr><td class="default">
            <p><span class="monospace">log2-e</span></p></td><td class="default">
            <p><span class="monospace">M_LOG2E</span></p></td><td class="default">
            <p>Value of log<sub>2</sub> e</p></td></tr><tr><td class="default">
            <p><span class="monospace">log10-e</span></p></td><td class="default">
            <p><span class="monospace">M_LOG10E</span></p></td><td class="default">
            <p>Value of log<sub>10</sub> e</p></td></tr><tr><td class="default">
            <p><span class="monospace">ln-2</span></p></td><td class="default">
            <p><span class="monospace">M_LN2</span></p></td><td class="default">
            <p>Value of log<sub>e</sub> 2</p></td></tr><tr><td class="default">
            <p><span class="monospace">ln-10</span></p></td><td class="default">
            <p><span class="monospace">M_LN10</span></p></td><td class="default">
            <p>Value of log<sub>e</sub> 10</p></td></tr><tr><td class="default">
            <p><span class="monospace">pi</span></p></td><td class="default">
            <p><span class="monospace">M_PI</span></p></td><td class="default">
            <p>Value of pi</p></td></tr><tr><td class="default">
            <p><span class="monospace">pi/2</span></p></td><td class="default">
            <p><span class="monospace">M_PI_2</span></p></td><td class="default">
            <p>Value of pi/2</p></td></tr><tr><td class="default">
            <p><span class="monospace">pi/4</span></p></td><td class="default">
            <p><span class="monospace">M_PI_4</span></p></td><td class="default">
            <p>Value of pi/4</p></td></tr><tr><td class="default">
            <p><span class="monospace">one-over-pi</span></p></td><td class="default">
            <p><span class="monospace">M_1_PI</span></p></td><td class="default">
            <p>Value of 1/pi</p></td></tr><tr><td class="default">
            <p><span class="monospace">two-over-pi</span></p></td><td class="default">
            <p><span class="monospace">M_2_PI</span></p></td><td class="default">
            <p>Value of 2/pi</p></td></tr><tr><td class="default">
            <p><span class="monospace">two-over-sqrt-pi</span></p></td><td class="default">
            <p><span class="monospace">M_2_SQRTPI</span></p></td><td class="default">
            <p>Value of 2/sqrt(pi)</p></td></tr><tr><td class="default">
            <p><span class="monospace">sqrt-2</span></p></td><td class="default">
            <p><span class="monospace">M_SQRT2</span></p></td><td class="default">
            <p>Value of sqrt(2)</p></td></tr><tr><td class="default">
            <p><span class="monospace">one-over-sqrt-2</span></p></td><td class="default">
            <p><span class="monospace">M_SQRT1_2</span></p></td><td class="default">
            <p>Value of 1/sqrt(2)</p></td></tr><tr><td class="default">
            <p><span class="monospace">maximum-flonum</span></p></td><td class="default">
            <p><span class="monospace">HUGE_VAL</span></p></td><td class="default">
            <p><span class="monospace">+inf.0</span> or else\\the largest finite flonum</p></td></tr><tr><td class="default">
            <p><span class="monospace">fast-multiply-add</span></p></td><td class="default">
            <p><span class="monospace">#t</span> if <span class="monospace">FP_FAST_FMA</span> is 1,\\or <span class="monospace">#f</span> otherwise</p></td><td class="default">
            <p>multiply-add is fast</p></td></tr><tr><td class="default">
            <p><span class="monospace">integer-exponent-zero</span></p></td><td class="default">
            <p><span class="monospace">FP_ILOGB0</span></p></td><td class="default">
            <p>what <span class="monospace">(integer-binary-log 0)</span> returns</p></td></tr><tr><td class="default">
            <p><span class="monospace">integer-exponent-nan</span></p></td><td class="default">
            <p><span class="monospace">FP_ILOGBNAN</span></p></td><td class="default">
            <p>what <span class="monospace">(integer-binary-log +0.nan)</span> returns</p></td></tr></table>
      <h2 id="C99&lt;math.h&gt;procedures">C99 &lt;math.h&gt; procedures</h2>
      <p>The following procedures are defined in terms of the functions of the &lt;math.h&gt; header of ISO/IEC 9899:1999 (C language).  In the C signatures, the types &quot;double&quot; and &quot;int&quot; are mapped to Scheme flonums and (suitably bounded) Scheme exact integers respectively.</p>
      <table><tr><td class="default">
            <p>Scheme name</p></td><td class="default">
            <p>C signature</p></td><td class="default">
            <p>Comments</p></td></tr><tr><td class="default">
            <p><span class="monospace">acosh</span></p></td><td class="default">
            <p><span class="monospace">double      acosh(double)</span></p></td><td class="default">
            <p>hyperbolic arc cosine</p></td></tr><tr><td class="default">
            <p><span class="monospace">asinh</span></p></td><td class="default">
            <p><span class="monospace">double      asinh(double)</span></p></td><td class="default">
            <p>hyperbolic arc sine</p></td></tr><tr><td class="default">
            <p><span class="monospace">atanh</span></p></td><td class="default">
            <p><span class="monospace">double      atanh(double)</span></p></td><td class="default">
            <p>hyperbolic arc tangent</p></td></tr><tr><td class="default">
            <p><span class="monospace">cbrt</span></p></td><td class="default">
            <p><span class="monospace">double      cbrt(double);</span></p></td><td class="default">
            <p>cube root</p></td></tr><tr><td class="default">
            <p><span class="monospace">complementary-error-function</span></p></td><td class="default">
            <p><span class="monospace">double      erfc(double)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">copy-sign</span></p></td><td class="default">
            <p><span class="monospace">double      copysign(double x, double y)</span></p></td><td class="default">
            <p>result has magnitude of x and sign of y</p></td></tr><tr><td class="default">
            <p><span class="monospace">cosh</span></p></td><td class="default">
            <p><span class="monospace">double      cosh(double)</span></p></td><td class="default">
            <p>hyperbolic cosine</p></td></tr><tr><td class="default">
            <p><span class="monospace">make-flonum</span></p></td><td class="default">
            <p><span class="monospace">double      ldexp(double x, int n)</span></p></td><td class="default">
            <p>x*2<sup>n</sup></p></td></tr><tr><td class="default">
            <p><span class="monospace">error-function</span></p></td><td class="default">
            <p><span class="monospace">double      erf(double)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">exp</span></p></td><td class="default">
            <p><span class="monospace">double exp(double)</span></p></td><td class="default">
            <p>e<sup>x</sup></p></td></tr><tr><td class="default">
            <p><span class="monospace">exp-binary</span></p></td><td class="default">
            <p><span class="monospace">double      exp,,2,,(double)</span></p></td><td class="default">
            <p>base-2 exponential</p></td></tr><tr><td class="default">
            <p><span class="monospace">exp-minus-1</span></p></td><td class="default">
            <p><span class="monospace">double      expm1(double)</span></p></td><td class="default">
            <p>e<sup>x</sup>-1</p></td></tr><tr><td class="default">
            <p><span class="monospace">exponent</span></p></td><td class="default">
            <p><span class="monospace">double      logb(double x)</span></p></td><td class="default">
            <p>the exponent of x, which is the integral part of log_r(|x|), as a signed floating-point value, for non-zero x, where r is the radix of the machine's floating-point arithmetic</p></td></tr><tr><td class="default">
            <p><span class="monospace">first-bessel-order-0</span></p></td><td class="default">
            <p><span class="monospace">double      j0(double)</span></p></td><td class="default">
            <p>bessel function of the first kind, order 0</p></td></tr><tr><td class="default">
            <p><span class="monospace">first-bessel-order-1</span></p></td><td class="default">
            <p><span class="monospace">double      j1(double)</span></p></td><td class="default">
            <p>bessel function of the first kind, order 1</p></td></tr><tr><td class="default">
            <p><span class="monospace">first-bessel</span></p></td><td class="default">
            <p><span class="monospace">double      jn(int n, double)</span></p></td><td class="default">
            <p>bessel function of the first kind, order n</p></td></tr><tr><td class="default">
            <p><span class="monospace">fraction-exponent</span></p></td><td class="default">
            <p><span class="monospace">double      modf(double, double *)</span></p></td><td class="default">
            <p>returns two values, fraction and int exponent</p></td></tr><tr><td class="default">
            <p><span class="monospace">gamma</span></p></td><td class="default">
            <p><span class="monospace">double      tgamma(double)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">hypotenuse</span></p></td><td class="default">
            <p><span class="monospace">double      hypot(double, double)</span></p></td><td class="default">
            <p>sqrt(x<sup>2</sup>+y<sup>2</sup>)</p></td></tr><tr><td class="default">
            <p><span class="monospace">integer-exponent</span></p></td><td class="default">
            <p><span class="monospace">int         ilogb(double)</span></p></td><td class="default">
            <p>binary log as int</p></td></tr><tr><td class="default">
            <p><span class="monospace">log-binary</span></p></td><td class="default">
            <p><span class="monospace">double      log2(double)</span></p></td><td class="default">
            <p>log base 2</p></td></tr><tr><td class="default">
            <p><span class="monospace">log-decimal</span></p></td><td class="default">
            <p><span class="monospace">double      log10(double)</span></p></td><td class="default">
            <p>log base 10</p></td></tr><tr><td class="default">
            <p><span class="monospace">log-gamma</span></p></td><td class="default">
            <p><span class="monospace">double      lgamma(double)</span></p></td><td class="default">
            <p>returns two values, log(|gamma(x)|) and sgn(gamma(x))</p></td></tr><tr><td class="default">
            <p><span class="monospace">log-one-plus</span></p></td><td class="default">
            <p><span class="monospace">double      log1p(double x)</span></p></td><td class="default">
            <p>log (1+x)</p></td></tr><tr><td class="default">
            <p><span class="monospace">multiply-add</span></p></td><td class="default">
            <p><span class="monospace">double      fma(double a, double b, double c)</span></p></td><td class="default">
            <p>a*b+c</p></td></tr><tr><td class="default">
            <p><span class="monospace">next-after</span></p></td><td class="default">
            <p><span class="monospace">double      nextafter(double, double)</span></p></td><td class="default">
            <p>next flonum following x in the direction of y</p></td></tr><tr><td class="default">
            <p><span class="monospace">normalized-fraction-exponent</span></p></td><td class="default">
            <p><span class="monospace">double      frexp(double, int *)</span></p></td><td class="default">
            <p>returns two values, fraction in range [1/2,1) and int exponent</p></td></tr><tr><td class="default">
            <p><span class="monospace">positive-difference</span></p></td><td class="default">
            <p><span class="monospace">double      fdim(double, double)</span></p></td><td class="default">
            <p>-</p></td></tr></table>
      <p>||<span class="monospace">remquo</span>||<span class="monospace">double      remquo(double, double, int *)</span>||returns two values, rounded remainder and low-order <i>n</i> bits of the quotient (<i>n</i> is implementation-defined)</p>
      <table><tr><td class="default">
            <p><span class="monospace">scalbn</span></p></td><td class="default">
            <p><span class="monospace">double      scalbn(double x, int y)</span></p></td><td class="default">
            <p>x*r<sup>y</sup>, where r is the machine float radix</p></td></tr><tr><td class="default">
            <p><span class="monospace">second-bessel-order-0</span></p></td><td class="default">
            <p><span class="monospace">double      y0(double)</span></p></td><td class="default">
            <p>bessel function of the second kind, order 0</p></td></tr><tr><td class="default">
            <p><span class="monospace">second-bessel-order-1</span></p></td><td class="default">
            <p><span class="monospace">double      y1(double)</span></p></td><td class="default">
            <p>bessel function of the second kind, order 1</p></td></tr><tr><td class="default">
            <p><span class="monospace">second-bessel</span></p></td><td class="default">
            <p><span class="monospace">double      yn(int n, double)</span></p></td><td class="default">
            <p>bessel function of the second kind, order <i>n</i></p></td></tr><tr><td class="default">
            <p><span class="monospace">sinh</span></p></td><td class="default">
            <p><span class="monospace">double      sinh(double)</span></p></td><td class="default">
            <p>hyperbolic sine</p></td></tr><tr><td class="default">
            <p><span class="monospace">tanh</span></p></td><td class="default">
            <p><span class="monospace">double      tanh(double)</span></p></td><td class="default">
            <p>hyperbolic tangent</p></td></tr></table>
      <h2 id="Generalremarks">General remarks</h2>
      <p>In the event that these operations do not yield a real result for the given arguments, the result may be <span class="monospace">+nan.0</span>, or may be some unspecified flonum.</p>
      <p>Implementations that use IEEE binary floating-point arithmetic should follow the relevant standards for these procedures.</p>
      <h2 id="Compnumproceduresfrom&lt;complex.h&gt;">Compnum procedures from &lt;complex.h&gt;</h2>
      <p>A <i>compnum</i> is a general complex number whose <span class="monospace">real-part</span> and <span class="monospace">imag-part</span> are both flonums.  The following procedures should be in a different library from the flonum procedures, since they will only be relevant to Schemes that support general complex numbers, and since there are conflicting names.</p>
      <table><tr><td class="default">
            <p>Scheme name</p></td><td class="default">
            <p>C signature</p></td><td class="default">
            <p>Comments</p></td></tr><tr><td class="default">
            <p><span class="monospace">abs</span></p></td><td class="default">
            <p><span class="monospace">double cabs(double complex)</span></p></td><td class="default">
            <p>same as magnitude</p></td></tr><tr><td class="default">
            <p><span class="monospace">acos</span></p></td><td class="default">
            <p><span class="monospace">double complex cacos(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">acosh</span></p></td><td class="default">
            <p><span class="monospace">double complex cacosh(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">angle</span></p></td><td class="default">
            <p><span class="monospace">double carg(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">asin</span></p></td><td class="default">
            <p><span class="monospace">double complex casin(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">asinh</span></p></td><td class="default">
            <p><span class="monospace">double complex casinh(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">atan</span></p></td><td class="default">
            <p><span class="monospace">double complex catan(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">atanh</span></p></td><td class="default">
            <p><span class="monospace">double complex catanh(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">conjugate</span></p></td><td class="default">
            <p><span class="monospace">double complex conj(double complex)</span></p></td><td class="default">
            <p>complex conjugate</p></td></tr><tr><td class="default">
            <p><span class="monospace">cos</span></p></td><td class="default">
            <p><span class="monospace">double complex ccos(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">cosh</span></p></td><td class="default">
            <p><span class="monospace">double complex ccosh(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">exp</span></p></td><td class="default">
            <p><span class="monospace">double complex cexp(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">expt</span></p></td><td class="default">
            <p><span class="monospace">double complex cpow(double complex, double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">imag-part</span></p></td><td class="default">
            <p><span class="monospace">double cimag(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">log</span></p></td><td class="default">
            <p><span class="monospace">double complex clog(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">magnitude</span></p></td><td class="default">
            <p><span class="monospace">double cabs(double complex)</span></p></td><td class="default">
            <p>same as abs</p></td></tr></table>
      <p>||<span class="monospace">projection</span>||<span class="monospace">double complex  cproj(double complex)</span>||projects to Riemann sphere</p>
      <table><tr><td class="default">
            <p><span class="monospace">real-part</span></p></td><td class="default">
            <p><span class="monospace">double creal(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">sin</span></p></td><td class="default">
            <p><span class="monospace">double complex csin(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">sinh</span></p></td><td class="default">
            <p><span class="monospace">double complex csinh(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">sqrt</span></p></td><td class="default">
            <p><span class="monospace">double complex csqrt(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">tan</span></p></td><td class="default">
            <p><span class="monospace">double complex ctan(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr><tr><td class="default">
            <p><span class="monospace">tanh</span></p></td><td class="default">
            <p><span class="monospace">double complex ctanh(double complex)</span></p></td><td class="default">
            <p>-</p></td></tr></table>
      <h2 id="Derivedprocedures">Derived procedures</h2>
      <p>TODO: what library do these go in?</p>
      <p><span class="monospace">(cis </span><i>z</i><span class="monospace">)</span></p>
      <p>Returns e<sup>i<i>z</i></sup>, a complex number whose real part is cos <i>z</i> and whose imaginary part is sin <i>z</i>.</p>
      <p><span class="monospace">(signum </span><i>z</i><span class="monospace">)</span></p>
      <p>Returns a complex number whose phase is the same as <i>z</i> but whose magnitude is 1, unless <i>z</i> is zero, in which case it returns <i>z</i>.  As a consequence of this definition, negative real numbers return -1, positive real numbers return 1, and zero returns zero.</p>
      <p><span class="monospace">(decode-float </span><i>z</i><span class="monospace">)</span> and friends</p>
      <p>See <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/f_dec_fl.htm">CL DECODE-FLOAT and friends</a>.</p></div></body></html>