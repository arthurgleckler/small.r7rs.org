
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Copyright 2013 by Arthur A. Gleckler. All rights reserved. -->
    <title>PlebisciteObjections</title>
    <link href="/trac.css" rel="stylesheet" type="text/css"></head>
  <body>
    <header>This site is a static rendering of the <a href="https://trac.edgewall.org/">Trac</a> instance that was used by <a href="http://scheme-reports.org/2015/working-group-1.html">R7RS-WG1</a> for its work on R7RS-small (<a href="/attachment/r7rs.pdf">PDF</a>), which was ratified in 2013. For more information, see <a href="/">Home</a>. For a version of this page that may be more recent, see <a href="https://github.com/johnwcowan/r7rs-work/blob/master/PlebisciteObjections.md">PlebisciteObjections</a> in WG2's repo for R7RS-large.</header>
    <ul class="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/ticket/">All tickets</a></li>
      <li><a href="/wiki/">All wiki pages</a></li></ul>
    <h1 class="wiki">Plebiscite&shy;Objections</h1>
    <div class="wiki metadata">
      <div class="author">cowan</div>
      <div class="time">2013-05-12 00:29:02</div>
      <div class="version">5<span class="comment"></span><a href="/wiki/PlebisciteObjections/history">history</a></div>
      <div class="source"><a href="/wiki/PlebisciteObjections/5/source.html">source</a></div></div>
    <div class="wiki text">
      <p>I (John Cowan) have extracted the following formal and informal objections to draft 9 of R7RS-small from votes cast in the R7RS-small plebiscite.  I have in some cases provided suggested resolutions for the WG as well.</p>
      <ul>
        <li>The draft semantics of <span class="monospace">eq?</span> and <span class="monospace">eqv?</span> as applied to procedures should return to the IEEE/R5RS rules.
          <ul>
            <li>WG1 has already unanimously agreed with this statement.</li></ul></li>
        <li>In the draft as written, implementations are permitted to add new character names such as <span class="monospace">#\xbeef;</span> that can also be read as hexadecimal character references.
          <ul>
            <li>WG1 is considering this issue.</li></ul></li>
        <li>The various mapping procedures should be allowed to return results that are <span class="monospace">eqv?</span> to, or share storage with, one or more of their arguments.
          <ul>
            <li>WG1 is considering this issue.</li></ul></li>
        <li>The draft is gratuitously incompatible with R6RS.
          <ul>
            <li>R6RS in turn was incompatible with existing practice as expressed in SRFIs and implementations.  Many of the incompatibilities in the draft were meant to be compatible with this existing practice.</li></ul></li>
        <li>The proposed module system is pointlessly inflexible.
          <ul>
            <li>The only way to extend the module system in R6RS is through the use of syntax-case macros, which were considered to be too complex and controversial for R7RS-small.</li></ul></li>
        <li>The proposed module system requires additional boilerplate past the requirements of R6RS and implementation-specific module systems.
          <ul>
            <li>Only a little.  You can convert an R6RS module into the draft's module language by changing <span class="monospace">library</span> to <span class="monospace">define-library</span> and wrapping everything except the <span class="monospace">import</span> and <span class="monospace">export</span> declarations into a <span class="monospace">begin</span> library declaration.  (Of course, this assumes that the implementation provides both R6RS and R7RS modules for import.)</li></ul></li>
        <li>The semantics of the top level are unspecified in the draft.
          <ul>
            <li>They are not entirely specified, it's true.  But there is no reason for something to be either 100% specified or 0% specified.  A standard is a contract between user and implementer, and it may quite legitimately partly constrain the implementer or user while still providing some freedom of action.</li></ul></li>
        <li>The draft avoids making hard decisions, making it a mere description of the current state of Scheme.
          <ul>
            <li>A standard is inherently a compromise.  A rigid &quot;my way or the highway&quot; standard, especially a complex one, means that only a few implementers will be able to provide it, thus limiting the scope of user choices.</li></ul></li>
        <li>Many decisions were based on a tacit requirement to ignore R6RS.
          <ul>
            <li>There was, of course, no such tacit requirement.  Several members of the WG pushed R6RS solutions as hard as they could.  Sometimes they carried the group with them, sometimes they did not.</li></ul></li>
        <li>The draft is a step backwards (or at any rate fails to be a step forwards) from R6RS.
          <ul>
            <li>The R7RS-small language is not meant to replace R6RS.  Rather, it is meant to replace R5RS and at the same time provide a sound basis for the R7RS-large language, which is meant to replace R6RS.</li></ul></li>
        <li>The draft fails to stay true to the history and spirit of Scheme.
          <ul>
            <li>A matter of opinion.</li></ul></li>
        <li>The draft's failure to treat compatibility with R6RS as important is a move away from unity.
          <ul>
            <li>There was never much unity beyond the IEEE/R4RS/R5RS core.  The introduction of R6RS was not in itself a move toward or away from unity, but the fact that it was not widely accepted by existing implementations caused a de facto separation of implementations into R5RS and R6RS.  As has been noted, R7RS-small is not directly intended to address this separation.</li></ul></li>
        <li>For aficionados of Scheme's crystalline beauty, the draft has little to offer beyond R5RS.
          <ul>
            <li>It's a matter of opinion whether Scheme's procedure library (which is greatly extended) is a matter of diamond-like beauty in <i>any</i> version of the Scheme standard.  It is for the most part ad hoc and historical.</li></ul></li>
        <li>The draft has little to offer the working programmer over R6RS.
          <ul>
            <li>Probably true if application programmers are meant.  Library programmers, however, will be able to achieve more widely portable libraries if R7RS-small is adopted by the implementations that did not adopt R6RS.</li></ul></li>
        <li>The draft fails to provide library versioning, a pedagogically important topic.
          <ul>
            <li>The WG's view is that the R6RS library versioning system was insufficiently tested against implementations when it was proposed, and hasn't received much attention since.</li></ul></li>
        <li>The draft excludes assertions.
          <ul>
            <li>True.  The WG felt that simple <span class="monospace">assert</span> is insufficient, and a more complex and useful assertion facility was beyond the scope of the small language.</li></ul></li>
        <li>Programs that depend on full Unicode support are not portable to all R7RS implementations.
          <ul>
            <li>True.  However, many programs in the domain of the small language do not require extensive character support, and Unicode support is emphatically not free.</li></ul></li>
        <li>The syntaxes <span class="monospace">include</span> and <span class="monospace">include-ci</span>, and the <span class="monospace">load</span> procedure, don't belong in Scheme.
          <ul>
            <li>The <span class="monospace">load</span> procedure has been around</li></ul></li>
        <li>The draft does not provide the important higher-order procedures in the R6RS <span class="monospace">(rnrs lists)</span> library.
          <ul>
            <li>Equivalents exist in SRFI 1, which is well-established, available in almost all Scheme implementations, and will be directly incorporated into the large language.</li></ul></li>
        <li>The draft does not require the Scheme language to be safely implemented in conforming implementations.
          <ul>
            <li>Not mandating safety allows implementations to trade off safety for performance for the sake of users and programs who need that performance.  This can be done either by a safety setting in a single implementation or by allowing pervasively unsafe, yet conformant, implementations to be created.</li></ul></li>
        <li>The draft defines a less expressive language than the R6RS base language.
          <ul>
            <li></li></ul></li>
        <li>The &quot;stack-winding dance&quot; of <span class="monospace">guard</span> clauses is not dealt with in a satisfactory way.
          <ul>
            <li></li></ul></li>
        <li>Mutable strings are still present in the draft despite their undesirability.
          <ul>
            <li>True.  Immutable strings would be useful in many ways; unfortunately, mutable strings are part of IEEE, and the WG did not feel that the high bar for removing IEEE features was reached even in this case.</li></ul></li>
        <li>The draft insists that certain procedures return a single unspecified value rather than an unspecified number of unspecified values.
          <ul>
            <li>That provision makes it possible to invoke an unknown procedure safely without needing to wrap it in <span class="monospace">call-with-values</span> or an equivalent.</li></ul></li>
        <li>Adding Unicode support is too large a change from R5RS.
          <ul>
            <li>It is still possible for a Scheme to provide ASCII-only support; the only constraint is that it must be done in a way that extends smoothly to the rest of the Unicode repertoire.</li></ul></li>
        <li>Exceptions integrate badly with the rest of the language.
          <ul>
            <li>Perhaps that is because they are pure R6RS.  We can't do it all.</li></ul></li>
        <li>The syntaxes <span class="monospace">#true</span> and <span class="monospace">#false</span> are totally gratuitous.
          <ul>
            <li>They add a little extra readability, but are optional.  Early versions of the Scheme standard provided them in the forms <span class="monospace">#!true</span> and <span class="monospace">#!false</span>.</li></ul></li>
        <li>The lexical syntax <span class="monospace">#| ... |#</span> is unsightly.
          <ul>
            <li>A matter of taste.  Many Schemes provide it already, including R6RS.</li></ul></li>
        <li>The lexical syntax <span class="monospace">#!(no-)fold-case</span> is a bit ugly.
          <ul>
            <li>It is R6RS-compatible and fairly clear.  The alternatives <span class="monospace">#cs</span> (case sensitive) and <span class="monospace">#ci</span> are less widely standardized and less intuitively clear.</li></ul></li>
        <li>The <span class="monospace">read-line</span> procedure can cause a denial of service because it does not provide for a limit on the amount of input read.
          <ul>
            <li>True.  However, <span class="monospace">read</span> has the same problem.  It's easy for an implementation that worries about this sort of thing to provide an optional second argument setting a limit.</li></ul></li>
        <li>The syntax of <span class="monospace">define-record-type</span> is unscalable and not open to extension.
          <ul>
            <li>True.  However, it is extremely widely implemented, more so than any other non-R5RS syntax or procedure.  WG members who voted for it emphasized the importance of compatibility.</li></ul></li>
        <li>The systematic use of parameters would be better than proliferating separate procedures, specifically in the <span class="monospace">write</span>, <span class="monospace">write-simple</span>, and <span class="monospace">write-shared</span> procedures and the <span class="monospace">include</span> and <span class="monospace">include-ci</span> syntaxes.
          <ul>
            <li>Au contraire.  If that were done, the only safe way to call <span class="monospace">write</span> would be by always wrapping it in a <span class="monospace">parameterize</span> form, which is longer and less clear.  Syntax forms are not affected by the state of (run-time) parameter objects.</li></ul></li>
        <li>The <span class="monospace">error</span> procedure is gratuitously different from the R6RS version.
          <ul>
            <li>Which in turn was gratuitously different from SRFI 23.</li></ul></li>
        <li>The <span class="monospace">include</span>, <span class="monospace">include-ci</span>, and <span class="monospace">include-library-declarations</span> syntaxes are ugly and unnecessary consequences of the artificial limitations on modules.
          <ul>
            <li></li></ul></li>
        <li>The <span class="monospace">cond-expand</span> syntax does not scale well, and we have done little to fix the issues that make it un-useful.
          <ul>
            <li></li></ul></li>
        <li>The lack of a fully-featured macro system requires the use of sub-par constructs.
          <ul>
            <li>There are too many fully-featured macro systems around, and WG1 believed that none of them were appropriate for the small language, bringing in as they do considerations of phasing.  There is no reason why the large language cannot provide more than one.</li></ul></li>
        <li>The draft's version of Scheme has no conception of user extensibility in the library system or conditional expansion.
          <ul>
            <li>The module system is the largest mandatory extension to R5RS.  Keeping it simple and static rather than allowing greater generality seemed to the WG to be the appropriate tradeoff between flexibility and ease of use and implementation.  Not everything in Scheme is designed for maximal flexibility.</li></ul></li>
        <li>The draft follows the style and wording of R5RS rather than the better, more precise, and clearer R6RS language.
          <ul>
            <li>A matter of opinion.  John Cowan personally does not believe that changing every occurrence of &quot;number&quot; to &quot;number object&quot; actually helped either precision or clarity.</li></ul></li>
        <li>The draft should reflect the intersection of high-quality industrial-strength implementations, not the intersection of every toy Scheme ever written.
          <ul>
            <li>Which implementations are those?  Schemers disagree.</li></ul></li>
        <li>The <span class="monospace">call/cc</span> abstraction is intractable and not useful and should have been excluded.
          <ul>
            <li>The WG did not believe that the very high bar for removing an IEEE Scheme feature was met.</li></ul></li>
        <li>The draft was forbidden by its charter to remove restrictions that make additional features seem necessary.
          <ul>
            <li>If the restrictions in question were hard-coded into R5RS, and removing them would break backward compatibility, then yes.  Restrictions that could be removed without breaking backward compatibility could be and sometimes were removed; for example, the restriction that <span class="monospace">load</span> loads into the interaction environment only.</li></ul></li>
        <li>The large language should have been developed before the small language.
          <ul>
            <li>This objection is untimely.  In addition, developing a large language and then subsetting it would have a higher overall risk of failure; if the large language was never completed, the small language would not exist.</li></ul></li>
        <li>The text-handling routines are redundant or inelegant in a Unicode world, but could not be removed or fundamentally altered due to charter restrictions.
          <ul>
            <li>Scheme would probably be better off not treating strings as sequences of characters, but rather treating characters as a special case of strings.  Unfortunately, that's too far away from the IEEE model.</li></ul></li>
        <li>The interaction between exceptions, <span class="monospace">dynamic-wind</span>, and continuations is missing something orthogonal.
          <ul>
            <li>This objection is too vague to meet head-on.</li></ul></li>
        <li><a href="/wiki/Parameters">Parameters</a> don't belong in the base language.
          <ul>
            <li>They can be provided portably on top of <span class="monospace">dynamic-wind</span> provided the implementation does not provide native threads.  In the presence of threads, however, such a portable implementation will produce unintuitive results.</li></ul></li>
        <li>The draft made many matters settled by R6RS undefined again.
          <ul>
            <li>Since R6RS support never became pervasive, these matters were in practice not defined in a way that Schemers could rely on, unless they used only R6RS-compatible implementations.</li></ul></li>
        <li>The order of arguments in the draft's <span class="monospace">bytevector-copy</span> is fundamentally incompatible with R6RS in an undetectable way, though it is R6RS that is wrong here.
          <ul>
            <li>True and unfortunate, but the draft's approach is consistent with the rest of Scheme.</li></ul></li>
        <li>The draft should have included delimited continuation support.
          <ul>
            <li>The large language will provide it.</li></ul></li>
        <li>The draft does not provide procedures that operate on mixed types of sequences (e.g. a map function that accepts a list and a vector and applies a two-argument function element-wise on them).
          <ul>
            <li>True.  Unfortunately, no one proposed them during the working life of WG1.</li></ul></li>
        <li>The draft is too conservative in its changes to R5RS.
          <ul>
            <li>That was a charter requirement.</li></ul></li></ul></div></body></html>