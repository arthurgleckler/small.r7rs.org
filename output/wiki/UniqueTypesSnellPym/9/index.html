
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Copyright 2013 by Arthur A. Gleckler. All rights reserved. -->
    <title>UniqueTypesSnellPym</title>
    <link href="/trac.css" rel="stylesheet" type="text/css"></head>
  <body>
    <header>This site is a static rendering of the <a href="https://trac.edgewall.org/">Trac</a> instance that was used by <a href="http://scheme-reports.org/2015/working-group-1.html">R7RS-WG1</a> for its work on R7RS-small (<a href="/attachment/r7rs.pdf">PDF</a>), which was ratified in 2013. For more information, see <a href="/">Home</a>. For a version of this page that may be more recent, see <a href="https://github.com/johnwcowan/r7rs-work/blob/master/UniqueTypesSnellPym.md">UniqueTypesSnellPym</a> in WG2's repo for R7RS-large.</header>
    <ul class="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/ticket/">All tickets</a></li>
      <li><a href="/wiki/">All wiki pages</a></li></ul>
    <h1 class="wiki">Unique&shy;Types&shy;Snell&shy;Pym</h1>
    <div class="wiki metadata">
      <div class="author">alaric</div>
      <div class="time">2010-11-01 05:25:22</div>
      <div class="version">9<span class="comment">Fixed markup error</span><a href="/wiki/UniqueTypesSnellPym/history">history</a></div>
      <div class="source"><a href="/wiki/UniqueTypesSnellPym/9/source.html">source</a></div></div>
    <div class="wiki text">
      <h1 id="Background">Background</h1>
      <p>I feel that records are too complex and controversial and varied for standardisation in WG1.</p>
      <p>We all love records, but there's a number of ways of doing them.</p>
      <p>There's widespread consensus that defining a record type FOO with fields X, Y, and Z should result in procedures FOO?, FOO-X, FOO-Y, FOO-Z, MAKE-FOO, and sometimes FOO-X-SET!, FOO-Y-SET! and FOO-Z-SET!; however, there's less consensus about definition forms, let alone more esoteric features like purely functional mutators, constructs that open up a record by creating a lexical environment in which X is bound to (FOO-X &lt;record&gt;) and so on, etc.</p>
      <p>Perhaps most importantly, records need to be distinct types. If you implement them in terms of vectors, everything seems to work fine, but a subtle kind of hygiene is broken. If somebody writes a function that dispatches on type for some reason, and they have a case for handling vectors that comes before the case for some record type, then the vector case will be triggered unexpectedly. Oh, noes!</p>
      <p>Also, there is potential variation in implementation. It's widely accepted that programming languages should generally support records in the sense of first-class values in memory, but third-party libraries (or the outer reaches of a more sprawling language) may well want to implement a record-like interface - at least FOO? FOO-&lt;field&gt;, FOO-&lt;field&gt;-SET! *and type disjointness* - to things like persistent data in a database, data accessed via some network protocol, and other such forms. Clearly, Thing One already allows the definition of the procedures, and type disjointness is all we need 'added'.</p>
      <p>And, obviously, any manner of in-memory record abstraction can be implemented with suitable macros - if we have a means of forming disjoint types.</p>
      <p>Therefore, I propose that WG1 should standardise a primitive mechanism to create disjoint types, allowing portable libraries to implement SRFI-9, SRFI-99, R6RS records, Chicken records, CLOS, persistent databases, remote access to data on servers, and the like; WG2 should probably pick or create a record standard, but that's not my problem (and I'm happy either way, as I can have whatever record system I fancy as a portable library anyway).</p>
      <p>It is possible to build arbitrary record-like disjoint types on top of (eg) SRFI-9 records, by exposing the <span class="monospace">FOO?</span> procedure and wrapping the accessors and (where applicable) constructors and mutators, but this gives me a non-jewel-like feeling.</p>
      <h1 id="Themeatoftheproposal">The meat of the proposal</h1>
      <p>The semantics of such a system are fairly simple and obvious, and the syntax used in the Kernel programming language seems as good as any. Slightly altered for Schemier style, here it is:</p><span class="monospace">(make-encapsulation-type &lt;size&gt;)
</span>
      <p>Returns three or more values: procedures <span class="monospace">e</span>, <span class="monospace">p?</span> and <span class="monospace">d</span>, and perhaps some implementation-defined extra ones after that. Each call to <span class="monospace">(make-encapsulation-type)</span> returns different procedures.</p>
      <ul>
        <li><span class="monospace">e</span> is a procedure that takes &lt;size&gt; arguments, and returns a fresh encapsulation with those arguments as the content. Different calls to <span class="monospace">e</span> produce encapsulations that are not <span class="monospace">eq?</span>, but will be <span class="monospace">equal?</span> if their contents are equal? and they were both produced by <span class="monospace">e</span>.</li></ul>
      <ul>
        <li><span class="monospace">p?</span> is a procedure that takes one argument, and returns <span class="monospace">#t</span> if the argument is an encapsulation that was returned by a call to <span class="monospace">e</span>, and <span class="monospace">#f</span> in all other cases.</li></ul>
      <ul>
        <li><span class="monospace">d</span> is a procedure that takes two arguments. If the first is an encapsulation that was returned by a call to <span class="monospace">e</span>, and N is an exact integer more than or equal to zero and less than &lt;size&gt;, then the Nth content of the encapsulation (where N is the second argument) is returned. Otherwise, an error is signalled.</li></ul><span class="monospace">(make-encapsulation-type &lt;size&gt; &lt;symbol&gt;)
</span>
      <p>As above, but annotates the type with a descriptive symbol. The implementation is free to ignore the symbol, but may use it to aid debugging or providing printable representations of the encapsulated type. However, implementors be warned that the users are in no way obliged to make descriptive symbols be unique, so don't go using it in ways that would assume this.</p>
      <h1 id="Writtenform">Written form</h1>
      <p>One of the reasons to have a unique type encapsulation system is for security, to prevent access to the contents of an object, and to prevent objects of that type being constructed by arbitrary code.</p>
      <p>Therefore, the result of calling <span class="monospace">write</span> on an encapsulation should not reveal the contents of the encapsulation's fields by default, and <span class="monospace">read</span> should be incapable of creating encapsulations by default.</p>
      <p>However, mechanisms for attaching <span class="monospace">read</span> and <span class="monospace">write</span> semantics to encapsulations should be addressed by WG2 or an SRFI. My quick proposal is that it should be possible to attach encode/decode procedures to an encapsulation type, which map an instance of the encapsulation type to a list of fields, and the inverse; then <span class="monospace">write</span> should produce syntax something like <span class="monospace">#&lt;symbol&gt;(&lt;...list of fields returned by encoder...&gt;)</span>, where the <span class="monospace">&lt;symbol&gt;</span> is the registered name of the type (and must be unique), and <span class="monospace">read</span> should parse that syntax by calling the decoder function registered under that symbolic name, with the list of parsed fields.</p>
      <p>How to maintain uniqueness of type-name symbols globally is left as an exercise for the reader.</p>
      <h1 id="Optionalextension:TypeInheritance(pleasevoteas`snellpym+inheritance`insteadof`snellpym`ifyouwantthis)">Optional extension: Type Inheritance (please vote as <span class="monospace">snellpym+inheritance</span> instead of <span class="monospace">snellpym</span> if you want this)</h1><span class="monospace">(make-encapsulation-subtype &lt;e&gt; &lt;d&gt; &lt;extra-size&gt; [&lt;symbol&gt;])
</span>
      <p>Creates a subtype T2 of an existing encapsulation type T1. The parent type's <span class="monospace">e</span> and <span class="monospace">d</span> procedures must both be provided to demonstrate the caller's existing ability to construct and deconstruct the parent type (<span class="monospace">p?</span> is really just a convenience, that could be crafted from <span class="monospace">d</span> and a condition handler, so access to it need not be proven). The returned values are as per <span class="monospace">make-encapsulation-type</span>, except that the &lt;size&gt; is equal to the parent's &lt;size&gt; plus &lt;extra-size&gt;; however, the definition of <span class="monospace">make-encapsulation-type</span>s return values (and, therefore, the return values of <span class="monospace">make-encapsulation-subtype</span>) is extended such that <span class="monospace">p?</span> also returns true for encapsulations created by any subtype's <span class="monospace">e</span> procedure, and <span class="monospace">d</span> will work for encapsulations created by subtypes' <span class="monospace">e</span> procedures, and when called on an encapsulation created by a subtype's <span class="monospace">e</span> procedure, will work for indices up to <span class="monospace">(+ &lt;parent-size&gt; &lt;extra-size&gt;)</span>.</p>
      <h1 id="Rationale">Rationale</h1>
      <p>I originally specified a single &quot;content item&quot; in the encapsulations, suggesting that users drop a vector in there if they wanted to, but without loss of generality (and only a little loss of simplicity), implementations can easily avoid an extra indirection by providing an embedded vector for free.</p>
      <p>I have not specified a mutation operation here, but have allowed for implementation extensions to return extra values from <span class="monospace">make-encapsulation-type</span> to allow for a mutator procedure, or for implementations to provide a separate <span class="monospace">make-mutable-encapsulation-type</span> etc.</p>
      <p>I have made the encapsulation types have a hard-coded size when the type is created, in order to avoid requiring implementations to store a type descriptor *and* a length in every instance of that type. Variable-length behaviour can be had by embedding a vector created at instance creation time, if so desired.</p></div></body></html>