
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Copyright 2013 by Arthur A. Gleckler. All rights reserved. -->
    <title>Source for wiki CyclesMedernach version 5</title>
    <link href="/trac.css" rel="stylesheet" type="text/css"></head>
  <body>
    <header>This site is a static rendering of the <a href="https://trac.edgewall.org/">Trac</a> instance that was used by <a href="http://scheme-reports.org/2015/working-group-1.html">R7RS-WG1</a> for its work on R7RS-small (<a href="/attachment/r7rs.pdf">PDF</a>), which was ratified in 2013. For more information, see <a href="/">Home</a>.</header>
    <ul class="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/ticket/">All tickets</a></li>
      <li><a href="/wiki/">All wiki pages</a></li></ul>
    <h1>Source for wiki CyclesMedernach version 5</h1>
    <h2>author</h2>
    <pre>cowan</pre>
    <h2>comment</h2>
    <pre></pre>
    <h2>ipnr</h2>
    <pre>198.185.18.207</pre>
    <h2>name</h2>
    <pre>CyclesMedernach</pre>
    <h2>readonly</h2>
    <pre>0</pre>
    <h2>text</h2>
    <pre>== Cycle type ==

Cycles are an immutable ordered, but unindexed, container type similar to circular lists.

The idea is to make a cycle type disjoint from the other types, only interface is standardized. Scheme implementations are free to use any underlying structure to achieve it.

=== Constructor and type conversion === 

`(make-cycle `''list''`)`

Constructs and returns a new cycle whose elements are the elements of ''list''.

`(cycle `''element'' ...`)`

Constructs and returns a new cycle containing ''elements''.

`(cycle-&gt;list `''cycle''`)`

Constructs and returns a list whose elements are those of ''cycle''.

=== Predicate ===

`(cycle? `''obj''`)`

Returns `#t` if obj is a cycle, and otherwise returns `#f`.

=== Associated procedures ===

`(cycle-length `''cycle''`)`

Returns the number of elements in ''cycle''.

`(cycle-front `''cycle''`)`

Returns the element in front of ''cycle''.

`(cycle-remove-front `''cycle''`)`

''cycle-remove-front'' returns a cycle obtained from ''cycle'' where the front element has been removed.

`(cycle-rotate `''cycle''` `''k''`)`

''cycle-rotate'' returns a cycle obtained from ''cycle'' by a rotation of ''k'', which is an exact integer.  If ''k'' is positive, the rotation is forward; if ''k'' is negative, the rotation is backward; if ''k'' is zero, there is no rotation.

`(cycle-insert `''cycle''` `''obj''`)`

Return a cycle where ''obj'' is put in front in ''cycle''.

`(cycle=? `''equivalence cycle,,1,, cycle,,2,,''`)`

Return `#t` if ''cycle,,1,,'' and ''cycle,,2,,'' contain the same values (in the sense of the ''equivalence'' predicate) in the same order, independent of their rotations; otherwise return `#f`.

Example:  `(cycle=? (make-cycle 1 2 3) (make-cycle 3 1 2)) =&gt; t`

`(cycle-map `''proc''` `''cycle'' ...`)`

All cycles must have the same length, and ''proc'' must be a procedure taking as many arguments as there are ''cycles'' and returning a single value. `cycle-map` applies ''proc'' to the elements of the cycle(s) and returns a newly allocated cycle of the corresponding results.

`(cycle-for-each `''proc''` `''cycle'' ...`)`

All cycles must have the same length, and ''proc'' must be a procedure taking as many arguments as there are ''cycles''. `cycle-for-each` applies ''proc'' to the elements of the cycle(s) and discards any results.

`(cycle-fold `''proc''` `''nil''` `''cycle'' ...`)`

All cycles must have the same length, and ''proc'' must be a procedure taking as many arguments as there are ''cycles'', plus one additional argument, and returning a single value. `cycle-fold` applies ''proc'' to the elements of the cycle(s) and the value previously returned by ''proc''.  On the first call to ''proc'', the additional argument is ''nil''.  Returns the result of the final call to ''proc''.

`(cycle-unfold `''continue? successor mapper seed''`)`

Start with an empty list.  If the result of applying the predicate ''continue?'' to ''seed'' is `#f`, apply `make-cycle` to the reversed list and return the result.  Otherwise, apply the procedure ''mapper'' to ''seed''.  The value of ''mapper'' is prepended onto the list.  Then get a new seed by applying the procedure ''successor'' to ''seed'', and repeat this algorithm.

=== External representations ===

The cycle composed of elements 1, 2 and 3 with 1 in front can be written as following:

  `#cycle(1 2 3)`




</pre>
    <h2>time</h2>
    <pre>2013-05-20 22:11:11</pre>
    <h2>version</h2>
    <pre>5</pre></body></html>