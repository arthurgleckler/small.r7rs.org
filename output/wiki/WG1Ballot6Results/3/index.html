
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Copyright 2013 by Arthur A. Gleckler. All rights reserved. -->
    <title>WG1Ballot6Results</title>
    <link href="/trac.css" rel="stylesheet" type="text/css"></head>
  <body>
    <header>This site is a static rendering of the <a href="https://trac.edgewall.org/">Trac</a> instance that was used by <a href="http://scheme-reports.org/2015/working-group-1.html">R7RS-WG1</a> for its work on R7RS-small (<a href="/attachment/r7rs.pdf">PDF</a>), which was ratified in 2013. For more information, see <a href="/">Home</a>. For a version of this page that may be more recent, see <a href="https://github.com/johnwcowan/r7rs-work/blob/master/WG1Ballot6Results.md">WG1Ballot6Results</a> in WG2's repo for R7RS-large.</header>
    <ul class="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/ticket/">All tickets</a></li>
      <li><a href="/wiki/">All wiki pages</a></li></ul>
    <h1 class="wiki">WG1Ballot6Results</h1>
    <div class="wiki metadata">
      <div class="author">alexshinn</div>
      <div class="time">2012-08-23 19:08:43</div>
      <div class="version">3<span class="comment">finalized ballot 6</span><a href="/wiki/WG1Ballot6Results/history">history</a></div>
      <div class="source"><a href="/wiki/WG1Ballot6Results/3/source.html">source</a></div></div>
    <div class="wiki text">
      <h1 id="NotesaboutResults">Notes about Results</h1>
      <p>See <a href="/wiki/WG1BallotExplanation">WG1BallotExplanation</a>.</p>
      <h1 id="WG1BallotItemsToFinalizeByJuly31">WG1 Ballot Items To Finalize By July 31</h1>
      <h2 id="WG1-Core">WG1 - Core</h2>
      <h3 id="#460Semanticsof`eqv?`"><a href="/ticket/460">#460</a> Semantics of <span class="monospace">eqv?</span></h3>
      <p>Earlier we voted on <a href="/ticket/125">#125</a>, <a href="/ticket/229">#229</a> and <a href="/ticket/345">#345</a> separately without regard to
the formal semantics of <span class="monospace">eqv?</span> from a top level.  We need to first
decide what the definition of <span class="monospace">eqv?</span> is, and consider if there should
be any exception cases as a secondary effect.</p>
      <p>The debate is fundamentally one of whether we define <span class="monospace">eqv?</span> in terms
of &quot;operational equivalence&quot; as in R6RS or a simpler rule
(e.g. resolve by <span class="monospace">=</span>) as in earlier standards.</p>
      <p>R2RS had the simplest historical rule which was simply to use <span class="monospace">=</span>.</p>
      <p>The term &quot;operational equivalence&quot; appears in R3RS but for numbers the
definition is the same as in R4RS and R5RS, which is <span class="monospace">=</span> plus the same
exactness.  This is the <span class="monospace">r5rs</span> option, with the &quot;true&quot; cases written formally as:</p><span class="monospace">  The `eqv?` procedure returns #t if:

  (1) obj1 and obj2 are both booleans and are the same according
  to the `boolean=?` procedure.

  (2) obj1 and obj2 are both symbols and are the same symbol
  according to the `symbol=?` procedure.

  (3) obj1 and obj2 are both numbers, have the same exactness, are
  numerically equal (see `=`).

  (4) obj1 and obj2 are both characters and are the same
  character according to the `char=?` procedure.

  (5) obj1 and obj2 are both the empty list.

  (6) obj1 and obj2 are pairs, vectors, bytevectors, records,
  or strings that denote the same location in the store.

  (7) obj1 and obj2 are procedures whose location tags are equal.
</span>
      <p>Note that (7) is an exception case which will be decided
separately in <a href="/ticket/125">#125</a>.  Furthermore, an exception to make NaNs
unspecified regardless of the semantics here will be decided in
<a href="/ticket/229">#229</a>.</p>
      <p>The <span class="monospace">r6rs</span> vote replaces (3) with the following operational
equivalence semantics:</p><span class="monospace">  (3.1) obj1 and obj2 are both exact numbers and are numerically
  equal (see `=`)

  (3.2) obj1 and obj2 are both inexact numbers, are numerically
  equal (see `=`), and yield the same results (in the sense of
  `eqv?`) when passed as arguments to any other procedure that
  can be defined as a finite composition of Scheme’s standard
  arithmetic procedures.
</span>
      <p>where &quot;standard arithmetic procedures&quot; refers arguably to either</p>
      <ol class="number" start="11">
        <li>7 or 11.7.4.3.  For R7RS it would apply to the &quot;Numbers&quot;</li></ol>
      <p>section 6.2.6.  R6RS further adds an extra case which is not
applicable because we don't guarantee record-types are first-class
objects:</p><span class="monospace">  (8) obj1 and obj2 are record-type descriptors that are
  specified to be `eqv?` in library section on “Procedural
  layer”.
</span>
      <p>The <span class="monospace">r6rs/all</span> option changes (3.2) to a finite composition of
any of the implementations arithmetic procedures.  The intention
is that <span class="monospace">decode-float</span> if provided could distinguish NaNs, but
something like <span class="monospace">eq?</span> (which could distinguish the same bit
pattern in different locations) would not be considered
arithmetic and not apply.  This does leave the
definition &quot;arithmetic&quot; open to some interpretation.</p>
      <p>In contrast to R6RS, R7RS does not require the full numeric tower.
This means that any definition of operational equivalence would render
many numbers unspecified from the perspective of the standard, yet
users could rely on consistency within their own implementation, and
broad agreement amongst most implementations which provide the full
tower.</p>
      <p>Finally, the <span class="monospace">same-bits</span> option replaces (3) with:</p><span class="monospace">  (3.1) obj1 and obj2 are both exact numbers and are numerically
  equal (see `=`)

  (3.2) obj1 and obj2 are both inexact real numbers conforming to the
  IEEE 754-2008 standard, and they have the same radix,
  precision, maximum exponent, sign, exponent, and significand as
  described in IEEE 754-2008

  (3.3) obj1 and obj2 are both inexact real numbers, are not implemented using
  IEEE 754-2008, and are numerically equal (see `=`)

  (3.4) obj1 and obj2 are both complex numbers whose real and imaginary
  parts are `eqv?`
</span>
      <p>Keep in mind the semantics of <span class="monospace">eqv?</span> also affect <span class="monospace">memv</span>, <span class="monospace">assv</span> and
<span class="monospace">case</span>.</p>
      <ul>
        <li><b>References:</b>
          <ul>
            <li><a href="https://groups.google.com/d/msg/scheme-reports-wg1/BGvDFtD6A1M/5pHmfXHtvEIJ">eqv? issues summarized</a></li>
            <li><a href="https://groups.google.com/d/msg/scheme-reports-wg1/2Nv6oIND8HI/Z2HXPQMNFooJ">the history of eqv? on numbers</a></li></ul></li>
        <li><b>Options:</b> r5rs, r6rs, r6rs/all, same-bits</li>
        <li><b>Default:</b> r5rs</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: r6rs/all, r6rs</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: same-bits, r5rs, r6rs/all, r6rs</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: same-bits, r5rs, r6rs, r6rs/all</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: r6rs, r6rs/all</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: same-bits, r6rs/all, r6rs</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: same-bits, r6rs/all, r6rs, r5rs</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: same-bits, r5rs</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: same-bits, r6rs, r6rs/all, r5rs</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: r5rs, r6rs/all, same-bits, r6rs</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: r6rs, r5rs, (r6rs/all   same-bits)</li></ul></li>
        <li><b>Results:</b> <b>same-bits</b>, r6rs/all, r6rs, r5rs</li>
        <li><b>Ratios:</b> 6:3, 7:3, 6:2</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>On systems where <span class="monospace">0.0</span> and <span class="monospace">-0.0</span> are mathematically distinct, they should be distinct in the sense of <span class="monospace">eqv?</span> as well, and the same for <span class="monospace">1.0+2.0i</span> and <span class="monospace">1.0+2i</span>.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I sympathize with the motivation of <span class="monospace">r6rs</span> in getting at &quot;true&quot; operational equivalence, but agree with Alex that this eventually becomes inseparable from the machine implementation, and is thus not suitable for its most prominent use. <span class="monospace">same-bits</span> is of course also somewhat implementation-dependent, but in a more controlled way.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I was impressed by Bradley's arguments that same-bits matches IEEE 754 and is therefore superior. The R6RS semantics are defined too indirectly and are too dependent on the specific combination of numeric features supported by the implementation. The R5RS semantics are clearer. I would argue for an option that is the same as r5rs but distinguishes between positive and negative zero in the same way as we already distinguish between exact and inexact, but that does not appear on the ballot. I don't agree with choosing <span class="monospace">r6rs/all</span> over <span class="monospace">r6rs</span>. Implementation-specific procedures like <span class="monospace">decode-float</span>, the example given above, are specifically designed to expose implementation details, whereas <span class="monospace">eqv?</span> has generally been used to compare numbers arithmetically. If we a<a href="/wiki/WG1BallotGleckler">...</a></dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>The R6RS option seems to provide more rigor, in particular in determining actual equivalence, rather than &quot;mathematical equality.&quot; The notion provided by R6RS is useful and important, and without it, I do not see a good way to portably provide both <span class="monospace">=</span> and the operational equivalence notions. Let us have the distinctions. You can get back to the R5RS version yourself if you really need it.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>Bradley Lucier provides a good case for 'same-bits'. The notion of sameness of two floats is well-specified in IEEE 754; we should use it.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I don't think the operational semantics of R6RS is well defined, nor is it appropriate when so much is unspecified about the numeric tower. If we are going to use an operational semantics, however, it should reflect the full semantics of the implementation so as to be usable for memoization, so I put r6rs/all before r6rs.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>My gut feeling is that eqv? should be about equivalence, so I like the &quot;operationally indistinguishable&quot; notion; yet I also feel that anything which peeks beneath the hood of the numeric abstraction, such as bitwise comparison or implementation-provided introspection features, should be exempt from that.</dd></dl>
      <h3 id="#229eqv?andNaN"><a href="/ticket/229">#229</a> eqv? and NaN</h3>
      <p>As announced previously this is being re-opened due to incorrect
formulation in the previous ballot, and in response to formal comment
<a href="/ticket/423">#423</a>.</p>
      <p>Regardless of the result of <a href="/ticket/460">#460</a>, the semantics implies that <span class="monospace">eqv?</span>
return <span class="monospace">#f</span> on comparing any two NaN objects.  It is reasonable to
want to consider any two NaNs as the &quot;same&quot; since they behave the same
under any operation, even though none of the results are <span class="monospace">=</span>.  Moreover,
it is very common to use a shortcut <span class="monospace">eq?</span> pointer comparison before
falling back on general <span class="monospace">eqv?</span> logic.  In deference to this R6RS makes
an exception and allows the result to be unspecified, and we should
consider allowing this exception.</p>
      <p>This proposal is only to allow an explicit exception to make
NaN comparisons unspecified, regardless of the semantics.
Vote <span class="monospace">no-exception</span> (or anything other than <span class="monospace">unspecified</span>)
to require NaN comparisons to follow directly from <a href="/ticket/460">#460</a>.</p>
      <p>The default of <span class="monospace">unspecified</span> still holds from the previous invalidated
ballot.</p>
      <ul>
        <li><b>Options:</b> no-exception, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no-exception</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: unspecified, no-exception, undecided</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: no-exception</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: no-exception, unspecified</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: unspecified, different</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: no-exception, unspecified</li></ul></li>
        <li><b>Results:</b> <b>unspecified</b>, no-exception, undecided, different</li>
        <li><b>Ratios:</b> 6:4, 8:0, 8:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>This is a marginal case which is not worth prescribing. I would have preferred all NaNs to be <span class="monospace">eqv?</span> to each other, but that's probably not achievable.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I think it is reasonable to consider two of the &quot;same&quot; NaNs to be <span class="monospace">eqv?</span>, and see no reason not to specify this behavior. The specified behavior of <span class="monospace">=</span> on numbers is not relevant to NaNs.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>There is not enough agreement about this to make a requirement. NaN's can be addressed specially by code that uses them.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>This seems like a reasonable exception to make, and should not hurt in any case.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>It will depend on the <a href="/ticket/460">#460</a> item result, but personnaly I would prefer to be able to distinguish different NaNs and to identify identical NaNs (&quot;same&quot; vote).</dd>
        <dt><span class="monospace">Radul</span></dt>
        <dd>As I interpret same-bits, it would actually require eqv? to return #t on two IEEE NaNs that did, in fact, have the same pattern of bits. This case satisfies all rationales I can think of for wanting NaNs to compare eqv?.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>NaNs which may be distinguished are part of the IEEE 754 abstraction; eqv? should distinguish them even if = doesn't.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Mostly because there is so much disagreement about this, and the <span class="monospace">eq?</span> shortcut is so common, I'm OK with this exception.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>At this level of abstraction, a NaN is a NaN; differentiating NaNs is peeking below the abstraction again.</dd></dl>
      <h3 id="#125Allowproceduresnottobelocations(makingEQV?unspecifiedinsomeadditionalcases)"><a href="/ticket/125">#125</a> Allow procedures not to be locations (making EQV? unspecified in some additional cases)</h3>
      <p>Procedures are another case for contention with <span class="monospace">eqv?</span>.  In R3RS, an
operational equivalence was defined for procedures, and this was
subsequently removed.</p>
      <p>R6RS went the other direction and allowed the exact same procedure <span class="monospace">x</span>
to return <span class="monospace">#f</span> for <span class="monospace">(eqv? x x)</span>, and R7RS currently reaffirms this.
The rationale behind this is for compiler optimizations such as
inlining local procedures, that is given:</p><span class="monospace">(let ((square (lambda (x) (* x x))))
  (eqv? square square))
</span>
      <p>it is reasonable for a compiler to perform the optimization:</p><span class="monospace">(eqv? (lambda (x) (* x x)) (lambda (x) (* x x)))
</span>
      <p>in which case the result would naturally return <span class="monospace">#f</span>.</p>
      <p>Vote <span class="monospace">yes</span> to allow the result to be <span class="monospace">#f</span>.</p>
      <p>The default of <span class="monospace">yes</span> still holds from the previous invalidated ballot.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> yes</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: no</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes, undecided, no</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: no</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes, no</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no, undecided</li>
        <li><b>Ratios:</b> 6:4, 6:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Although this means that procedures aren't quite first-class (you can't reliably use <span class="monospace">memv</span> to determine if a procedure can be found in a list), I think we don't want to renege on the license to return <span class="monospace">#f</span> that R6RS provided and that optimizing compilers exploit.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I interpret this as <span class="monospace">(eqv? x x)</span>, where <span class="monospace">x</span> is a variable. As I think was pointed out in the discussion, this example is not much different from: <span class="monospace"> (let ((cell (cons 3 4))) (eqv? cell cell)) </span> so the results should be consistent. Also, this doesn't seem like a good reason to give up having <span class="monospace">eqv?</span> be an approximation of <span class="monospace">eq?</span>.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Absolutely not. This would mean that even <span class="monospace">eq?</span> wouldn't work after such an optimization.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>Allowing <span class="monospace">#f</span> here allows for optimizations that does not result in the need for an additional pass or more to manage this notion of equivalence. Instead, after the optimization, if things still work out to be <span class="monospace">#t</span>, then that is fine, but otherwise, there is no reason to expect that they should.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>The problematic R5RS paragraph is the following (end of section 4.1.4): Each procedure created as the result of evaluating a lambda expression is (conceptually) tagged with a storage location, in order to make <span class="monospace">eqv?' and </span>eq?' work on procedures (see section *note Equivalence predicates::). I have the tendency to think that (eqv? p p) should always return #t whatever p may be, at least when this is so syntactically manifest. However the point here is more about forcing all procedures to have location or not (i.e. deciding &quot;Does lambda is an allocator or not ?&quot;). Inlined functions or unrolled loops are examples of such &quot;beasts&quot;. As such optimizations are really worth to have, especially in our functional programming world, I recommend: - either not using (hen<a href="/wiki/WG1BallotMedernach">...</a></dd>
        <dt><span class="monospace">Radul</span></dt>
        <dd>I have argued against this on the list in the past, as being the beginning of a slippery slope that has no end. It occurs to me now that procedures-with-locations are definable from procedures-without-locations if the implementation supports apply-hooks and gensyms (the latter of which I expect that most implementations will have to, in one or another form, if nothing else because cons is generative). This means that a complete, performance-conscious implementation should offer both tagged procedures and untagged procedures, and the question becomes which one should you get when you type &quot;lambda&quot; into the initial environment. I vote for retaining the invariant that for any variable x, (eqv? x x) is true unless one is using an implementation extension (like s<a href="/wiki/WG1BallotRadul">...</a></dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I think this is too surprising and contrary to the spirit of <span class="monospace">eqv?</span>. Compilers can always detect the use of <span class="monospace">eqv?</span> on a procedure value and skip this optimization.</dd></dl>
      <h3 id="#393Definingrecordequality"><a href="/ticket/393">#393</a> Defining record equality</h3>
      <p>Currently, R7RS-small says that when <span class="monospace">equal?</span> is applied to records
that are not <span class="monospace">eqv?</span> (that were constructed by different calls to the
record constructor), the result may be <span class="monospace">#t</span> or <span class="monospace">#f</span> at the
implementation's discretion.  The proposal is to treat records of the same
type like pairs, strings, vectors, and bytevectors: that is, their
contents are recursively compared.</p>
      <p>Vote <span class="monospace">recursive</span> to require recursive comparison of the record's
fields, <span class="monospace">identity</span> to return <span class="monospace">#t</span> iff <span class="monospace">eqv?</span> does, and <span class="monospace">unspecified</span>
to leave this open.</p>
      <p>Note <span class="monospace">equal?</span> is already required to handle cycles regardless.</p>
      <ul>
        <li><b>Options:</b> recursive, identity, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: recursive</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: recursive</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: recursive, unspecified</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: identity, unspecified, undecided, recursive</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: recursive</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: recursive, identity, unspecified</li></ul></li>
        <li><b>Results:</b> <b>unspecified</b>, recursive, identity, undecided</li>
        <li><b>Ratios:</b> 5:5, 5:2, 7:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Existing systems shouldn't have to change their <span class="monospace">equal?</span> to conform to R7RS. What's more, record equality is <span class="monospace">eqv?</span> on some systems by default and not on others.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>This is what <span class="monospace">equal?</span> does.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>This is merely making <span class="monospace">equal?</span> on records consistent with <span class="monospace">equal?</span> on other data types.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>While I would like to make this recursive, we cannot do so without prejudicing the core against implementations that favor opaque records in some sense. If we had a means of expressing opacity, then this would not be a problem, but since we cannot reasonably talk about opacity, we should leave the effects of opacity in the record system unspecified.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>I believe that one may have 2 records containing identical fields and despite that being semantically distincts. (records have &quot;bag&quot; behaviour instead of set behaviour).</dd>
        <dt><span class="monospace">Radul</span></dt>
        <dd>I don't think WG1 is in a position to solve this problem. If equal? is recursive, it becomes impossible to use records for information hiding or security. If equal? is identity, the common (at least in my code, and in what I understand to be good style) case (of records just being transparent immutable named tuples) breaks. In either case, the essential problem is that if you want the non-default behavior for a particular record type, there is no way to effectively modify equal?, without rewriting it and rewriting every procedure that uses equal? internally (member comes to mind; even if there are no others in the standard, there will be others in libraries). So the &quot;right answer&quot; to this involves some kind of extensible or generic operation system, which we<a href="/wiki/WG1BallotRadul">...</a></dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>Compatible with our expectations of <span class="monospace">equal?</span></dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I think recursive is the Right Thing, but appreciate this is very controversial and moreover that it may be difficult for implementations to support.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I see a desire for both &quot;open&quot; records that are vectors with named slots, and &quot;closed&quot; records that are opaque separations of implementation from interface. I definitely want WG2 Scheme to provide both these options as part of an extended record system, along the related issues of read/write on record objects and record introspection. So, what we're really deciding here is both what limited WG1-only schemes will provide, and what the default will be. On the latter basis, I think that open records are the sensible default as secure sandboxing is a rather specialise case, and I'm undecided on the former basis. So I go for open records on the latter basis alone :-) However, to make it clear, I want the wording such that this is the defined behaviour for records<a href="/wiki/WG1BallotSnellPym">...</a></dd></dl>
      <h3 id="#306Whatdoes&quot;fullUnicode&quot;supportmeaninAppendixB?"><a href="/ticket/306">#306</a> What does &quot;full Unicode&quot; support mean in Appendix B?</h3>
      <p>Specifically, does it indicate case-folding and normalization support
for the repertoire of any particular version of Unicode, or any
version greater than 5 or 6 or 6.1, or no particular version?</p>
      <p>Full unicode refers to the set of characters available.  Case-folding
and character predicates are required to work according to the Unicode
standard for all supported characters.  The question of which version
of Unicode the property refers to is important.  We could require a
specific version (and all further revisions), or always require the
latest official Unicode standard, in which case an implementation
would not be compliant until it was updated with each new standard.  Alternatively, we could parameterize the feature identifier, so that implementations might claim to support (full-unicode 6), (full-unicode 6.1), etc.</p>
      <ul>
        <li><b>Options:</b> at-least-6, at-least-6.1, latest, parameterize, undecided, unspecified</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: at-least-6</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: parameterize, latest, at-least-6.1, at-least-6</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: at-least-6, at-least-6.1, unspecified</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: undecided, at-least-6, at-least-6.1, latest</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: at-least-6, latest</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: at-least-6, at-least-6.1</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: unspecified, (latest   at-least-6   at-least-6.1)</li></ul></li>
        <li><b>Results:</b> <b>at-least-6</b>, at-least-6.1, unspecified, latest, parameterize, undecided</li>
        <li><b>Ratios:</b> 5:1, 6:3, 5:1, 6:1, 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Requiring the latest major version is reasonable, since R7RS will require at least a refresher release for almost all implementations that adopt it, but there's no reason to huff and pant to keep up with the latest minor version.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd><span class="monospace">latest</span> seems easier than having to update the standard in order to get a guarantee that the next version of unicode is supported. But parameterizing the feature identifier with a version number allows for new unicode versions without either implementations becoming non-compliant or the standard becoming out-dated.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Specifying <span class="monospace">latest</span> is unrealistic. That would mean that existing Scheme implementations would fall out of compliance the moment a new Unicode standard was promulgated. Specifying a point version, e.g. 6.1, is also unrealistic, as the version of Unicode that a particular implementation is reasonably able to support depends so much on underlying facilities provided, for example, by the operating system.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>We should tie this report to the latest major version of Unicode. Later standards can consider Unicode 7, etc., and in the meantime implementations can continue to add new characters from minor releases. It's highly unlikely characters will ever be removed, but in such a case Scheme implementations will be required to support old characters, and allowed to support new ones.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I think an implementation should specify what version of Unicode it supports, but that this should be orthogonal to the Scheme language it supports.</dd></dl>
      <h3 id="#458Removetheformalsemanticsfromthereport"><a href="/ticket/458">#458</a> Remove the formal semantics from the report</h3>
      <p>There have been a bunch of complaints about the formal semantics: it's
incomplete, it cannot be mechanized with a proof assistant, it doesn't
help either users or implementers very much, and so on.  See in
particular <a href="/ticket/453">#453</a>.</p>
      <p>The semantics have been updated to include <span class="monospace">dynamic-wind</span>, however the
other arguments still hold.</p>
      <p>This proposal is to remove it from the report altogether, and to urge
the Steering Committee to create a new WG to produce one, likely in a
&quot;rolling&quot; style with increasingly comprehensive releases, on its own
schedule.  Some members of the current WG have expressed interest in
serving on such a group, and others have expressed their complete lack
of interest, so a new WG seems the best choice if this is done.</p>
      <p>Alternately, we can adapt the operational semantics from R6RS.</p>
      <ul>
        <li><b>Options:</b> remove, keep, operational, undecided</li>
        <li><b>Default:</b> keep</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: remove</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: keep</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: keep, remove</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: remove, operational, keep</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: remove, keep, operational, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: remove</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: keep, operational</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: remove, operational, keep</li></ul></li>
        <li><b>Results:</b> <b>remove</b>, keep, operational, undecided</li>
        <li><b>Ratios:</b> 5:3, 6:1, 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>The formal semantics broken as written, and even if we patched it up, it would still be less than helpful. We need to let a separate group do a better job.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I agree that the semantics deserve a focused effort and that this is best not attempted within the current WG, so I support urging the Steering Committee to form a new WG for this purpose. However, I am not comfortable with releasing a standards document based only on English descriptions. We should go with what we have and let the new WG improve and replace it, especially since the new semantics is intended to be rolled out iteratively anyway and since a justification for this was to have us not be without a formal semantics. The document can be modified to specify authors involved with that second phase.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I've never understood the fascination with formal semantics, particularly considering that they're non-normative, i.e. that the English has always taken precedence. We always get the English right, then adjust the formal semantics to match. In all my years of using the RnRS specifications for reference, I have not once referred to the formal semantics in order to understand some point of the language. Nevertheless, the formal semantics do matter a lot to many people in the community. Removing them, even temporarily, will probably cause us to lose support for the draft. I'm afraid that we're going to have to find a way -- some volunteers? -- to bring that part of the document up to date. There's no point in adopting the operational semantics from R6RS since i<a href="/wiki/WG1BallotGleckler">...</a></dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>I dislike the idea of having a non-normative semantics that will likely not be used, which must nonetheless take time from the WG to get right. I want a normative semantics done as well as can be, which requires, IMO, a separate group. However, if we do keep things around, we should use the more up to date and partially mechanized operational semantics of R6RS.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Please produce it in a separate forthcoming document, in order for experts to have enough time to do it as well as possible.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>The primary objections have been addressed - the semantics are now up-to-date - and this is a piece of Scheme history that should not just be thrown away. We can add alternate formal semantics later if we want, but let's keep this.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I think keeping a flawed semantics helps nobody.</dd></dl>
      <h3 id="#398Allowrepeatedkeysin`case`"><a href="/ticket/398">#398</a> Allow repeated keys in <span class="monospace">case</span></h3>
      <p>R5RS says it's an error for a key to appear in more than one clause of
<span class="monospace">case</span> (or twice in the same clause, but that's trivial).  R6RS allows
the same key to appear more than one clause, but insists on
left-to-right testing throughout, like <span class="monospace">cond</span>.  The R6RS editors
thought this was better for machine-generated code, though worse for
hand-written code.</p>
      <p>The proposal is a compromise: allow keys to appear in more than one clause,
but behave as if the key appeared only in the first (leftmost) clause.
This allows hash-table or other non-left-to-right implementations.</p>
      <ul>
        <li><b>Options:</b> r5rs, r6rs, leftmost, unspecified, undecided</li>
        <li><b>Default:</b> r5rs</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: leftmost, r6rs</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: r5rs</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: leftmost, r6rs</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: r6rs, leftmost</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: r5rs, leftmost</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: r5rs, leftmost, r6rs, unspecified, undecided</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: leftmost</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: r5rs, unspecified</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: r5rs, leftmost, r6rs</li></ul></li>
        <li><b>Results:</b> <b>r5rs</b>, leftmost, r6rs, unspecified, undecided</li>
        <li><b>Ratios:</b> 5:4, 5:3, 5:1, 5:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd><span class="monospace">Leftmost</span> is a reasonable compromise between R5RS and R6RS; the latter overspecifies the mechanism.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Machines can be smart enough to generate each key only once.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>The argument from machine-generated code, e.g. macros, makes perfect sense, but the <span class="monospace">leftmost</span> proposal gives implementations more freedom to achieve the same ends.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>This ticket is inaccurate. A hash-table or other non-left to right implementation is perfectly valid in R6RS' world, because you cannot tell the difference between that and a left to right evaluation if the keys are all distinct. If they are not all distinct, then the R6RS is still equivalent to the leftmost option, because the only time that the ordering matters is in duplicate keys. Thus, r6rs and leftmost are equivalent, and in fact, superior to R5RS.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>There is a risk that repeated keys are an oversight. Being silent in that case is not recommended.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I would need to see specific examples of generated code where this is useful, otherwise I fear we're just masking errors.</dd></dl>
      <h3 id="#85Blobs,bytevectors,byte-vectors,octet-vectors,orsomethingelse?"><a href="/ticket/85">#85</a> Blobs, bytevectors, byte-vectors, octet-vectors, or something else?</h3>
      <p>Following exactly in the footsteps of R6RS we voted for a <span class="monospace">blob</span> API
and then changed the name to <span class="monospace">bytevector</span>.</p>
      <p>Formal comment <a href="/ticket/435">#435</a> argues that <span class="monospace">u8vector</span> is in more common use, so
this item is being re-opened.  The default is the current draft
<span class="monospace">bytevector</span>, and for any member leaving the preferences are left
blank their votes from ballot 3 will be used.</p>
      <ul>
        <li><b>Options:</b> blob, bytevector, byte-vector, u8vector, octet-vector, undecided</li>
        <li><b>Default:</b> bytevector</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: blob, bytevector</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: bytevector, byte-vector, u8vector</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: byte-vector, bytevector, u8vector, octet-vector, blob</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: bytevector, blob, byte-vector, u8vector</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: u8vector, bytevector</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: bytevector, byte-vector</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: bytevector, blob</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: bytevector, blob, u8vector</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: blob, (bytevector byte-vector), u8vector, octet-vector</li></ul></li>
        <li><b>Results:</b> <b>bytevector</b>, blob, byte-vector, u8vector, octet-vector</li>
        <li><b>Ratios:</b> 7:2, 7:1, 8:1, 9:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Neither <span class="monospace">bytevector</span> nor <span class="monospace">u8vector</span> fully captures the idea here, which is of a collection of unstructured binary information. <span class="monospace">Blob</span> does that nicely. Failing that, at least there is R6RS as precedent for using <span class="monospace">bytevector</span> in this vague way.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>bytevector is in common usage, based on a google search. <a href="http://www.gnu.org/software/kawa/api/gnu/lists/ByteVector.html">the gnu list java classes</a> consider a bytevector to have signed and unsigned subclasses. By this definition, the difference turns on whether, if we were to support constructors <span class="monospace">#s8(...)</span> and <span class="monospace">bytevector-s8-set!</span>, whether these would be considered to operate over a single type of bytevectors, or two different types. If the former, we should use <span class="monospace">bytevector</span>, if the latter <span class="monospace">u8vector</span>. I don't see much purpose for converting the same bit pattern between different interpretations, but parsimony would argue for a single type.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>While &quot;blob&quot; is a widely used term these days, I prefer a properly hyphenated, descriptive term, or at least a descriptive term. I've never liked &quot;blob,&quot; even knowing that it abbreviates &quot;Binary Large OBject.&quot; Since R7RS is case sensitive, we don't need even more cases where the capitalization of an abbreviation is not matched in the names of Scheme identifiers. Furthermore, it has been ages since &quot;byte&quot; meant anything other than eight bits, so there's no need to choose &quot;u8&quot; or &quot;octet.&quot; While Marc's argument that we (and implementers of the widely adopted SRFI 4) use &quot;#u8(&quot; to prefix literal byte vectors is compelling, the idea of byte vectors is to provide the basis for a more complete system in WG2 Scheme that supports reading and writing not only unsigned<a href="/wiki/WG1BallotGleckler">...</a></dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>blob or u8vector are IMHO terrible names. byte-vector is not perfect but conveys meaning.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I don't particularly like the name, but it has precedence in R6RS. The name u8vector doesn't work well when accessing by other types, e.g. u8vector-u32-ref sounds too strange.</dd></dl>
      <h2 id="WG1-LibrarySystem">WG1 - Library System</h2>
      <h3 id="#353Nousebeforeimportinlibraries"><a href="/ticket/353">#353</a> No use before import in libraries</h3>
      <p>For ease of implementation, the proposal is to make it an error for an
imported identifier to be referenced or defined in a library before
the library declaration that imports it.  This allows strict
left-to-right processing of library declarations, with no need to
delay processing till the end of the library.</p>
      <p>Therefore, this would be an error (but still permitted as an extension
in Schemes that can easily provide it):</p><span class="monospace">(module
  (begin (define x y))
  (import (library defining y))
</span>
      <p>This would necessitate replacing the penultimate paragraph of section</p>
      <ol class="number" start="5">
        <li>5.1 with:</li></ol>
      <p>One possible implementation of libraries is as follows: After all
<span class="monospace">cond-expand</span> library declarations are expanded, a new environment is
constructed for the library consisting of all imported bindings. The
expressions and declarations from all <span class="monospace">begin</span>, <span class="monospace">include</span>, and
<span class="monospace">include-ci</span> declarations are expanded in that environment in the
order in which they occur in the library declaration.  Alternatively,
<span class="monospace">cond-expand</span> and <span class="monospace">import</span> declarations may be processed in left to
right order interspersed with the processing of expressions and
declarations, with the environment growing as imported bindings are
added to it by each <span class="monospace">import</span> declaration.</p>
      <p>Vote <span class="monospace">yes</span> to add the restriction, or <span class="monospace">no</span> to leave it out.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: undecided</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, undecided, no</li>
        <li><b>Ratios:</b> 6:2, 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>This is how Chicken works, and I think left-to-right processing is a Good Thing whenever possible. Note that this has nothing to do with the fact that the library form is read all at once, and everything to do with how it is processed.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>The restriction doesn't seem to do any harm. One could always define multiple libraries with just the desired dependencies.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I'm not sure why we even allow <span class="monospace">begin</span>, <span class="monospace">include</span>, or <span class="monospace">include-ci</span> before any <span class="monospace">import</span> or <span class="monospace">export</span> form. The proposed restriction is not limiting, and simplifies not only implementing the library system, but also reading code that uses it.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>One can arbitrarily re-order clauses in a library, and one should at least read the entire library in to check for valid syntax before one begins processing. All that is required is to re-order the clauses into a correct ordering before processing to enable left-to-right processing. This is trivial and not difficult for any implementation. This restriction is unhelpful verbage with no real use.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I'm worried about interaction with include-library-declarations from <a href="/ticket/448">#448</a> where it can be useful to change the order. This may also conflict with requirements such as <a href="/ticket/441">#441</a>.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Use before import doesn't make for readable code, and makes for trickier implementation; nobody benefits!</dd></dl>
      <h3 id="#359Limitnumbersusedinlibrarynames"><a href="/ticket/359">#359</a> Limit numbers used in library names</h3>
      <p>This is a proposal to limit numbers in library names to the range 0 to</p>
      <ol class="number" start="32767">
        <li>Currently, there is no portable lower bound which all Schemes</li></ol>
      <p>can assume as the maximum size of an integer.</p>
      <p>Numbers are mostly used for SRFI-based libraries anyway, which are not
likely to reach either limit.</p>
      <p>The option <span class="monospace">uint15</span> for the proposal as stated (0 to 32767), <span class="monospace">int16</span>
for -32768 to 32767, int24 for -2<sup>23</sup> to 2<sup>23</sup>-1, etc.</p>
      <p>Vote <span class="monospace">unspecified</span> to make no explicit requirement on the integers
allowed in library names.</p>
      <ul>
        <li><b>Options:</b> uint15, int16, uint16, int24, uint24, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: uint15, int16, uint16, int24, uint24</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: int16, uint16, unspecified, int24, uint24</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: uint15, unspecified</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: uint15, uint16, unspecified</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: int16</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: uint15, (int16 uint16), (int24 uint24)</li></ul></li>
        <li><b>Results:</b> <b>unspecified</b>, uint15, int16, uint16, int24, uint24</li>
        <li><b>Ratios:</b> 5:4, 6:4, 5:4, 7:2, 7:2</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>I may change this later when/if Alex explains why negative numbers are useful in library names. We haven't had them up to now.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I can't imagine wanting such a large number in a library name, but maybe I'm not very imaginative.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Rationale (from my earlier ballot on <a href="/ticket/349">#349</a>): Twenty-four is too many bits to require for tiny implementations. I'm nervous about burdening the smallest implementations with even a sixteen-bit requirement, but such implementations typically already leave out significant language features, so I'm willing to ask for 16 bits.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>I just don't feel comfortable making a sudden distinction in fixnums versus bignums in the language.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>We should definitely allow negative numbers (for the old R^-1RS and (srfi -1) jokes), and 16 bits seems enough for all common uses.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I suppose it makes sense to have some contract between implementers and numeric-library authors.</dd></dl>
      <h3 id="#441Makesureaprogram/libraryloadsanyimportedlibrariesatmostonce"><a href="/ticket/441">#441</a> Make sure a program/library loads any imported libraries at most once</h3>
      <p>Add the following text to the discussion of library loading:</p>
      <p>Regardless of the number of times that a library is loaded, each
 program or library that imports bindings from a library will receive
 bindings from a single loading of that library, regardless of the
 number of <span class="monospace">import</span> or <span class="monospace">cond-expand</span> declarations in which it appears.</p>
      <p>to make it clear that, for example,</p><span class="monospace">(import (prefix (foo) 'foo:))
(import (only (foo) bar))
</span>
      <p>will cause <span class="monospace">bar</span> and <span class="monospace">foo:bar</span> to come from the same instantiation of
the library '(foo)'</p>
      <p>Vote <span class="monospace">yes</span> to add this requirement.</p>
      <ul>
        <li><b>Options:</b> yes, no, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes, unspecified</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: yes, undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: yes, unspecified</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: undecided, yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes, unspecified, no</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, unspecified, undecided, no</li>
        <li><b>Ratios:</b> 8:1, 7:2, 8:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>This is not a case R6RS deals with, but I think it's sensible to require all imports from the foo library into the bar library to come from the same instantiation.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Yes, we don't want people to interpret <span class="monospace">import</span> as a statement causing an import to happen rather than a declaration that one should. However, the wording still isn't clear, and in fact seems to suggest the opposite of its intent. I recommend this instead: Regardless of the number of times that a library is loaded, all the bindings it exports to any loading program or library will come from a single loading of that library, regardless of the number of <span class="monospace">import</span> or <span class="monospace">cond-expand</span> declarations in which it appears.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>This is reasonable based on the assumption that it does not preclude loading the library zero or more times, given phases or optimizations.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>By the rule of least surprise.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>I want to see some best practices develop before setting anything in stone here.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Although libraries that mutate their private internal state are a risky programming paradigm, it is occasionally useful for situations where we must manage process-wide resources such as signals. Ensuring that any given libary is instantiated (and initialised) only once is, therefore, useful.</dd></dl>
      <h3 id="#402Addanexport-allform."><a href="/ticket/402">#402</a> Add an export-all form.</h3>
      <p>Add an export-all form to the library declaration that means &quot;export
all identifiers that are defined in the library with begin, include,
and include-ci but none that are imported with import.&quot;</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: undecided, no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: no</li></ul></li>
        <li><b>Results:</b> <b>no</b>, yes, undecided</li>
        <li><b>Ratios:</b> 5:4, 4:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>I think this is very useful for reducing bureaucracy in small libraries. Chicken has it.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Some may choose other ways of hiding definitions, and this can save both keystrokes and maintenance effort.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>This will be a common usage pattern. It's much better than the alternative suggestion, which was to make all identifiers be exported if none are. That violates the principle of least astonishment. I don't understand Alex's argument that this will be hard to implement. If something like that is hard, we're doing something wrong.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>Is this even how normal <span class="monospace">export-all</span> functons work? I would normally expect it to export all of its imported bindings too.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Not in the standard does not disallow some implementation to have it, but allow others not to provide it if they think this is an overkill.</dd>
        <dt><span class="monospace">Radul</span></dt>
        <dd>This is definitely going to be the common case.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I'm concerned we may make the library system too complicated to easily implement. It's also unclear whether <span class="monospace">export-all</span> should export imported identifiers or not, and contrary to what John Cowan says Chicken does not provide this functionality.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I think it's good discipline to explicitly export stuff. It prevents accidental pollution of namespaces.</dd></dl>
      <h3 id="#448Addlibrarydeclarationinclude-library-declarations"><a href="/ticket/448">#448</a> Add library declaration include-library-declarations</h3>
      <p>The proposed <span class="monospace">include-library-declarations</span> allows a library to
incorporate a file containing arbitrary library declarations, not just
Scheme code (definitions and expressions).  This allows, for example,
the exports of a module to be written directly in the library file,
and its imports in a separate file.</p>
      <p>An alternative would be something like <span class="monospace">(export-from &lt;library&gt;)</span> to
export the same bindings as another library.  This does require the
clumsiness of actually defining the identifiers in the other library
if it is abstract.</p>
      <ul>
        <li><b>Options:</b> include-library-declarations, export-from, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: include-library-declarations</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: export-from</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: undecided, no, include-library-declarations</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: include-library-declarations, no, undecided, export-from</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: include-library-declarations, no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: include-library-declarations, no, export-from</li></ul></li>
        <li><b>Results:</b> ''include-library-declarations'', no, undecided, export-from</li>
        <li><b>Ratios:</b> 4:2, 4:3, 5:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Though this name is verbose even by Scheme standards, what it provides is very helpful. In simple implementations, it can be the same as include.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>This is a useful feature, and <span class="monospace">export-from</span> seems like the cleaner way to achieve it.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I don't understand why writing the imports in a separate file is a good idea. I view the imports and exports as part of a &quot;wiring diagram&quot; showing how parts of the system are connected, not a way of declaring an abstract interface. In any case, this is invention, not something that exists in Scheme implementations already, so it doesn't belong in the standard.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>There is something that I just don't like about this, and it feels untested and unprecedented. I would prefer to see it implemented and encouraged by implementations. Otherwise, we may find that implementations prefer to use something else for this purpose.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Having a simple way to separate interfaces from implementation is nice.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This is trivial to implement and is a good poor-man's interface implementation.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>export-from is, IMHO, an ugly hack...</dd></dl>
      <h3 id="#449Clarifylibraryloadingrules"><a href="/ticket/449">#449</a> Clarify library loading rules</h3>
      <p>R7RS currently says:</p>
      <p>Within a program, each imported library is loaded at least once, and,
 if imported by more than one program or library, may possibly be
 loaded additional times.</p>
      <p>Richard Kelsey thinks this is too liberal, and proposes:</p>
      <p>Regardless of the number of times that a library is loaded, each
 program or library that imports bindings from a library will receive
 bindings from a single loading of that library, regardless of the
 number of <span class="monospace">import</span> or <span class="monospace">cond-expand</span> forms in which it appears.</p>
      <p>Aaron Hsu, however, thinks this is too restrictive, and proposes
(backed up by actual R6RS implementations):</p>
      <p>If a library's definitions are referenced in the expanded form of a
 program or library body, then that library must be loaded before the
 expanded program or library body is evaluated. This rule applies
 transitively.</p>
      <p>Similarly, during the expansion of a library, if a syntax keyword
 imported from a library is needed to expand the library, then the
 imported library must be visited before the expansion of the
 importing library.</p>
      <ul>
        <li><b>Proposals:</b>
          <ul>
            <li><b>one:</b> Kelsey's proposal</li>
            <li><b>one-or-more:</b> current draft</li>
            <li><b>zero-or-more:</b> Hsu's proposal, R6RS status-quo</li>
            <li><b>zero-or-one:</b> Kelsey's proposal with Hsu's relaxation</li></ul></li>
        <li><b>Options:</b> one, one-or-more, zero-or-one, zero-or-more</li>
        <li><b>Default:</b> one-or-more</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: zero-or-more</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: one, undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: one, zero-or-one, one-or-more, zero-or-more</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: zero-or-one, zero-or-more</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>:  i have no opinion</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: undecided</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: one</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: zero-or-more</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: zero-or-more, one-or-more</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: one, zero-or-one, (one-or-more zero-or-more)</li></ul></li>
        <li><b>Results:</b> ''zero-or-more'', one, zero-or-one, one-or-more, undecided, i, have, no, opinion</li>
        <li><b>Ratios:</b> 4:4, 3:3, 4:1, 6:2, 6:1, 6:1, 6:1, 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>I think we should defer to R6RS-based experience here. Those who don't care much can probably live with any of these options, but those who care seem to be passionate about it.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>My module proposal had allowed for the same module to be loaded multiple times, consuming and producing different bindings each time, and I think was very well-motivated. I'm a bit confused on what additional expressiveness is being offered here. Based on my current understanding, the &quot;exactly one&quot; rule best meets the intuitions of the current module system. I don't see much benefit to avoiding loading libraries whose bindings are not referenced, and significant &quot;surprise&quot; potential in not doing so.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Our library system is designed to have simple semantics, and divergence from once-and-only-once makes it harder to reason about. If we are going to do something else, let's still make sure that modules aren't loaded more than once.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>So far I cannot find a reason to have more than a single load for any given expansion phase, and therefore the zero-or-one seems reasonable, but I still insist that zero must be a valid load count if the library is unused.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>It is useful for libraries that are not actually referred to to not be loaded, and we will leave it to implementations to decide how many loadings are necessary.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Allowing one or many instantiations is a philosophical choice that I think implementations are unlikely to compromise on. In deference to existing R6RS implementations I think zero instantiations is reasonable, assuming the implementation can prove it's safe. This gives better support among implementations, and the work-around to being unable to import for side effects is simply to import and call a function at run time.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Same argument as <a href="/ticket/441">#441</a> above.</dd></dl>
      <h2 id="WG1-Numerics">WG1 - Numerics</h2>
      <h3 id="#366Add(logzb)forlogarithmofztothebaseb"><a href="/ticket/366">#366</a> Add (log z b) for logarithm of z to the base b</h3>
      <p>Coverage for this R6RS feature is currently sparse: only Gauche, Chez,
Vicare, Larceny, Ypsilon, Mosh, IronScheme, KSi, RScheme, Rep support
it.  But it is convenient when working in bases other than <i>e</i> such
as 10, 2, or 16, and it is just a few extra lines of code, since `(log
z b)<span class="monospace"> =&gt; </span>(/ (log z) (log b))` for arbitrary complex numbers <i>z, b</i>.</p>
      <p>Vote <span class="monospace">yes</span> to add the optional second argument from R6RS.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes, no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no, undecided, yes</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: undecided, yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no, undecided</li>
        <li><b>Ratios:</b> 8:1, 7:2</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>This is easy for both users and implementers, but implementers should do it once so users don't have to do it more than once (as well as remembering the order of terms in the division!)</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>This is simple, widely useful, and conforms to R6RS.</dd>
        <dt><span class="monospace">Lucier</span></dt>
        <dd>I voted both yes and no because I think it's a good function to have, but (log z b) =&gt; (/ (log z) (log b)) is not as complete an implementation as I would like, e.g, I'd prefer (log (expt 2 29) 2) =&gt; 29 exactly, and not 29.000000000000004, which the second formula gives on Gambit.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>In engineering, log-base-10 is way more common than log-base-e. You're not doing developers of engineering applications any favors by not providing easy access to the logarithm they're most familiar with.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I've often wanted this when coding.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>For some reason, I'm uncharacteristically soppy about allowing extensions to the numeric procedures...</dd></dl>
      <h3 id="#367Inexactdivisionbyexactzero"><a href="/ticket/367">#367</a> Inexact division by exact zero</h3>
      <p>Draft 6 says that it's an error for an argument of <span class="monospace">/</span> (other than the
first) to be an exact zero.  R6RS, however, says that it's an error
only if <i>all</i> the arguments are exact.  In other words, <span class="monospace">(/ 2.0 0)</span>
is an error according to the draft, but in R6RS it returns <span class="monospace">+inf.0</span>
(assuming the implementation supports it).  The proposal is to adopt
the R6RS wording.</p>
      <p>Cowan tested <span class="monospace">(/ 2.0 0)</span> in the usual set of Schemes:</p>
      <ul>
        <li>Racket, Gambit, Chicken (with the numbers egg), Guile, Chibi, Elk, Spark report an error.</li>
        <li>Gauche, Bigloo, Scheme48/scsh, Kawa, SISC, Chez, SCM, Ikarus/Vicare, Larceny, Ypsilon, Mosh, IronScheme, NexJ, STklos, RScheme, BDC, UMB, VX return <span class="monospace">+inf.0</span>.</li>
        <li>MIT, scsh, Shoe, TinyScheme, Scheme 7, XLisp, Rep, Schemik, Inlab always report an error when dividing by zero, exact or inexact.</li>
        <li>KSi, Scheme 9 produce incorrect results.</li>
        <li>SigScheme, Dream, Oaklisp, Owl Lisp don't support inexact numbers.</li></ul>
      <p>Vote <span class="monospace">error</span> for the current draft semantics that it is an error,
<span class="monospace">all-error</span> for the R6RS semantics that it is only an error if all
arguments are exact, or <span class="monospace">unspecified</span> to make this case unspecified.</p>
      <ul>
        <li><b>Options:</b> error, all-error, unspecified, undecided</li>
        <li><b>Default:</b> error</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: error</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: all-error</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: error, all-error</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: all-error, unspecified, error</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: error</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: error, unspecified, all-error, undecided</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: error, unspecified</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: all-error</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: error</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: error, unspecified, all-error</li></ul></li>
        <li><b>Results:</b> <b>error</b>, all-error, unspecified, undecided</li>
        <li><b>Ratios:</b> 7:3, 7:1, 8:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>The zero is exact and that is what causes the error -- the other arguments are not relevant.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Systems that support <span class="monospace">+inf.0</span> and <span class="monospace">-inf.0</span> as constants and have procedures to test for them should produce them when appropriate.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Division by zero is still typically a mistake, and catching it as early as possible is a good idea. Until we specify how an implementation goes into IEEE non-signalling mode, we should continue signalling such errors.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>The zero is exact and that is what causes the error - the other arguments are not relevant.</dd></dl>
      <h3 id="#369Requirethat-and/allowanarbitrarynumberofarguments"><a href="/ticket/369">#369</a> Require that - and / allow an arbitrary number of arguments</h3>
      <p>R5RS requires that <span class="monospace">-</span> and <span class="monospace">/</span> accept one or two arguments, and labels
support for more than two as &quot;optional&quot;.  R6RS requires such support.
The proposal is to require it.</p>
      <p>All Schemes in the test suite support more than two arguments except
Scheme48/scsh.  (Owl Lisp does not support variadic procedures of any
kind.)</p>
      <p>Vote <span class="monospace">require</span> for required n-ary behavior and <span class="monospace">optional</span> to leave it
optional as in R5RS.  Alternately, vote <span class="monospace">forbidden</span> to make this
always an error in all implementations.</p>
      <ul>
        <li><b>Options:</b> required, optional, forbidden, undecided</li>
        <li><b>Default:</b> optional</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: required, optional</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: required</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: required, optional</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: required, optional</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: required</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: required, optional, undecided, forbidden</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: required</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: optional</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: required</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: required, optional, forbidden</li></ul></li>
        <li><b>Results:</b> <b>required</b>, optional, undecided, forbidden</li>
        <li><b>Ratios:</b> 9:1, 9:0, 9:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>It's silly for <span class="monospace">(- 1 2 3)</span> not to Just Work in all Schemes. Still, <span class="monospace">forbidden</span> would be terrible.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I don't think these are particularly useful, but will go with it for the sake of improving portability.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>It's not hard to make this just work, and almost all Schemes already support it.</dd>
        <dt><span class="monospace">Radul</span></dt>
        <dd>Since everybody does it anyway, might as well allow code to depend on it. Not that (/ 1 2 3 4) is very intuitive.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This is a de-facto standard, and I dislike &quot;fixing&quot; my code so that it works for Scheme48.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>It's useful, and it does not harm, and it's widely implemented. What's not to love?</dd></dl>
      <h3 id="#370Logofexactandinexactzero"><a href="/ticket/370">#370</a> Log of exact and inexact zero</h3>
      <p>R5RS and draft 6 of R7RS don't say what <span class="monospace">(log 0.0)</span> and <span class="monospace">(log 0)</span>
return.  R6RS requires <span class="monospace">-inf.0</span> and an exception respectively.  The
proposal is to say that <span class="monospace">(log 0.0)</span> returns <span class="monospace">-inf.0</span> on systems that
have <span class="monospace">-inf.0</span>, and that <span class="monospace">(log 0)</span> is an error.</p>
      <p>In Racket, Gambit, Chicken (with the numbers egg), Guile, Chibi, Chez,
Ikarus/Vicare, Larceny, Ypsilon, Mosh, IronScheme, STklos, Spark,
<span class="monospace">(log 0.0)</span> returns <span class="monospace">-inf.0</span> and <span class="monospace">(log 0)</span> raises an exception.</p>
      <p>Gauche, MIT, Chicken (without the numbers egg), Bigloo, Scheme48/scsh,
Kawa, SISC, SCM, NexJ, KSi, RScheme, XLisp, Rep, VX, SXM, Inlab return
<span class="monospace">-inf.0</span> in both cases.</p>
      <p>Elk, UMB, Oaklisp raise an exception in both cases.</p>
      <p>Scheme 7 returns the wrong answer in both cases.</p>
      <p>SigScheme, Shoe, TinyScheme, Dream, BDC, Owl Lisp don't support <span class="monospace">log</span>.</p>
      <p>Scheme 9 apparently goes into an infinite loop in both cases.</p>
      <p>Vote <span class="monospace">r6rs</span> for the R6RS behavior of returning <span class="monospace">-inf.0</span> and raising an
error, respectively.  Vote <span class="monospace">infinity</span> to always return <span class="monospace">-inf.0</span>.</p>
      <ul>
        <li><b>Options:</b> r6rs, infinity, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: r6rs</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: r6rs</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: r6rs, unspecified</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: r6rs</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: r6rs</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: r6rs, infinity, unspecified, undecided</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: r6rs</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: r6rs</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: r6rs, unspecified, infinity</li></ul></li>
        <li><b>Results:</b> <b>r6rs</b>, unspecified, infinity, undecided</li>
        <li><b>Ratios:</b> 9:0, 9:0, 9:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>R6RS got it right here: the limit of log <i>x</i> as <i>x</i> -&gt; 0 is negative infinity, which however is not representable within the exact number system.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Let's catch errors early.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>The R6RS option here does not prevent us from returning <span class="monospace">-inf.0</span> because our error state is not that strong.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>As in <a href="/ticket/367">#367</a>, an exact zero for an undefined operation should be an error. An inexact zero should return what the floating point processor returns.</dd></dl>
      <h3 id="#407Dividingexact0byaninexactnumber"><a href="/ticket/407">#407</a> Dividing exact 0 by an inexact number</h3>
      <p>This proposal allows <span class="monospace">(/ 0 </span><i>x</i><span class="monospace">)</span>, where <i>x</i> is an inexact
number, to return an exact value.  Currently only Racket, Gambit,
TinyScheme, Sizzle, Spark do this; see <a href="/wiki/Zero">Zero</a> for details.</p>
      <p>Vote <span class="monospace">zero</span> to allow (but not require) this to return exact 0.  Vote
<span class="monospace">no-nan</span> to allow it to return 0 except when <span class="monospace">x</span> is <span class="monospace">+nan.0</span>, where it
would return <span class="monospace">+nan.0</span>.</p>
      <ul>
        <li><b>Options:</b> zero, no-nan, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: zero, no-nan</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: no-nan</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no-nan, zero, unspecified</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: undecided, no-nan</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: zero</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no-nan, zero, unspecified, undecided</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: zero</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: no-nan</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no-nan, unspecified</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: no-nan, zero, unspecified</li></ul></li>
        <li><b>Results:</b> <b>no-nan</b>, zero, unspecified, undecided</li>
        <li><b>Ratios:</b> 7:3, 8:0, 7:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Returning an exact value is good, but propagating NaN is good too. As I've posted, I don't think the NaN exception to the exception is worth fussing about, since it's all optional.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I'd be happy to require exact zero in other cases (and for multiplication by exact 0).</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd><a href="/wiki/Zero">Zero</a> divided by anything is zero. We know the answer exactly given only an exact numerator, so we should return an exact answer. However, as John points out, a NaN may indicate an earlier error, and we shouldn't require masking that.</dd>
        <dt><span class="monospace">Radul</span></dt>
        <dd>While this does have the downside of potentially masking a NaN, it only masks one in a computation whose result wasn't going to be used anyway. If the programmer really did not want their NaNs masked, they could have ensured the zero were inexact. In the meantime, this allows an optimization, which can be very important in numeric code because it can chain.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>The proposal as-is explicitly breaks the rules for <span class="monospace">+nan.0</span>.</dd></dl>
      <h3 id="#410Infinityvs.NaNinmaxandmin"><a href="/ticket/410">#410</a> <a href="/wiki/Infinity">Infinity</a> vs. NaN in max and min</h3>
      <p>Currently R7RS says nothing about the value of <span class="monospace">(max +inf.0 +nan.0)</span>
or <span class="monospace">(min -inf.0 +nan.0)</span>.  R6RS required these functions to return the
infinite value, but this was adopted by some but not all R6RS
implementations (see <a href="/wiki/MaxInfNan">MaxInfNan</a> for details).  R5RS implementations are
also divided.</p>
      <p>The proposal is to allow R7RS implementations to provide either value.</p>
      <p>Vote <span class="monospace">both</span> to explicitly add a note that either are allowed,
<span class="monospace">infinity</span> to require the infinite value as in R6RS, <span class="monospace">nan</span> to require
returning <span class="monospace">+nan.0</span>, and <span class="monospace">unspecified</span> leave unspecified (i.e. the same
as <span class="monospace">both</span> but without the note).</p>
      <ul>
        <li><b>Options:</b> both, infinity, nan, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: both, unspecified</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: nan, unspecified</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: both, unspecified, nan, infinity</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: nan, unspecified, both</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: infinity, unspecified</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: both, unspecified, nan, infinity, undecided</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: both, unspecified, nan</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: infinity, both, unspecified, nan</li></ul></li>
        <li><b>Results:</b> both, ''unspecified'', nan, infinity, undecided</li>
        <li><b>Ratios:</b> 5:5, 5:2, 5:2, 6:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>If we are going to allow both (as I think we should and must, the arguments on both sides being equally satisfactory), we should say so.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I'm changing this for the same reason I changed my answer to <a href="/ticket/407">#407</a>, i.e. because a NAN may indicate an earlier error and we shouldn't lose the information that there was an error.</dd>
        <dt><span class="monospace">Lucier</span></dt>
        <dd>I consider Gambit's behavior a bug that I intend to fix (if I remember to do so). It is true that one of the original motivations for introducing NaN objects was to track the location of where anomalies/errors occured. But if an anomaly would not affect the final answer (in other words, if the final answer would be the same no matter the value substituted for the NaN), then that final answer should be returned.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>max and min are undefined over non-numbers (including NaNs).</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Implementations are divided and this is a confusing case so it should be documented. Given one or the other I'd say NaN trumps infinity.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>If there's no number that can be larger than +inf.0, then NaN can't make the maximum any more maximal, so infinity is the logical answer for (max +inf.0 +nan.0).</dd></dl>
      <h3 id="#395InfiniteandNaNcomplexnumbers"><a href="/ticket/395">#395</a> Infinite and NaN complex numbers</h3>
      <p>Currently both <span class="monospace">infinite?</span> and <span class="monospace">nan?</span> return <span class="monospace">#t</span> to a complex number
like <span class="monospace">+inf.0+nan.0i</span>.  Is this the Right Thing, or should <span class="monospace">infinite?</span>
only return <span class="monospace">#t</span> if neither part is a NaN?</p>
      <p>Note it is reasonable for an implementation to not support partial nan
complex numbers.</p>
      <p>Vote <span class="monospace">disjoint</span> to ensure that <span class="monospace">infinite?</span> and <span class="monospace">nan?</span> are disjoint
predicates as in the proposal, or <span class="monospace">overlap</span> to allow the current
behavior.</p>
      <ul>
        <li><b>Options:</b> overlap, disjoint, unspecified, undecided</li>
        <li><b>Default:</b> overlap</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: overlap</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: disjoint, unspecified</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: overlap, disjoint</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: overlap, unspecified</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: overlap, unspecified, disjoint, undecided</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: disjoint</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: disjoint, overlap</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: disjoint</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: overlap, unspecified, disjoint</li></ul></li>
        <li><b>Results:</b> <b>overlap</b>, disjoint, unspecified, undecided</li>
        <li><b>Ratios:</b> 5:4, 6:1, 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>I don't really care about the R6RS notion that <span class="monospace">finite?</span>, <span class="monospace">infinite?</span>, and <span class="monospace">nan?</span> form a partition (and in R6RS they don't work on complex numbers anyway). Testing against the Scheme suite didn't show much, because most Schemes either don't have complex numbers at all, don't have <span class="monospace">infinite?</span> and/or <span class="monospace">nan?</span>, or don't allow complex numbers as arguments to them. However, Gauche, Chicken with the numbers egg, Vicare, IronScheme agree that <span class="monospace">+inf.0+nan.0i</span> is both infinite and NaN. Spark says it is neither, SXM doesn't allow NaN in a complex value.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I'm not sure how useful it is to ask whether a complex number is infinite, but the only reasonable interpretation I can see is that if either part is infinite, the complex number is. If we don't agree on that, I can't see any value in leaving this unspecified, so let's make them disjoint.</dd>
        <dt><span class="monospace">Lucier</span></dt>
        <dd>I think <span class="monospace">infinite?' and </span>nan?' should take only real arguments.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>NaN-ness should be contagious: if any component of a numeric value is NaN, then the whole thing is &quot;not a number&quot;. Accordingly complex numbers with one part NaN should be either forbidden, or <span class="monospace">nan?</span> returns <span class="monospace">#t</span> on them but not any predicates that apply to is-a-number numeric values.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I don't think a number can be +nan.0 as well as something else.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>+inf.0+nan.0i is definitely infinite, and definitely not entirely specified, so infinite? and nan? are both valid.</dd></dl>
      <h3 id="#364truncate,floor,ceilingroundshouldreturnanon-finiteargument"><a href="/ticket/364">#364</a> truncate, floor, ceiling round should return a non-finite argument</h3>
      <p>Currently R7RS is silent on what truncate, floor, ceiling, and round
do when the argument is <span class="monospace">+inf.0</span>, <span class="monospace">-inf.0</span>, or <span class="monospace">+nan.0</span>. R6RS has them
return the argument, which seems reasonable.</p>
      <p>Tests were made for <span class="monospace">(round (* 1.0e200 1.0e200))</span> on a variety of
implementations.</p>
      <p>Racket, Gauche, Chicken (with and without the numbers egg), Bigloo,
Guile, Kawa, Chibi, Chez, SCM, Ikarus/Vicare?, Larceny, Ypsilon, Mosh,
IronScheme, NexJ, STklos, KSi, Shoe, BDC, Rep, Schemik, Elk, Spark
all return the argument.</p>
      <p>MIT, Gambit, Scheme48/scsh, SISC, Scheme 9, Scheme 7, signal errors.</p>
      <p>SigScheme, TinyScheme, Dream, UMB don't work for one or another
reason.</p>
      <p>Oaklisp and Owl Lisp don't do flonums.</p>
      <p>XLisp only has fixnums and flonums, and returns the largest or
smallest fixnum as the case may be.</p>
      <p>RScheme returns a variety of slightly strange values: (round +inf.0),
for example, is 0, but (round -inf.0) is -inf.0.</p>
      <p>Vote <span class="monospace">input</span> to return the input, <span class="monospace">error</span> to specify &quot;it is an error&quot;,
and <span class="monospace">unspecified</span> to leave unspecified as in the current draft.</p>
      <ul>
        <li><b>Options:</b> input, error, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: unspecified, input, error</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: input, unspecified</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: error, unspecified</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: input, unspecified</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: error</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: input, unspecified, error, undecided</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: input</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: input</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: input, unspecified, error</li></ul></li>
        <li><b>Results:</b> <b>input</b>, unspecified, error, undecided</li>
        <li><b>Ratios:</b> 6:3, 7:2, 7:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Implementations differ. If we must specify, R6RS wins.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Let's catch errors early. The whole point of these procedures is to return integers, so returning something that is not an integer makes no sense. If we don't do that, we should leave the result unspecified rather than force implementations to do the wrong thing even if it is compatible with R6RS.</dd>
        <dt><span class="monospace">Lucier</span></dt>
        <dd>To my mind, the output of round, truncate, floor, and ceiling should be integers, and +inf.0 and nan.0 are not rational, so they are not integers.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I think this is an error, but understand wanting to return the argument for efficiency, simplicity, and closeness to the floating point processor. Since implementations differ we should leave this unspecified.</dd></dl>
      <h3 id="#392Exactpositiveandnon-negativeintegerpredicates"><a href="/ticket/392">#392</a> Exact positive and non-negative integer predicates</h3>
      <p>There are two useful subsets of the exact numbers, both of which are
commonly called natural numbers, depending on who's talking.
Logicians, set theorists, and computer scientists include 0, other
mathematicians mostly don't.  This proposal adds the predicates
<span class="monospace">exact-positive-integer?</span> and <span class="monospace">exact-non-negative-integer?</span>, analogous
to <span class="monospace">exact-integer?</span>.  Because of the ambiguity, the name
<span class="monospace">natural-number?</span> is not proposed.</p>
      <p>Vote <span class="monospace">yes</span> to add these two procedures.</p>
      <ul>
        <li><b>Options:</b> yes, no, wg2, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no, wg2</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: undecided, wg2, yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes, wg2</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no, wg2, undecided, yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no, wg2</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes, wg2, no</li></ul></li>
        <li><b>Results:</b> ''wg2'', yes, <b>no</b>, undecided</li>
        <li><b>Ratios:</b> 4:4, 3:3, 5:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Natural numbers are an important type, and Scheme should support it directly.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>We don't need more names in WG1.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>I am not sure I see the use of these rather than just a combination of predicates...but...well, sure, I am not opposed to them so much.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>The motivation for this is unclear, apart from using procedure names as a platform to argue about the definition of natural numbers. The procedures in question are trivial compositions of existing procedures and serve only to bloat the standard.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I'm still soft on more numeric procedures...</dd></dl>
      <h2 id="WG1-Read/Write">WG1 - Read/Write</h2>
      <h3 id="#380IssupportofTABasawhitespacecharacterrequiredornot?"><a href="/ticket/380">#380</a> Is support of TAB as a whitespace character required or not?</h3>
      <ol class="number" start="2">
        <li>2 says:</li></ol>
      <p>Whitespace characters include the space and newline characters.
(Implementations may provide additional whitespace characters such as
tab or page break.)</p>
      <p>However, 7.1.1 has:</p>
      <p>&lt;intraline whitespace&gt; -&gt; &lt;space or tab&gt;
&lt;whitespace&gt; -&gt; &lt;intraline whitespace&gt; | &lt;newline&gt; | &lt;return&gt;</p>
      <p>So 2.2 implies that supporting tabs is allowed but not required, yet</p>
      <ol class="number" start="7">
        <li>1.1 implies supporting tabs is required.</li></ol>
      <p>Vote <span class="monospace">required</span> to require support for tab as a whitespace character
by <span class="monospace">read</span>.  <span class="monospace">char-whitespace?</span> is required to return <span class="monospace">#t</span> for it
regardless.</p>
      <ul>
        <li><b>Options:</b> required, optional, undecided</li>
        <li><b>Default:</b> optional</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: required</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: required</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: required</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: required</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: required</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: required, optional, undecided</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: required</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: required</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: required</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: required, optional</li></ul></li>
        <li><b>Results:</b> <b>required</b>, optional, undecided</li>
        <li><b>Ratios:</b> 10:0, 10:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>All Schemes treat tab as whitespace anyway, though some give it special meaning (completion or whatever) at the REPL.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Behavior of <span class="monospace">read</span> should be consistent with <span class="monospace">char-whitespace?</span></dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>How can this be in question? It's just basic ASCII, as is page break, for that matter.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>When have tabs ever not been whitespace?</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This is too common to be vague on, and a lot of source code includes tabs.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I think that anything generally considered whitespace in the implementation character set is fair game. Include Unicode paragraph breaks and NELs and all that malarky that caused such fun with XML 1.1...</dd></dl>
      <h3 id="#388Specifywhat`display`doeswithcircularlists"><a href="/ticket/388">#388</a> Specify what <span class="monospace">display</span> does with circular lists</h3>
      <p>Currently we don't specify what <span class="monospace">display</span> does with circular lists.
Should it generate labels like <span class="monospace">write</span>, or loop like <span class="monospace">write-simple</span>,
or leave it unspecified?</p>
      <ul>
        <li><b>Options:</b> labels, loop, unspecified</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: labels</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: labels</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: unspecified, labels</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: labels, unspecified</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: labels, unspecified, loop</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: labels</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: labels</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: labels, unspecified, loop</li></ul></li>
        <li><b>Results:</b> <b>labels</b>, unspecified, loop</li>
        <li><b>Ratios:</b> 7:2, 8:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Display should be safe (shouldn't loop), since it's often used as a debug printer. It might be better if it ignored sharing, but not enough to be worth yet another exception.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Why are we requiring that basic I/O operations be expensive? I shouldn't have to allocate memory just to print a list.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd><span class="monospace">display</span> is Scheme's <span class="monospace">PRINT</span> statement. It should gracefully handle any input.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Display should be safe as well. We should also provide <span class="monospace">write-string</span> from <a href="/ticket/425">#425</a> for efficiency.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Looping sucks.</dd></dl>
      <h3 id="#447#!fold-caseand#!no-fold-casehavenofinaldelimiter"><a href="/ticket/447">#447</a> #!fold-case and #!no-fold-case have no final delimiter</h3>
      <p>The <span class="monospace">#!fold-case</span> and <span class="monospace">#!no-fold-case</span> directives are read as
comments, which means that they are treated as whitespace (section</p>
      <ol class="number" start="2">
        <li>2).  Unlike the other kinds of comments, their final delimiter is</li></ol>
      <p>implicit.  This means that <span class="monospace">(1#!no-fold-cases)</span> reads as <span class="monospace">(1 s)</span>.
This seems unfortunate.</p>
      <ul>
        <li><b>Proposals:</b>
          <ul>
            <li><b>identifier:</b> add the formal syntax <span class="monospace">&lt;lexical-directive&gt; --&gt; #! &lt;identifier&gt;</span> and then make the interpretation of <span class="monospace">&lt;identifier&gt;</span> implementation-dependent, except for the standard cases <span class="monospace">#!fold-case</span> and <span class="monospace">#!no-fold-case</span>. (Per Bothner, Richard Kelsey)</li>
            <li><b>delimiter:</b> the directives must be followed by delimiter (John Cowan)</li>
            <li><b>comment:</b> the draft status-quo</li></ul></li>
        <li><b>Options:</b> identifier, delimiter, comment, undecided</li>
        <li><b>Default:</b> comment</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: delimiter</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: identifier, delimiter</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: delimiter, identifier</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: delimiter, identifier, comment</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: delimiter, identifier</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: delimiter, identifier, undecided, comment</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: identifier, delimiter</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: delimiter, identifier</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: delimiter, identifier, comment</li></ul></li>
        <li><b>Results:</b> <b>delimiter</b>, identifier, comment, undecided</li>
        <li><b>Ratios:</b> 7:2, 9:0, 9:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Most of the time case-folding directives will be delimited by newline or space anyway. I see no point in adding yet another class of magic implementation-dependent things to the standards: implementations can do what they will anyway.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Requiring a delimiter (presumably including end of file) is simple and consistent. Even if we don't do that, we shouldn't stick with the status quo, which is bizarre.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>The <span class="monospace">identifier</span> choice is what Gambit Scheme uses, which provides useful self-evaluating constants such as <span class="monospace">#!eof</span> and <span class="monospace">#!void</span>. I would be totally cool with standardizing this behavior.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I don't like encouraging additional #! identifiers - requiring a delimiter is simpler and resolves the issue.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>It seems the cleanest.</dd></dl>
      <h3 id="#442writeprocedureisnotbackwardscompatible"><a href="/ticket/442">#442</a> write procedure is not backwards compatible</h3>
      <p>There is concern that the output of <span class="monospace">write</span> cannot be read by non-R7RS
implementations.  This is not a strict requirement, but is reasonable
if using simple sexp-based file/interchange formats.</p>
      <p>Specifically, even though there are no cycles in</p>
      <p><span class="monospace">(let ((x (list 2))) (write (list x x)))</span></p>
      <p>it previously output &quot;((2) (2))&quot; but now outputs &quot;(<a href="/ticket/0">#0</a>=(2) <a href="/ticket/0">#0</a>#)&quot;.</p>
      <p>The WG concern is that R5RS write is unsafe, easily causing infinite
loops, and should therefore not be the default.  Thus we renamed this
&quot;write-simple&quot;, requiring programmers to know they are writing a
&quot;simple&quot; data structure up front.</p>
      <p>Arguably, there are three procedures desired:</p>
      <ul>
        <li>write-cyclic: uses labels only to avoid cycles</li>
        <li>write-shared: uses labels for all shared structure</li>
        <li>write-simple: won't use labels - it is an error to pass a cyclic structure</li></ul>
      <p>although even for <span class="monospace">write-shared</span> people sometimes want to treat
containers such as strings separately.</p>
      <p>Note the algorithms for detecting shared structure differ from those
for detecting cycles, so providing both -shared and -cyclic imposes an
additional implementation burden.</p>
      <ul>
        <li><b>Proposals:</b>
          <ul>
            <li><b>write+simple:</b> the current draft status quo</li>
            <li><b>write+shared:</b> change <span class="monospace">write</span> back and add <span class="monospace">write-shared</span> to explicitly handle sharing</li>
            <li><b>write+cyclic:</b> change <span class="monospace">write</span> back and add <span class="monospace">write-cyclic</span> to handle only cycles</li>
            <li><b>write+shared+cyclic:</b> change <span class="monospace">write</span> back and add both <span class="monospace">write-shared</span> and <span class="monospace">write-cyclic</span></li>
            <li><b>write+simple+shared:</b> <span class="monospace">write</span> handles cycles only, provide <span class="monospace">write-simple</span> and <span class="monospace">write-shared</span> separately</li></ul></li>
        <li><b>Options:</b> write+simple, write+shared, write+cyclic, write+shared+cyclic, write+simple+shared, unspecified, undecided</li>
        <li><b>Default:</b> write+simple</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: write+simple+shared, write+simple</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: write+simple+shared</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: write+shared, write+cyclic, write+shared+cyclic, write+simple+shared</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: write+simple+shared, write+shared+cyclic, write+simple</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: write+shared+cyclic, write+shared, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: write+simple+shared, write+shared+cyclic, write+shared, write+simple, write+cyclic, unspecified, undecided</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: write+simple</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: write+simple</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: write+simple+shared, write+shared, write+simple</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: write+simple, write+simple+shared, (write+shared write+cyclic write+shared+cyclic)</li></ul></li>
        <li><b>Results:</b> <b>write+simple+shared</b>, write+simple, write+shared+cyclic, write+shared, write+cyclic, unspecified, undecided</li>
        <li><b>Ratios:</b> 6:3, 6:2, 6:2, 6:1, 7:0, 7:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>I've changed my mind on this one: it's better to have all three.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I don't have patience to try to rate the others in terms of 'least-bad'.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>We shouldn't make such a basic, incompatible change in a core language feature (i.e. <span class="monospace">write</span>) even in the interests of preventing infinite loops. Furthermore, <span class="monospace">write</span> shouldn't have to allocate memory just to print something, particularly considering that the vast majority of uses will have no cycles.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>We should have a safe, but backwards compatible <span class="monospace">write</span>, which is <span class="monospace">write-cyclic</span> assuming that it behaves as <span class="monospace">write-shared</span> only when a cycle is detected. However, we also want the other two versions.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Safety is essential and both procedures are useful.</dd>
        <dt><span class="monospace">Radul</span></dt>
        <dd>If you are trying to use read/write to implement serialization and you have two different implementations of Scheme, one of which writes shared structure by default and the other does not read it, you have two perfectly good options: Either write a procedure that unshares shared structure, or implement reading of shared structure. The latter is harder, but is likely to yield a more compact external representation.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This is backwards compatible and makes the default <span class="monospace">write</span> safe.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I want a safe write by default; if you want backwards compatability, you shouldn't be trying to send shared structure, which r5rs doesn't support. In effect, you're relying on an implicit &quot;remove all sharing&quot; phase before WRITE in R5RS. I don't like relying on implicit things if I can avoid it!</dd></dl>
      <h3 id="#219Bringbackreadablebooleanliterals"><a href="/ticket/219">#219</a> Bring back readable boolean literals</h3>
      <p>Scheme used to use <span class="monospace">#!true</span> and <span class="monospace">#!false</span> before abbreviating to
the <span class="monospace">#t</span> and <span class="monospace">#f</span> syntax.</p>
      <p>In draft 4 we added these back in as aliases, without the &quot;!&quot; now
that tokens are required to be delimited so there would be no ambiguity.</p>
      <p>Some objections were made to the new syntax which generated
a lot of discussion, so we are re-opening this ticket.  The default
is the previous decision to add <span class="monospace">#true</span> and <span class="monospace">#false</span> as aliases.</p>
      <p>The primary objection is that boolean literals are very common,
and this introduces needless incompatibilities with non-R7RS
systems, and potential confusion in documentation.</p>
      <p>The counter-argument is that these are more readable and
friendly to beginners, and allow easy visual distinction in long lists
of booleans.  We retain full backwards compatibility and are
under no obligation for non-R7RS systems to be able to run R7RS code.</p>
      <p>Note that Racket and Chibi independently adopted this same
syntax unaware of each other.  Chicken also supports this via
its SRFI-38 implementation.</p>
      <ul>
        <li><b>References:</b></li>
        <li><b>Proposals:</b>
          <ul>
            <li><b>long:</b> #true and #false</li>
            <li><b>bang-long:</b> #!true and #!false</li></ul></li>
        <li><b>Options:</b> long, bang-long, none, undecided</li>
        <li><b>Default:</b> long</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: long</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: long, no</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: long, bang-long</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: long, no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: long</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: long</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: bang-long, no</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: long</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: long, bang-long, no</li></ul></li>
        <li><b>Results:</b> <b>long</b>, bang-long, no, undecided</li>
        <li><b>Ratios:</b> 8:1, 8:2, 8:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>&quot;I meant what I said and I said what I meant / An elephant's faithful, 100%!&quot; --Horton Hatches The Egg</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd><span class="monospace">#!</span> is now for directives, which these are not.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>The long form is more readable, I suppose. However, I'm worried that non-R7RS implementations will no longer be able to read values of this most basic type.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>It is unlikely that these should be used for anything else, so we might as well alias them.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd><span class="monospace">bang-long</span> is consistent with my answer to <a href="/ticket/447">#447</a>.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I almost went back on this, but the fact that Racket came up with the same syntax convinced me. There will be few compatibility issues in practice since implementations will likely continue using the short forms for write, and the names really are an improvement.</dd></dl>
      <h3 id="#443Recommendsourcesofcharacternames"><a href="/ticket/443">#443</a> Recommend sources of character names</h3>
      <p>Currently, we allow implementations to provide their own names for
characters, but provide no guidance for them.  There are two plausible
sources: the <a href="http://unicode.org/Public/UNIDATA/NamesList.txt">names in
the Unicode Standard</a>, and the [http://www.w3.org/TR/xml-entity-names/
entity names specified by W3C] for use in HTML, MathML, and other
markup standards (ultimately derived from ISO SGML character entity
sets).</p>
      <p>The Unicode names are in all upper case and contain significant spaces
and apostrophes as name characters, which would require some mapping
to make valid Scheme identifiers.  The W3C name list is incomplete
though fairly large (currently 2237 names), covering mainly the Greek
and Cyrillic scripts and non-ASCII punctuation and symbols.  It
distinguishes between iota (small) and Iota (capital).</p>
      <p>Vote <span class="monospace">w3c</span> for the W3C list, <span class="monospace">unicode</span> to use the Unicode list with
names mapped by converting to lowercase and replacing any
non-identifier character (space and apostrophe) with hyphens.  Vote
<span class="monospace">unspecified</span> to leave the character name extensions entirely up to
the implementation.</p>
      <ul>
        <li><b>Options:</b> w3c, unicode, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: unspecified, w3c, unicode</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: w3c, unspecified</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: unspecified, unicode</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: unicode, w3c, unspecified</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: unspecified, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: unicode, w3c</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: unspecified, unicode</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: (w3c unicode), unspecified</li></ul></li>
        <li><b>Results:</b> <b>unspecified</b>, unicode, w3c, undecided</li>
        <li><b>Ratios:</b> 6:3, 5:4, 8:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Alex is unhappy with the W3C list because it has case-sensitive names (so under case folding some names are shadowed), and I'm unhappy with the Unicode list because it's huuuuuuge and the names are loooooong. Let's say nothing.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>There isn't agreement among implementations on this. If we do specify it, we should specify Unicode to be consistent with all our other support for Unicode, which is the most carefully thought out standard in any case.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I'd rather not specify this in WG1, but if we do the W3C entity names seem arbitrary and ugly, are case-sensitive (in contrast to our existing rule for character names), and most languages adding readable character names these days seem to use Unicode.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I think we should provide a recommendation, but I'm not sure which. If we go for w3c, we need to make it case-inensitive, which might be tricky for the iota!</dd></dl>
      <h2 id="WG1-BaseLibrary">WG1 - Base Library</h2>
      <h3 id="#140Removing`quotient`,`remainder`,`modulo`"><a href="/ticket/140">#140</a> Removing <span class="monospace">quotient</span>, <span class="monospace">remainder</span>, <span class="monospace">modulo</span></h3>
      <p>With the acceptance of <a href="/ticket/278">#278</a>, we reduced the set of division operators
to <span class="monospace">truncate-*</span> and <span class="monospace">floor-*</span> and move these into the base library.
Three of these procedures are simply aliases for <span class="monospace">quotient</span>,
<span class="monospace">remainder</span> and <span class="monospace">modulo</span>, so it is worth considering removing the old
names.</p>
      <p>Since the old names are in IEEE Scheme we need strong justification
for removing them from (scheme base), and even if we do so they will
remain available in (scheme r5rs).</p>
      <p>We have precedence for changing names, but only in the case when the
existing names were both actively misleading and had already been
changed in R6RS.  Specifically, in ticket <a href="/ticket/328">#328</a> we replaced the names
<span class="monospace">inexact-&gt;exact</span> and <span class="monospace">exact-&gt;inexact</span> with the more accurate <span class="monospace">exact</span>
and <span class="monospace">inexact</span>.</p>
      <p>Arguably the new division operator names are clearer, but the old
names are not actually misleading.</p>
      <p>Vote <span class="monospace">yes</span> to remove the old names from (scheme base), or <span class="monospace">no</span> to
leave them in as aliases.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: no</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no, yes</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: no</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: no</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes, no</li></ul></li>
        <li><b>Results:</b> <b>no</b>, yes</li>
        <li><b>Ratios:</b> 8:2</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>It's silly to have both sets of names in the base library.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I don't have a strong preference, so I'll go with not breaking existing code.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>This would break too much code.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This breaks too much existing code, and isn't actively misleading like <span class="monospace">inexact-&gt;exact</span>.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I'm happy about backwards compatability if they're in (scheme r5rs), and want to keep (scheme base) clean.</dd></dl>
      <h3 id="#378RenameGET-FEATUREStojustFEATURES"><a href="/ticket/378">#378</a> Rename GET-FEATURES to just FEATURES</h3>
      <p>This is compatible with Chicken, and &quot;more Scheme-like, less
Java-like&quot;.  Okay, it's bikeshedding.</p>
      <ul>
        <li><b>Options:</b> features, get-features, undecided</li>
        <li><b>Default:</b> get-features</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: features</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: features</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: features</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: features, get-features, undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: features, get-features, undecided</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: features</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: features</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: features, get-features</li></ul></li>
        <li><b>Results:</b> <b>features</b>, get-features, undecided</li>
        <li><b>Ratios:</b> 8:0, 8:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>I don't even know why I made this <span class="monospace">get-features</span> when I proposed it.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Yes, the &quot;get-&quot; prefix adds nothing here. We should consider removing it from <span class="monospace">get-output-string</span>, <span class="monospace">get-output-bytevector</span>, <span class="monospace">get-environment-variable</span>, and <span class="monospace">get-environment-variables</span> as well.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>We have precedence from Chicken, and I don't think any implementation uses get-features.</dd></dl>
      <h3 id="#384Merge`bytevector-copy`and`bytevector-copy-partial`"><a href="/ticket/384">#384</a> Merge <span class="monospace">bytevector-copy</span> and <span class="monospace">bytevector-copy-partial</span></h3>
      <p>Under this proposal, the name would be <span class="monospace">bytevector-copy</span> and the
signature would be</p>
      <p><span class="monospace">(bytevector-copy </span><i>bytevector</i> [<i>start</i> [<i>end</i>]]<span class="monospace">)</span></p>
      <p>Vote <span class="monospace">yes</span> for this simplification.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes, undecided, no</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, undecided, no</li>
        <li><b>Ratios:</b> 9:0, 9:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>This is in conformity with the way we do string and vector copiers now, as well as the destructive <span class="monospace">bytevector-copy!</span>.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>The naming convention &quot;-partial&quot; is neither widely used nor consistent with naming elsewhere in the draft.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>The *-partial interfaces are not used in existing implementations.</dd></dl>
      <h3 id="#385Merge`write-bytevector`and`write-bytevector-partial`"><a href="/ticket/385">#385</a> Merge <span class="monospace">write-bytevector</span> and <span class="monospace">write-bytevector-partial</span></h3>
      <p>One proposal is <span class="monospace">port-last</span> with a signature of:</p>
      <p><span class="monospace">(write-bytevector ''bytevector'' [''start'' [''end'' [''port'']]])</span></p>
      <p>This has the disadvantage of being required to call
<span class="monospace">bytevector-length</span> when writing to a specific port.</p>
      <p>Alternately we could do <span class="monospace">offsets-last</span>:</p>
      <p><span class="monospace">(write-bytevector ''bytevector'' [''port'' [''start'' [''end'']]])</span></p>
      <p>which has the disadvantage of separating the bytevector from its
offsets.</p>
      <p>Alternately, vote <span class="monospace">separate</span> to keep these as two separate procedures.</p>
      <ul>
        <li><b>Options:</b> port-last, offsets-last, separate, undecided</li>
        <li><b>Default:</b> separate</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: port-last</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: offsets-last</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: port-last</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: offsets-last, port-last, undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: separate, port-last</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: port-last, separate, offsets-last, undecided</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: offsets-last</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: offsets-last, port-last, undecided</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: offsets-last, separate, port-last</li></ul></li>
        <li><b>Results:</b> <b>offsets-last</b>, port-last, separate, undecided</li>
        <li><b>Ratios:</b> 5:4, 5:2, 6:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>I think the port is less important than the stop/start; it can be set using the current-output-port parameter anyway.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Alex says that we should optimize for the most common use case, and I agree, but I believe that that's writing a range of the byte vector, not writing to a different port. After all, as John points out, the latter can be accomplished using a parameter.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>We should optimize for the most common use case, and wanting to write the entire bytevector is most common.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I see no problem with separating the bytevector from its offsets, and it's a pragmatic argument ordering.</dd></dl>
      <h3 id="#387Addstart/endargumentstostring-&gt;vectorandvector-&gt;string"><a href="/ticket/387">#387</a> Add start/end arguments to string-&gt;vector and vector-&gt;string</h3>
      <p>This is a proposal to add optional start (inclusive) and end
(exclusive) arguments to <span class="monospace">string-&gt;vector</span> and <span class="monospace">vector-&gt;string</span>.  We
now have start (inclusive) and end (exclusive) arguments for
<span class="monospace">string-&gt;list</span> and <span class="monospace">vector-&gt;list</span>, but our non-R5RS and non-SRFI
procedures to convert directly between strings and vectors don't
provide these.</p>
      <p>Vote <span class="monospace">yes</span> to add these optional arguments.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: yes</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no</li>
        <li><b>Ratios:</b> 8:2</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Consistency and completeness.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Yes, these are useful, and we should be consistent. Alex says that using indexes with strings is a mistake, but I disagree. Arbitrarily indexing into a string and expecting to find a well-formed substring may be a mistake, but it should still be possible to remember safe offsets while creating a string and use them later.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>First, using indexes with strings is a mistake. More importantly, these are type coercion utilites, and the case of using indexes seems too rare, and better relegated to a thorough vector or string library, and/or a comprehensions library. Let's keep simple functions simple.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Viva la consistency!</dd></dl>
      <h3 id="#391AddpredicatesforR7RSsignalledconditions"><a href="/ticket/391">#391</a> Add predicates for R7RS signalled conditions</h3>
      <p>R7RS requires an error to be signalled (which means an exception is
raised as if by <span class="monospace">raise</span>) in the following circumstances:</p>
      <ol class="number">
        <li>Trying to open for input or delete a file that does not exist or is otherwise inaccessible.</li>
        <li>Specifying an argument to <span class="monospace">scheme-report-environment</span> that the implementation doesn't support.  (It must support 7 and may support other values.)</li>
        <li>An EOF is encountered while <span class="monospace">read</span> is in the middle of a datum.</li>
        <li>Using <span class="monospace">expt</span> to raise zero to the power of a non-real number (alternatively an arbitrary number may be returned).</li></ol>
      <p>This proposal is to provide four standard predicates that identify
these specific conditions, to be used in <span class="monospace">guard</span> clauses or in
<span class="monospace">with-exception</span> handlers as a portable means of detecting these
errors.  Although these predicates may return <span class="monospace">#t</span> on other objects,
if one reports <span class="monospace">#t</span> on an object, the others must report <span class="monospace">#f</span>.
Proposed names are <span class="monospace">file-error?</span>, <span class="monospace">scheme-report-error?</span>,
<span class="monospace">read-error?</span>, and <span class="monospace">expt-error?</span> respectively.</p>
      <p>Vote <span class="monospace">yes</span> to add these procedures, or <span class="monospace">file-only</span> to only add the
<span class="monospace">file-error?</span> predicate, and file+read to add the <span class="monospace">file-error?</span> and
<span class="monospace">read-error?</span> predicates.</p>
      <ul>
        <li><b>Options:</b> yes, file-only, file+read, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: file+read, yes, file-only</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes, file+read, file-only</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: yes, no, file-only, undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: file+read, file-only, yes, undecided, no</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no, file+read, file-only</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes, no, file-only</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, file+read, file-only, no, undecided</li>
        <li><b>Ratios:</b> 5:3, 6:2, 7:1, 7:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>There are only a few situations where errors must be signalled, and we should be able to identify which one we have in an exception handler. I can't think of any reason for providing <span class="monospace">file-error</span> but not the others.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I'm disappointed that we have an exception system without a standard taxonomy even in WG1, so this will provide at least some relief. Alex argues that all of these situations can be checked for in advance, but that's not true. For example, checking that a file exists and is accessible before opening it opens one up to a race condition. Also, the only way to determine whether EOF will be found in the middle of reading a datum is to implement a separate parser, at which point <span class="monospace">read</span> becomes useless.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>File operations are too common not to have a predicate for detecting file errors. The others are not really needed as one could test for it beforehand.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>WG2 will include a full condition hierarchy which will make this redundant. All of these can be checked for in advance.</dd></dl>
      <h3 id="#400Definerecord?."><a href="/ticket/400">#400</a> Define record? .</h3>
      <p>We should define the predicate record? so that it's possible to
distinguish instances of record types from all other types.  It should
not be necessary to enumerate all record type predicates in order to
determine whether an object is an instance of a record.</p>
      <p>This is Alexey Radul's suggestion.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: no</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: no</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: wg2, no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no, undecided, yes</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: no</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: no, yes</li></ul></li>
        <li><b>Results:</b> <b>no</b>, yes, undecided, wg2</li>
        <li><b>Ratios:</b> 7:2, 7:0, 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>No, no, a thousand times no. The large language may want to introduce opaque records (records that look like primitive types to the outside world) and this would effectively prevent it. Redefining <span class="monospace">record?</span> within a library wouldn't be enough, as it would permit opaque records to be recognized as such as soon as they were passed out of the library.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>This seems even less useful than <span class="monospace">procedure?</span>, which is hardly the most well-recommended scheme primitive. I'm not sure I care if something is a record without more powerful introspection procedures, which might at least allow me to recur through the fields. I can't do anything with it unless I already know what kind of record it is, and that is available through the predicates.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Why shouldn't one be able to distinguish instances of record types from instances of other types? John says that having <span class="monospace">record?</span> would prevent WG2 Scheme from supporting opaque records because it would be possible to recognize them as instances of record types. So what? What's the harm in being able to recognize them as such? Could a programmer do anything malicious with that information?</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>This conflicts with opacity. As with equality, if we had a means of discussing opacity in the standard in a meaningful way, then it might be reasonable to put this in here. As it stands, this predicate makes sense only when we can define it in the context of opacity. Without that, it is nonsense; it must return an unspecified value, since we should allow either opaque or open records as the defualt, given that we do not provide a means of creating one or the other explicitly -- this behavior is, of course, nonsense.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Definitely not. The idea is that each record type defines a type by itself, and that one doesn't want to exhibit implementation details. Moreover there is not any functions taking generic records.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>From my standpoint the purpose of records is not to have these things called records, but to usefully extend the Scheme type system with user-created aggregate types. There souldn't be a way to distinguish user-created types from types that are intrinsic to the language, and <span class="monospace">record?</span> would be one way to distinguish them.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This is useless without a record introspection library. We can include it when and if we provide record introspection.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I see no reason to wonder if an object is an instance of some record type.</dd></dl>
      <h3 id="#425Addread-string,read-string!,write-stringproceduresto(schemebase)"><a href="/ticket/425">#425</a> Add read-string, read-string!, write-string procedures to (scheme base)</h3>
      <p>This was requested by Formal Comment <a href="/ticket/424">#424</a>.</p>
      <p>These procedures would be provided for parallelism with the
byte-vector I/O operations:</p>
      <table><tr><td class="default">
            <p>Byte</p></td><td class="default">
            <p>Character</p></td><td class="default">
            <p>Bytevector</p></td><td class="default">
            <p>String</p></td></tr><tr><td class="default">
            <p>read-u8</p></td><td class="default">
            <p>read-char</p></td><td class="default">
            <p>read-bytevector(!)</p></td><td class="default">
            <p>read-string(!)</p></td></tr><tr><td class="default">
            <p>write-u8</p></td><td class="default">
            <p>write-char</p></td><td class="default">
            <p>write-bytevector</p></td><td class="default">
            <p>write-string</p></td></tr></table>
      <p>If <a href="/ticket/385">#385</a> passes, optional <i>start</i> (inclusive) and <i>end</i> (exclusive)
index arguments would be added to <span class="monospace">write-string</span>.  Otherwise
<span class="monospace">write-partial-string</span> would be provided.</p>
      <p>Vote <span class="monospace">yes</span> to add all three, <span class="monospace">immutable</span> to add only <span class="monospace">read-string</span> and
<span class="monospace">write-string</span>, or <span class="monospace">no</span> to leave them out.</p>
      <ul>
        <li><b>Options:</b> yes, immutable, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes, immutable.</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes, immutable</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes, immutable</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: yes, immutable, no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: immutable, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: immutable, yes</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: immutable, no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: immutable, yes, no</li></ul></li>
        <li><b>Results:</b> <b>immutable</b>, yes, no, undecided, immutable.</li>
        <li><b>Ratios:</b> 4:4, 7:0, 7:1, 7:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>As soon as we voted in <span class="monospace">string-copy!</span>, the goal of immutable strings died a horrible death. We should have all of these for bulk I/O. Still, <span class="monospace">immutable</span> is better than <span class="monospace">no</span>.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I'm alarmed that we made it this far without <span class="monospace">write-string</span>.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>How would encodings be handled? Perhaps we should</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>These are very useful, but for reading into a mutable data-structure you should use bytevectors - strings are not guaranteed to have the requisite size allocated.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>These are quite useful operations, and I have a penchant for immutability.</dd></dl>
      <h3 id="#433fullconversioncycleforcontainers"><a href="/ticket/433">#433</a> full conversion cycle for containers</h3>
      <p>Marc Feeley proposes it should be possible to convert from any
container type to another, possibly via an intermediary such as</p>
      <p><span class="monospace">(list-&gt;B (A-&gt;list a))</span></p>
      <p>proposing specifically &quot;list&quot; be the universally available
intermediary, although &quot;vector&quot; would also be worth considering.</p>
      <p>The container types are list, vector, string and bytevector.  String
and bytevector are second-class in that they are not general-purpose
container types, and may raise errors converting from lists or
vectors.</p>
      <p>Vote <span class="monospace">list</span> for the proposal to add the following procedures to
complete the cycle:</p>
      <ul>
        <li>list-&gt;bytevector</li>
        <li>bytevector-&gt;list</li></ul>
      <p>Vote <span class="monospace">vector</span> to add the equivalent procedures to allow converting
between any of the types and vectors, specifically the following two
new procedures:</p>
      <ul>
        <li>vector-&gt;bytevector</li>
        <li>bytevector-&gt;vector</li></ul>
      <p>Vote <span class="monospace">list+vector</span> to add both list and vector conversions.</p>
      <p>The <span class="monospace">latin-1</span> proposal also adds the Latin-1-centric ideas of string to
bytevector conversion, where each element of the bytevector is
converted to/from a character with char-&gt;integer/integer-&gt;char.</p>
      <p>The <span class="monospace">matrix</span> proposal requires all 4<sup>3</sup>=64 conversions.</p>
      <ul>
        <li><b>Options:</b> matrix, list, vector, list+vector, latin-1, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: list+vector</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: vector, matrix</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no, list+vector, vector</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: vector, list+vector, list, no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: list, list+vector, no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no, vector, list+vector, list, undecided, latin-1, matrix</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no, list, vector, list+vector, latin-1</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: vector, list, (list+vector matrix latin-1)</li></ul></li>
        <li><b>Results:</b> <b>no</b>, vector, list+vector, list, undecided, latin-1, matrix</li>
        <li><b>Ratios:</b> 4:3, 3:4, 3:3, 5:1, 5:1, 5:2</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Conversions between bytevectors and lists/vectors are sensible, but doing Latin-1 conversions isn't a particularly sensible conversion between strings and bytevectors.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I don't see a lot of justification for <span class="monospace">bytevector-&gt;list</span>.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I don't see the point. These conversions are generally wasteful, especially as simple intermediate values, and direct conversions would be better. However, we shouldn't include the full direct conversions matrix because that's just too large, especially for WG1.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>This is more part of a WG2 library.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I'd rather these be part of the general extended bytevector library from wg2. Bytevectors are a second class data structure that can only hold bytes, not a general purpose one like lists or vectors.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Vectors and bytevectors are more akin. I don't really see a need for a single &quot;universal&quot; intermediary; unnecessary inconsistency is bad, but situations like converting between strings and bytevectors are useful as a chokepoint at which to concentrate the complexity of encoding choices.</dd></dl>
      <h3 id="#444Addvector-appendprocedure"><a href="/ticket/444">#444</a> Add vector-append procedure</h3>
      <p>This is for completeness with <span class="monospace">append</span> and <span class="monospace">string-append</span>.  See <a href="/ticket/436">#436</a>
for the Formal Comment that triggered this ticket.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: yes, undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes, no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes, no</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no, undecided</li>
        <li><b>Ratios:</b> 9:0, 9:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Consistency and completeness.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Yes, for consistency and completeness.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Although I disagree with the rationale in the formal comment, this is a generally useful function.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I'm a sucker for consistency and complete sets of things, too. Is this why my house is overflowing with books?</dd></dl>
      <h3 id="#451Addbytevector-appendprocedure"><a href="/ticket/451">#451</a> Add bytevector-append procedure</h3>
      <p>This is for consistency with <span class="monospace">append</span>, <span class="monospace">string-append</span>, and
<span class="monospace">vector-append</span> (per ticket <a href="/ticket/444">#444</a>) procedures.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: yes, undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes, no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes, no</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no, undecided</li>
        <li><b>Ratios:</b> 9:0, 9:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Consistency and completeness.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Yes, for consistency and completeness.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This is perhaps less useful than <span class="monospace">vector-append</span> but reasonable to include.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Well, the camel's nose was already in the tent...</dd></dl>
      <h3 id="#445Bidirectionalportsandport-open?"><a href="/ticket/445">#445</a> Bidirectional ports and port-open?</h3>
      <p>Replace <span class="monospace">port-open?</span> with <span class="monospace">input-port-open?</span> and <span class="monospace">output-port-open?</span>,
since a bidirectional port can be closed on one side without the
other.  See Formal Comment <a href="/ticket/439">#439</a>.</p>
      <p>Vote <span class="monospace">replace</span> to replace <span class="monospace">port-open?</span> with just the two new versions,
or <span class="monospace">add</span> to have all three.</p>
      <ul>
        <li><b>Options:</b> replace, add, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: replace</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: replace</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: replace</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: undecided, add</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: add, replace, no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: replace</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: replace</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: replace, add</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: replace, add, no</li></ul></li>
        <li><b>Results:</b> <b>replace</b>, add, no, undecided</li>
        <li><b>Ratios:</b> 7:2, 8:0, 8:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>It's better to keep these separate, even if marginally less convenient.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Leaving <span class="monospace">port-open?</span> leads to the question of whether it should require both sides or either side of a bidirectional port to be open. The answer should probably be both, but then you still need to use both the new procedures to determine that a port is closed, or add yet another.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Otherwise it's unclear what <span class="monospace">port-open?</span> means on a bidirectional port.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Contrary to close-port I think you always know which direction you need when checking if a port is open.</dd></dl>
      <h3 id="#450Eliminatedefaultforfillargumentinvector-copy"><a href="/ticket/450">#450</a> Eliminate default for fill argument in vector-copy</h3>
      <p>Marc Feeley writes:</p>
      <p>It is a bad idea for the <i>fill</i> parameter of <span class="monospace">vector-copy</span> to have a
default. When <i>fill</i> is absent, it should be an error when <i>start</i>
and <i>end</i> are not within the bounds of the sequence. Otherwise, some
index calculation errors (off-by-one on <i>end</i>) may go
unnoticed. Moreover, when it is supplied, <i>fill</i> should also be used
when <i>start</i> is less than 0, for consistency with the case where
<i>end</i> is greater to the length of the sequence.</p>
      <p>Vote <span class="monospace">required</span> to make the fill parameter required, <span class="monospace">error</span> to make
it an error in the case that fill is absent yet needed, <span class="monospace">remove</span> to
remove the fill parameter and signal a runtime error if end is longer
than the input vector, or <span class="monospace">default</span> for the current status quo.</p>
      <ul>
        <li><b>Options:</b> required, error, remove, default, undecided</li>
        <li><b>Default:</b> default</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: default</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: error</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: remove, error, required</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: remove, error, default, undecided, required</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: remove</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: remove, default, error</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: error, remove, required, default</li></ul></li>
        <li><b>Results:</b> <b>remove</b>, error, default, undecided, required</li>
        <li><b>Ratios:</b> 4:2, 5:1, 5:2, 5:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>This routine comes from SRFI-43 and should be kept compatible with it.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Marc's suggestions sound convincing to me.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>While allowing the <span class="monospace">fill</span> parameter to have a default value is compatible with SRFI 43, Marc's argument about detecting errors is strong. However, I disagree that the idea of allowing <span class="monospace">start</span> to be negative is somehow more consistent. The obvious application of the <span class="monospace">fill</span> parameter is implementing variable-length data structures out of vectors, extending the original in the process. However, using the name <span class="monospace">vector-copy</span> for this purpose is an awkward overloading. A separate procedure, not defined in WG1 Scheme, should be used for that purpose. I've updated <a href="/wiki/WG1Ballot">WG1Ballot</a>, so others should adjust their votes if they see fit.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>It should be an error to cross vector boundary, lest something terribly wrong may happen unnoticed. As Alex said, the best is IMHO to remove this fill parameter.</dd>
        <dt><span class="monospace">Read</span></dt>
        <dd>Seems to me like needless complexity.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I think we're conflating the vector-copy and vector-fill! concepts here and should just remove the fill parameter. It should be a runtime error if end is longer than the input vector. Either way, we can't make the final parameter required without making start and end required as well, which is too clumsy.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I like the reasoning about making off-by-ones into real errors.</dd></dl>
      <h3 id="#404Makehandlerstakearaise-continuable?argument."><a href="/ticket/404">#404</a> Make handlers take a raise-continuable? argument.</h3>
      <p>Pass exception handlers a second, Boolean argument that declares
whether the exception is continuable.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: no</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: no, undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: undecided, no</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes, no</li></ul></li>
        <li><b>Results:</b> <b>no</b>, undecided, yes</li>
        <li><b>Ratios:</b> 5:3, 5:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Given that Scheme has no way of calling a procedure portably when the number of arguments it accepts is unknown, I have to reluctantly reject this, even though it is clearly the Right Thing. Many handlers will not care, and they should not be required to be retrofitted with a dummy second argument.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Seems like a lot of wires to connect. I can see why this might be useful, but would like to see some examples of programs that rely on this, and decide whether this is really the best way. For example, perhaps <span class="monospace">with-exception-handler</span> can provide separate handlers for the continuable and non-continuable cases.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I would like to see this, too, but agree that passing it to every handler is overly verbose considering how rarely it would be used. We should address this in WG2 where we will, I hope, have a more powerful exception system.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>This is a needed feature, but I am not convinced that this is the correct way to express it ?</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This has no precedent, and could be difficult for implementations to support.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I think this is useful information to know.</dd></dl>
      <h3 id="#464Addoptionalstartandendparameterstoutf8-&gt;stringandstring-&gt;utf8."><a href="/ticket/464">#464</a> Add optional start and end parameters to utf8-&gt;string and string-&gt;utf8.</h3>
      <p>Per ticket 464, add optional start and end arguments to <span class="monospace">utf8-&gt;string</span>
and <span class="monospace">string-&gt;utf8</span>.</p>
      <p>Vote <span class="monospace">both</span> to add optional start and end arguments to both,
<span class="monospace">string-&gt;utf8</span> or <span class="monospace">utf8-&gt;string</span> to add them to only one procedure, or
<span class="monospace">neither</span> to leave both unchanged.</p>
      <ul>
        <li><b>Options:</b> both, string-&gt;utf8, utf8-&gt;string, neither</li>
        <li><b>Default:</b> neither</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: both, utf8-&gt;string</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: both</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: both, utf8-&gt;string, no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: both</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: both</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: both</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: both</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: both, utf8-&gt;string, (string-&gt;utf8 neither)</li></ul></li>
        <li><b>Results:</b> <b>both</b>, utf8-&gt;string, string-&gt;utf8, neither, no</li>
        <li><b>Ratios:</b> 8:0, 8:0, 8:0, 8:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>I think both of these are wins, but converting part of a bytevector into a string without having to copy it first is probably the more important part.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Consistency is good. BTW, I REALLY dislike these names. The bytevector is not utf8, it's just bytes. If anything, the string is utf8. I prefer <span class="monospace">bytevector-&gt;string</span>/<span class="monospace">string-&gt;bytevector</span>, possibly taking <span class="monospace">utf8</span> as a symbol argument, to allow support for alternative coding. At a minimum, <span class="monospace">bytevector-&gt;utf8</span>/<span class="monospace">utf8-&gt;bytevector</span> would make more sense.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>As Marijn says, it's useful to be able to avoid extra copying while decoding a string. We should change both for symmetry.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>The arguments to utf8-&gt;string are necessary for many common idioms of reading binary data and extracting strings from it. The reverse is much less useful, but makes sense for symmetry.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Consistency!</dd></dl>
      <h2 id="WG1-OptionalLibraries">WG1 - Optional Libraries</h2>
      <h3 id="#373(exit#t)shouldbethesameas(exit)"><a href="/ticket/373">#373</a> (exit #t) should be the same as (exit)</h3>
      <p>See Formal Comment <a href="/ticket/372">#372</a> for the argument.  Cowan writes: &quot;I support this proposal.  I
don't support the alternative proposal to just say that any true value
reports success and only #f reports failure, for there is usually only
one kind of success (0 on Posix and Windows, &quot;&quot; on Plan 9, 2 on VMS)
and many kinds of failure.&quot;</p>
      <p>It is reasonable and convenient to use <span class="monospace">#t</span>/<span class="monospace">#f</span> as generic
success/failure for portable programs, with <span class="monospace">(exit)</span> as a shorthand
for the &quot;normal&quot; completion <span class="monospace">(exit #t)</span>.</p>
      <p>Another reasonable extension is fallback for certain success values
that the implementation cannot understand.  Specifically, <span class="monospace">0</span> is
commonly used for success on Posix systems, and the empty string &quot;&quot; as
success on Plan9.  We could require that if the implementation does
not know how to pass these value types (string or number) to the OS,
then it should recognize <span class="monospace">0</span> and <span class="monospace">&quot;&quot;</span> as true.  Any value other than
these which cannot be passed to the OS should be treated as a generic
error.  That way, a program written for Posix that alternatively uses
<span class="monospace">(exit 0)</span> and <span class="monospace">(exit &lt;n&gt;)</span> will still work as desired on a Plan9
system, only losing details of the type of failure (and likewise for
Plan9 programs running on Posix).</p>
      <p>In either case, unless someone makes a proposal to the contrary,
unknown values should always be treated as generic failure, and never
raise an exception or fail to exit (from <a href="/ticket/374">#374</a>).</p>
      <ul>
        <li><b>Proposals:</b>
          <ul>
            <li><b>boolean:</b> Only <span class="monospace">#t</span>/<span class="monospace">#f</span> are as described as above, and all other values are passed (as best as possible) to the OS and therefore implementation-defined</li>
            <li><b>extended-true:</b> <span class="monospace">#f</span> is generic failure, <span class="monospace">#t</span> generic success, and <span class="monospace">&quot;&quot;</span> and <span class="monospace">0</span> are generic success if not otherwise understood by the OS</li></ul></li>
        <li><b>Options:</b> boolean, extended-true, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: boolean</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: boolean</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: boolean, unspecified</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: boolean</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: boolean, unspecified</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: boolean, unspecified, undecided, extended-true</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: extended-true, boolean</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: boolean, extended-true, unspecified</li></ul></li>
        <li><b>Results:</b> <b>boolean</b>, unspecified, extended-true, undecided</li>
        <li><b>Ratios:</b> 8:0, 7:1, 8:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd><span class="monospace">Extended-true</span> is going too far: 0 means success on many systems, but failure (specifically: failure of unknown origin) on VMS. Portable code should stick with <span class="monospace">#t</span> and <span class="monospace">#f</span>.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Don't add unnecessary OS dependencies.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Making <span class="monospace">(exit #t)</span> have the same effect as <span class="monospace">(exit)</span> is a no-brainer. I can see no portable reason to treat the empty string and zero specially.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>This is the only way to allow programs to exit with meaningful values while remaining portable.</dd></dl>
      <h3 id="#375AddEMERGENCY-EXITprocedure"><a href="/ticket/375">#375</a> Add EMERGENCY-EXIT procedure</h3>
      <p>This procedure provides instant guaranteed process exit without
running <span class="monospace">dynamic-wind</span> thunks.  This is a low-level and dangerous
procedure.</p>
      <p>Vote <span class="monospace">emergency-exit</span> to add this procedure, or <span class="monospace">no</span> to leave it out.
If you want to write in an alternate name, be sure to include
<span class="monospace">emergency-exit</span> as a secondary option after it.</p>
      <ul>
        <li><b>Options:</b> emergency-exit, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: exit-immediately, emergency-exit</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: abort, emergency-exit</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: exit-immediately, emergency-exit</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: exit-immediately, emergency-exit, undecided, no</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: exit!, emergency-exit</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: no, emergency-exit</li></ul></li>
        <li><b>Results:</b> <b>emergency-exit</b>, no, exit-immediately, undecided, abort, exit!</li>
        <li><b>Ratios:</b> 5:4, 3:3, 6:0, 5:1, 5:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Given that <span class="monospace">exit</span> unwinds thunks, this is needed. It should also call <span class="monospace">_exit()</span> on Posix and Windows, so stdio buffers are not flushed either. I agree that <span class="monospace">exit-immediately</span> is a better name.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I think <span class="monospace">abort</span> is standard for this. It is probably not recommended in production code, but is useful for completeness, for education, and potentially for debugging.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I hate the name, but it makes sense to be able to exit immediately. Frankly, I'd rather that <span class="monospace">exit</span> did this, or that its behavior with regard to <span class="monospace">dynamic-wind</span> was unspecified. It's my impression that people use <span class="monospace">exit</span> when they want their program to stop immediately. They don't want a <span class="monospace">dynamic-wind</span> form to prevent their exit, for example. I suggest the name <span class="monospace">exit-immediately</span>.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>This is not a reasonable thing to have in WG1's version of Scheme.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>This is occasionally (or unfortunately) needed in critical systems. Arthur's name proposal is certainly better.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Maybe in WG2, but this is too dangerous for general use.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Looks too dangerous and low-level, IMHO.</dd></dl>
      <h3 id="#394DitchingSCHEME-REPORT-ENVIRONMENTandNULL-ENVIRONMENT"><a href="/ticket/394">#394</a> Ditching SCHEME-REPORT-ENVIRONMENT and NULL-ENVIRONMENT</h3>
      <p>Cowan writes:</p>
      <p>&quot;I have reluctantly come to the same conclusion as the R6RS editors:
that in a Scheme with libraries, <span class="monospace">scheme-report-environment</span> and
<span class="monospace">null-environment</span> don't make much sense.  They are not in IEEE Scheme
or R4RS, so there is no formal barrier to removing them.</p>
      <p>&quot;Semantically, <span class="monospace">scheme-report-environment</span> holds all the identifiers in
R5RS, excepting any which the implementation doesn't provide, like
<span class="monospace">make-rectangular</span> if it does not have complex numbers.
<span class="monospace">Null-environment</span>, on the other hand, contains only the syntax
keywords with none of the standard procedures: it is not an empty
environment.  R6RS preserves these procedures only in the R5RS
compatibility library, where they expose only R5RS content.</p>
      <p>&quot;When adapting the definition to R7RS, I changed
<span class="monospace">scheme-report-environment</span> to contain all the identifiers in all the
standard libraries that the implementation provides, and
<span class="monospace">null-environment</span> all the syntax keywords in those libraries.  This
was the best I thought I could do, but now I think that it provides
very little utility.</p>
      <p>&quot;It's possible to construct any specific environment you want by using
the <span class="monospace">environment</span> procedure, which turns a sequence of import-specs
into an environment.  In particular, we now have the <span class="monospace">(scheme r5rs)</span>
library, which essentially provides what
<span class="monospace">(scheme-environment-procedure 5)</span> should provide, and there is no
portable use of any argument other than 5.&quot;</p>
      <p>Vote <span class="monospace">remove</span> to remove these two procedures entirely, or <span class="monospace">move</span> to
move them from (scheme eval) and provide them only as portability
options in <span class="monospace">(scheme r5rs)</span>, where only the argument 5 is required to
be supported.  Vote <span class="monospace">keep</span> to leave them as-is.</p>
      <ul>
        <li><b>Options:</b> remove, move, keep, undecided</li>
        <li><b>Default:</b> keep</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: move, remove</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: remove, move, keep</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: move, remove</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: remove, move, keep</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: move, remove, keep, undecided</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: move</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: move</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: move, remove, keep</li></ul></li>
        <li><b>Results:</b> <b>move</b>, remove, keep, undecided</li>
        <li><b>Ratios:</b> 6:2, 8:0, 8:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>These do no harm in the R5RS-compatibility library, but are actively harmful (because misleading) in the <span class="monospace">eval</span> library where they are today.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I see John's point, but we shouldn't break compatibility with R5RS.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I agree they are less meaningful, but want to preserve <span class="monospace">(scheme r5rs)</span> compatibility as much as possible.</dd></dl>
      <h3 id="#413EVALacceptsDEFINE"><a href="/ticket/413">#413</a> EVAL accepts DEFINE</h3>
      <p>The proposal is to require <span class="monospace">eval</span> to accept definitions as well as
expressions, as long as the specified environment is mutable.  See
<a href="/wiki/EvalDefine">EvalDefine</a> for which Schemes already handle this.</p>
      <ul>
        <li><b>Options:</b> yes, no, unspecified, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes, but</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: yes</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes, no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes, unspecified</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, unspecified, but, no</li>
        <li><b>Ratios:</b> 9:0, 9:0, 9:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>We've got first-class environments now, we should make use of them.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I would expect and prefer all environments to be mutable, at least by default, i.e., <span class="monospace">null-environment</span> and <span class="monospace">environment</span> are procedures that always return a &quot;new&quot; environment with a particular structure that can be modified by <span class="monospace">eval</span>.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd><span class="monospace">eval</span> should accept the full language, including defines.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>We've got first-class environments now, we should make use of them.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I see it as a useful facility for many uses.</dd></dl>
      <h3 id="#399clarifywhichprimitivesareallowedtoimplicitlyforce"><a href="/ticket/399">#399</a> clarify which primitives are allowed to implicitly force</h3>
      <p>The standard allows the following extension to force:</p>
      <p>Some implementations may implement &quot;implicit forcing,&quot; where the
  value of a promise is forced by primitive procedures like `cdr'
  and `+'</p>
      <p>We should remove this note or tighten the definition.</p>
      <p>A simple definition is any primitive that would require a type-check
can perform implicit forcing.  This would include all type predicates
themselves except for <span class="monospace">promise?</span>.  Note if <a href="/ticket/405">#405</a> passes, then in
implementations which support this extension an object could return
<span class="monospace">#t</span> for <span class="monospace">promise?</span> in addition to one other type.</p>
      <ul>
        <li><b>Options:</b> remove, type-check, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: type-check, unspecified</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: type-check, unspecified</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: unspecified</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: remove, undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: type-check, unspecified</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: remove, unspecified, type-check, undecided</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: unspecified, type-check</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: type-check, unspecified, remove</li></ul></li>
        <li><b>Results:</b> ''type-check'', unspecified, remove, undecided</li>
        <li><b>Ratios:</b> 4:3, 5:2, 6:2</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>The <span class="monospace">type-check</span> rule is sensible and clear.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I don't see any reason to change this.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Conflating a lazy language with standard Scheme is not a good idea, especially for primitives. One may still provide its own extensions, but no standard code have to rely on this.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I don't like removing this extension, which is still available in chibi-scheme. <span class="monospace">type-check</span> is slightly different from what chibi currently does.</dd></dl>
      <h3 id="#405Makepromisesfirst-class"><a href="/ticket/405">#405</a> Make promises first-class</h3>
      <p>Currently there is no way to inspect an object to see if it's a
promise.  This proposal makes promises first-class by adding a
<span class="monospace">promise?</span> predicate.  It also requires that if the argument to
<span class="monospace">make-promise</span> is a promise, it is returned without rewrapping it, and
that if <span class="monospace">force</span> is given a non-promise argument, it returns it
unchanged.  (These things cannot be provided by the user without a
<span class="monospace">promise?</span> predicate, and are trivial to provide with it.)</p>
      <p>Vote <span class="monospace">disjoint</span> to add <span class="monospace">promise?</span> and make it a disjoint type, or
<span class="monospace">yes</span> to add it as a not-necessarily disjoint predicate.</p>
      <ul>
        <li><b>Options:</b> disjoint, yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: disjoint, yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: yes, no, undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: disjoint, yes</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: yes, disjoint, undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: disjoint</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes, undecided, disjoint, no</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: disjoint</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes, (no disjoint)</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, disjoint, undecided, no</li>
        <li><b>Ratios:</b> 5:4, 7:0, 7:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Promises should be disjoint, specifically disjoint from procedures. See DisjointProcedures for which are and which are not.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>The <span class="monospace">disjoint</span> option seems inconsistent with implicit forcing.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>The <span class="monospace">promise?</span> procedure is useful, as the examples above demonstrate. Once we support <span class="monospace">promise?</span>, keeping them disjoint seems easy, since if one implements them directly as procedures, one can't provide <span class="monospace">promise?</span> without an inefficient table lookup anyway.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>We should have a way to check for promises, but not make it a disjoint type. It is perfectly reasonable to implement promises with thunks.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd><span class="monospace">promise?</span> is useful, I don't think it needs to be disjoint. One must still be aware that the result of <span class="monospace">(delay &lt;expr&gt;)</span> may not answer true to <span class="monospace">promise?</span> given the existing allowed extensions.</dd></dl>
      <h3 id="#462endoflinedefinition"><a href="/ticket/462">#462</a> end of line definition</h3>
      <p>The definition of read-line allows implementation defined extensions
to the set of end of line sequences. This is arguably too loose, as an
implementation could define &quot;a&quot; as and end of line. On the other hand,
if we do want to leave this in it may make sense to remove &quot;\r&quot;, which
is no longer used in any contemporary OS.</p>
      <p>Vote <span class="monospace">no-extensions</span> to forbid implementation defined extensions,
<span class="monospace">no-return</span> to remove a single return from the list of required end of
lines, and <span class="monospace">none</span> to leave as-is.</p>
      <ul>
        <li><b>Options:</b> no-extensions, no-return, none, undecided</li>
        <li><b>Default:</b> none</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: no, no-return</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: no-return</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: no, no-return</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: no</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: no, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: no</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: no</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no-return, no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: no</li></ul></li>
        <li><b>Results:</b> <b>no</b>, no-return, undecided</li>
        <li><b>Ratios:</b> 7:2, 8:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>The implementation-defined extensions is for the sake of R6RS systems that treat EBCDIC NEL and Unicode LS as line delimiters (a la XML 1.1, both my doing, I fear). Defining &quot;a&quot; as a line ending is a quality of implementation issue; the standard does not need to forbid implementations from being stupid, because nobody will use such an implementation. I agree we could live without <span class="monospace">\r</span>, but it's very standard today in such routines.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>I think we can trust that implementations will be reasonable here. They should be left enough leeway to deal with any OS.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Implementations are going to define extensions, and it's unreasonable to expect them not to.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Not any sensible implementation would do such thing !</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Allowing extensions is reasonable, and given that case there is no need to explicitly mention the antiquated &quot;\r&quot;.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>Implementations can already do stupid things, like provide only a few bytes of memory and therefore rejecting all nontrivial programs; common sense is enough of a barrier to that.</dd></dl>
      <h3 id="#452providedigit-valuesupportfornon-decimal-digits"><a href="/ticket/452">#452</a> provide digit-value support for non-decimal-digits</h3>
      <p>In ballot 4, in symmetry with the new Unicode definition of
<span class="monospace">char-numeric?</span> and as an analog to CL's <span class="monospace">digit-char-p</span>, we provided
<span class="monospace">digit-value</span>.</p>
      <p>An informal comment was made questioning this procedure, and
suggesting if provided at all it be extended to hex digits.</p>
      <p>Vote <span class="monospace">ascii-hex</span> to support only the ASCII hex digits a-f,A-F (in
addition to full Unicode numeric digits), <span class="monospace">unicode-hex</span> to support all
Unicode variants of a-f,A-F (need to define formally).</p>
      <p>Vote <span class="monospace">ascii-radix</span> or <span class="monospace">unicode-radix</span> to have both <span class="monospace">digit-value</span> and <span class="monospace">char-numeric?</span> take a radix argument, such that <span class="monospace">char-numeric?</span> returns #t and <span class="monospace">digit-value</span> returns the appropriate value for characters representing non-numeric digits of that radix under ASCII or Unicode character encodings, respectively, and for characters representing numeric digits under Unicode.  Implementations are required to support at least the radix values: 2, 8, 10, and 16, and may support others.</p>
      <p>Vote <span class="monospace">remove</span> to remove <span class="monospace">digit-value</span> entirely, <span class="monospace">remove-radix</span> to remove <span class="monospace">digit-value</span> entirely, but add the radix argument to <span class="monospace">char-numeric?</span> as described above, or <span class="monospace">keep</span> to keep as is.</p>
      <ul>
        <li><b>Options:</b> ascii-hex, unicode-hex, ascii-radix, unicode-radix, remove, remove-radix, keep, undecided</li>
        <li><b>Default:</b> keep</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: keep</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: unicode-radix, ascii-radix, remove-radix, keep</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: remove, ascii-hex</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: remove, keep, undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: ascii-hex, keep</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: remove, undecided, ascii-hex, keep, unicode-hex</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: remove, keep, undecided</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: unicode-hex, ascii-hex, keep, remove</li></ul></li>
        <li><b>Results:</b> remove, ascii-hex, ''keep'', undecided, unicode-hex, unicode-radix, ascii-radix, remove-radix</li>
        <li><b>Ratios:</b> 4:2, 4:4, 5:0, 4:1, 5:1, 5:1, 5:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Allowing the hex digits is an unnecessary wart.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>A radix argument allows support for letters a-f as digits without creating inconsistency with <span class="monospace">char-numeric?</span>. It also allows easier access to these results for other numeric systems.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>We've strayed into invention territory here, providing something that existing implementations don't. If we do keep it, it should support ASCII hex for compatibility with <span class="monospace">string-&gt;number</span>.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Let WG2 comes up with an Unicode library.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>digit-value is paired with char-numeric? which does not handle hex digits. The two of these can serve as a basis for hex-digit or base-N-digit procedures. The -radix variations are already getting too complicated for something in the core language. Since there is contention I'd just as soon move this to more general Unicode property handling in WG2, however.</dd></dl>
      <h2 id="WG1-Non-normative">WG1 - Non-normative</h2>
      <h3 id="#411Referenceimplementation"><a href="/ticket/411">#411</a> Reference implementation</h3>
      <p>Our charter calls for one or more reference implementations.  As of
today, Chibi is very close to being so.  The proposal is to bless it
as a sample or model implementation, but not technically a reference
implementation -- if it disagrees with the standard, the standard
wins.</p>
      <ul>
        <li><b>Options:</b> yes, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: yes</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: yes</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: undecided</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: yes, no, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: yes</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: yes</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: yes</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: yes, no</li></ul></li>
        <li><b>Results:</b> <b>yes</b>, no, undecided</li>
        <li><b>Ratios:</b> 7:0, 7:2</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Chibi is the de facto model implementation, and we may as well say so. It's small, easy to understand, and does a lot of things directly in Scheme.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>If it disagrees with the standard (as is always possible) one of them needs to be changed, even after we are officially relieved of our duty, so the distinction seems pedantic.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>Chibi is the one implementation that be considered a reference implementation, and we are supposed to provide one, so let's make it official. Thank you very much to Alex for doing the work to make this happen.</dd>
        <dt><span class="monospace">Medernach</span></dt>
        <dd>Of course. Thanks Alex for such an impressive work !</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>The important thing is the standard comes first.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>It's easier to have bugs in an implementation than in a specification.</dd></dl>
      <h3 id="#463librarynamingconventions"><a href="/ticket/463">#463</a> library naming conventions</h3>
      <p>We currently use the singular form of data types for library names,</p>
      <ol class="alpha-lower" start="5">
        <li>g. <span class="monospace">(scheme char)</span> and <span class="monospace">(scheme file)</span>.  R6RS prefers the plural, as</li></ol>
      <p>in <span class="monospace">(scheme lists)</span> and <span class="monospace">(scheme records)</span>. We should decide
officially which is preferred.</p>
      <ul>
        <li><b>Options:</b> singular, plural, unspecified, undecided</li>
        <li><b>Default:</b> unspecified</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: singular</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: singular, plural</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: singular, plural, unspecified</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: plural</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: plural, unspecified, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: plural</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: singular, unspecified</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: plural, singular</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: singular</li></ul></li>
        <li><b>Results:</b> <b>singular</b>, plural, unspecified, undecided</li>
        <li><b>Ratios:</b> 5:4, 6:1, 6:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>This is a matter of taste, but I like the singular form and see no reason to change it.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Just personal preference.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I'll bikeshed for the singular. (I'm assuming that what we're saying here is that we'll change all of the data type names we use, not that we're saying anything about the names people use for purposes other than standard data types.)</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>Not only R6RS but also several SRFIs, e.g. (srfi 99 records), have started a plural convention.</dd></dl>
      <h2 id="WG1-Lateadditions">WG1 - Late additions</h2>
      <h3 id="#465Addjiffy-modulustospecifywhen,ifever,current-jiffywraps"><a href="/ticket/465">#465</a> Add jiffy-modulus to specify when, if ever, current-jiffy wraps</h3>
      <p>If the value of <span class="monospace">current-jiffy</span> is to be both space-efficient (that is, a fixnum) and reasonably precise (say, microsecond timing), it needs to wrap around: 30-bit fixnums on a 32-bit system will wrap every 17 minutes.  That means an application needs to know what the maximum value is before it wraps back to zero.  The <span class="monospace">jiffy-modulus</span> function returns the maximum value of the current jiffy plus 1.  Alternatively, jiffies can be signed and wrap from (- (jiffy-modulus) 1) to (- (jiffy-modulus)), which is easier for the implementation but harder for the user.</p>
      <ul>
        <li><b>Options:</b> unsigned, signed, no, undecided</li>
        <li><b>Default:</b> no</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: unsigned</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: undecided</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: undecided, unsigned, no</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: undecided</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: no</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: unsigned, signed, no</li></ul></li>
        <li><b>Results:</b> ''undecided'', unsigned, <b>no</b>, signed</li>
        <li><b>Ratios:</b> 4:2, 4:2, 4:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>Unsigned will roll over faster if the full fixnum range is used, but it makes life easier for the user not to have to deal with negative jiffy values ever.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I don't know what existing implementations do.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>I am not sure that I really follow or understand a lot of these timing functions, and the idea of putting something that is implicitly a fixnum into the system strikes me as a bad design.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>As specified, this is broken, since if jiffies are equated with fixnums, and an implementation has no bignum support, then by definition it cannot represent the modulus. A better API is <span class="monospace">(maximum-jiffy)</span> optionally with <span class="monospace">(minumum-jiffy)</span> if negative values are allowed. I still find jiffies difficult to use and avoided them in some recent R7RS time based code.</dd>
        <dt><span class="monospace">SnellPym</span></dt>
        <dd>I agree that wrapping jiffies are useful (and may be forced upon us by the underlying clock mechanism). However, I would also like some support for <span class="monospace">jiffy-modulus</span> to be infinite, as forcing the jiffy counter to be a fixed-width number is unnecessary. Allowing it to return positive infinity would satiate me, I think!</dd></dl>
      <h3 id="#466casefoldingofcharacternames"><a href="/ticket/466">#466</a> case folding of character names</h3>
      <p>In ticket <a href="/ticket/11">#11</a> we voted to make the reader case-sensitive
by default. In ticket <a href="/ticket/92">#92</a> we further added the R6RS
#!fold-case and #!no-fold-case reader extensions. In
both cases the terminology was lax and simply referred
to &quot;reader case sensitivity&quot;, and all discussion centered
around symbols, although in R6RS character names were
also affected.</p>
      <p>Case folding will apply to numeric literals, booleans and
bytevectors regardless, as they do in both R5RS and R6RS.
We need to clarify how character names and the case
folding directives themselves are handled.</p>
      <p>The default is <span class="monospace">r6rs</span>, where character names are case
sensitive by default and folded by the <span class="monospace">#!fold-case</span> flag:</p>
      <p>​http://www.r6rs.org/final/html/r6rs-app/r6rs-app-Z-H-4.html#node_chap_B</p>
      <p>Alternately character names could be made to ignore
the reader directives and always or never fold case.
Never folding case breaks R5RS and earlier compatibility
without any easy workaround.</p>
      <p>These same settings apply to the <span class="monospace">include-ci</span> syntax.</p>
      <ul>
        <li><b>Proposals:</b>
          <ul>
            <li><b>r6rs:</b> character names behave like symbols, directives are sensitive</li>
            <li><b>r6rs+directives:</b> like <span class="monospace">r6rs</span> but directives can also be case-folded</li>
            <li><b>always-fold:</b> like <span class="monospace">r6rs</span> but character names and directives always fold case</li>
            <li><b>never-fold:</b> like <span class="monospace">r6rs</span> but character names and directives never fold case</li></ul></li>
        <li><b>Options:</b> r6rs, r6rs+directives, always-fold, never-fold, undecided</li>
        <li><b>Default:</b> r6rs</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: r6rs</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: r6rs, r6rs+directives, never-fold, always-fold</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: r6rs, r6rs+directives</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: r6rs, always-fold, r6rs+directives, undecided, never-fold</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: r6rs, undecided</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: r6rs, r6rs+directives</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: r6rs</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: r6rs, r6rs+directives, always-fold</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: always-fold, r6rs+directives, r6rs, never-fold</li></ul></li>
        <li><b>Results:</b> <b>r6rs</b>, r6rs+directives, always-fold, never-fold, undecided</li>
        <li><b>Ratios:</b> 8:1, 8:1, 9:0, 9:0</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>I see no reason to deviate from R6RS here.</dd>
        <dt><span class="monospace">Ganz</span></dt>
        <dd>Making case fold directives subject to themselves seems at best weird and at worst paradoxical: I suppose <span class="monospace">#!nO-fOLD-cASE</span> is unspecified but <span class="monospace">#!fOLD-cASE</span> is a valid directive? The very possibility that directives could be interpreted as case-folded forces them to be case-unambiguous anyway, or else the case-folding crowd will have to pick a selected interpretation. I don't think we want to go there. My understanding is that under <span class="monospace">r6rs</span> option nothing prevents an implementation from supporting additional directives with any other case. I see no need to emphasize this possibility, though.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I see no reason to differ from R6RS here.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>It is needless complication to deviate from R6RS in this case.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I can't think of a good reason to diverge from R6RS here.</dd></dl>
      <h3 id="#467Alloweqv?andeq?toreturndifferentanswersonproceduresaswellasintegersandcharacters"><a href="/ticket/467">#467</a> Allow eqv? and eq? to return different answers on procedures as well as integers and characters</h3>
      <p>This proposal stems from <a href="http://lists.r6rs.org/pipermail/r6rs-discuss/2012-July/006405.html">remarks</a> by Alaric Snell-Pym and Will Clinger on the r6rs public mailing list.  If <span class="monospace">eq?</span> is allowed to return <span class="monospace">#f</span> on two procedures when <span class="monospace">eqv?</span> nevertheless returns <span class="monospace">#t</span>, as is already the case for numbers and characters, then more intelligent implementation-specific procedure comparisons using <span class="monospace">eqv?</span> are possible, while still keeping <span class="monospace">eq?</span> simple enough to inline easily.</p>
      <p>Note that this is orthogonal to the question of <a href="/ticket/460">#460</a>, how <span class="monospace">eqv?</span> works on procedures.  There should be little or no backward-compatibility hit for this change.</p>
      <ul>
        <li><b>Proposals:</b>
          <ul>
            <li><b>same:</b> <span class="monospace">eq?</span> and <span class="monospace">eqv?</span> always return the same on procedures, per R5RS and R6RS</li>
            <li><b>different:</b> <span class="monospace">eq?</span> may return <span class="monospace">#f</span> on procedures even when <span class="monospace">eqv?</span> returns <span class="monospace">#t</span> (but not vice versa)</li></ul></li>
        <li><b>Options:</b> same, different, undecided</li>
        <li><b>Default:</b> same</li>
        <li><b>Voters:</b>
          <ul>
            <li><a href="/wiki/WG1BallotCowan">Cowan</a>: different</li>
            <li><a href="/wiki/WG1BallotGanz">Ganz</a>: same, undecided</li>
            <li><a href="/wiki/WG1BallotGleckler">Gleckler</a>: different</li>
            <li><a href="/wiki/WG1BallotHsu">Hsu</a>: undecided, different, same</li>
            <li><a href="/wiki/WG1BallotLucier">Lucier</a>: different</li>
            <li><a href="/wiki/WG1BallotMedernach">Medernach</a>: different</li>
            <li><a href="/wiki/WG1BallotRadul">Radul</a>: undecided</li>
            <li><a href="/wiki/WG1BallotRead">Read</a>: different</li>
            <li><a href="/wiki/WG1BallotShinn">Shinn</a>: undecided, different</li>
            <li><a href="/wiki/WG1BallotSnellPym">SnellPym</a>: different, same</li></ul></li>
        <li><b>Results:</b> <b>different</b>, undecided, same</li>
        <li><b>Ratios:</b> 6:4, 8:1</li>
        <li><b>Rationales:</b></li></ul>
      <dl>
        <dt><span class="monospace">Cowan</span></dt>
        <dd>If it's useful for Will and Larceny, that's good enough for me. This doesn't affect conformance, and is unlikely to affect user code either.</dd>
        <dt><span class="monospace">Gleckler</span></dt>
        <dd>I will defer to Will's long experience in compiler implementation.</dd>
        <dt><span class="monospace">Hsu</span></dt>
        <dd>This seems to be useful, but I am cautious about this.</dd>
        <dt><span class="monospace">Radul</span></dt>
        <dd>It could be reasonable to allow a scenario where eq? compares procedures by location tags and eqv? does something coarser, like alpha renaming. I would, however, strongly object to allowing <span class="monospace"> (let ((x (lambda ...))) (eq? x x)) </span> to evaluate to #f. I do not see any options on this item that I understand to correspond with this, which is the definition of &quot;further discussion&quot;.</dd>
        <dt><span class="monospace">Shinn</span></dt>
        <dd>I understand the desire to separate these two, but need to think about this more.</dd></dl></div></body></html>