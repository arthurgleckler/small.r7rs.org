
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Copyright 2013 by Arthur A. Gleckler. All rights reserved. -->
    <title>SixRejection</title>
    <link href="/trac.css" rel="stylesheet" type="text/css"></head>
  <body>
    <header>This site is a static rendering of the <a href="https://trac.edgewall.org/">Trac</a> instance that was used by <a href="http://scheme-reports.org/2015/working-group-1.html">R7RS-WG1</a> for its work on R7RS-small (<a href="/attachment/r7rs.pdf">PDF</a>), which was ratified in 2013. For more information, see <a href="/">Home</a>. For a version of this page that may be more recent, see <a href="https://github.com/johnwcowan/r7rs-work/blob/master/SixRejection.md">SixRejection</a> in WG2's repo for R7RS-large.</header>
    <ul class="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/ticket/">All tickets</a></li>
      <li><a href="/wiki/">All wiki pages</a></li></ul>
    <h1 class="wiki">Six&shy;Rejection</h1>
    <div class="wiki metadata">
      <div class="author">aag</div>
      <div class="time">2012-02-15 13:10:29</div>
      <div class="version">10<span class="comment">Added clarification about additional layer of parentheses in library forms.</span><a href="/wiki/SixRejection/history">history</a></div>
      <div class="source"><a href="/wiki/SixRejection/10/source.html">source</a></div></div>
    <div class="wiki text">
      <p>These are condensed and anonymized <a href="http://www.r6rs.org/ratification/results.html">objections to R6RS</a> by the people who voted against it, with comments underneath each that show how R7RS meets (or fails to meet) that objection.  Statements about R7RS-large reflect WG votes, but are subject to change.  <b>This document is still being edited.</b>  All errors and misstatements not present in the original comments are Cowan's responsibility.</p>
      <p>The order of the objections given here follows the order of the R7RS-small report as much as possible, which follows the R5RS report as much as possible.</p>
      <p>This document is explicitly a work of R7RS advocacy.  Its purpose is not to attack R6RS, but to explain why people who rejected R6RS at the time of ratification may find R7RS more to their liking (and should therefore vote for it).</p>
      <h2 id="General">General</h2>
      <ul>
        <li>R6RS simultaneously breaks with the Scheme tradition to favor homogeneity and software-engineering appeal and still doesn't go far enough towards becoming a useful engineering tool.
          <ul>
            <li>Dividing R7RS into large and small languages was intended to meet this objection.</li></ul></li></ul>
      <ul>
        <li>Interoperability should not be achieved by demanding that one size fits all.  Requiring all of the many features of R6RS limits the capacity of the implementers to work in small, specialized fields.  Embedded devices immediately come to mind, but other things also come to mind, such as applications that may not desire unicode, libraries, or other pieces.  R6RS removes the aspects of elegant simplicity and limited scope that make Scheme such a great language for teaching. Right now, Scheme is easy to learn, because the core concepts are simple, and they extend outward in reasonable, predictable ways.
          <ul>
            <li>R6RS is about 340% the size of R5RS.  By contrast, R7RS-small is about 50% larger than R5RS, but only the base library is required, and that actually defines fewer names than R5RS.</li></ul></li></ul>
      <ul>
        <li>The change to case-sensitivity flies in the face of Scheme tradition, for little to no benefit.  Existing programs that assumed case-insensitivity will have to be massively overhauled.
          <ul>
            <li>The R7RS <span class="monospace">include/ci</span> library declaration permits case-insensitive code files to be included in modules and main programs without making any changes to the files themselves.</li></ul></li></ul>
      <ul>
        <li>R6RS has simply suffered considerable feature creep and is vastly overspecified and overcomplex. In a word, it is too ambitious (or presumptuous, depending on your point of view). It will make Scheme too much complicated for a gain not worth it.  We should focus on defining vital SRFIs, and that we all agree on portable extensions of Scheme, to implement, say, TCP/IP, non blocking IOs or bindings to a graphical library.
          <ul>
            <li>R7RS-large will consist of a series of optional packages, several of which will be closely aligned with existing SRFIs.</li></ul></li></ul>
      <ul>
        <li>The standard library report gratuitously eschews important and widely-used existing SRFIs such as the SRFI-1 list library in favor of its equivalent incompatible functionality.
          <ul>
            <li>R7RS-small has changed R5RS in small and upward-compatible ways for SRFI-1 compatibility.  SRFI-1 is currently planned to be incorporated into R7RS-large.</li></ul></li></ul>
      <ul>
        <li>Why should features such as, say, byte vectors, enumerations and hash tables should even be included in the RnRS reports in the first place?  The SRFI process has proven itself and works better than the committee process being voted on here.
          <ul>
            <li>Bytevectors are provided because existing code has used strings in the same function, which is unreliable when characters require more than 8 bits.  The other data structures mentioned will be provided in R7RS-large.</li></ul></li></ul>
      <ul>
        <li>R6RS has the goal of making Scheme be like C or Perl: a workable programming language like other programming languages.  This seems reasonable on its face, but Scheme has survived for a long time by not being a programming language like others, but rather by being an oddball: minimally specified, usable for real-world programming only by using numerous implementation-specific features, but ideal for teaching and research.
          <ul>
            <li>R7RS-small retains the qualities mentioned.</li></ul></li></ul>
      <ul>
        <li>It is not clear that R6RS even specifies the right things to make Scheme industrial strength.
          <ul>
            <li>Probably not, by the standards of Java or Python, which come with huge libraries built-in.  The R7RS-large library will be mostly (or perhaps entirely) optional, but an implementation providing them all should have plenty of industrial strength.  Attributes of industrial-strength languages other than convenient libraries, such as static typing and pervasive object-orientation, are highly controversial, and really would produce a language other than Scheme.</li></ul></li></ul>
      <ul>
        <li>Each new large feature (enums, records, conditions, identifier macros, Unicode) are each individually motivated, but all together we end up with a very large ball of mud.  The size of this ball directly impairs one of Scheme's important features from an industrial perspective: its role as a small language suitable for automatic program transformation and other PLT sorts of techniques.
          <ul>
            <li>The design of R7RS should reduce such coupling: no R7RS-small module depends on any other (except that loading makes little sense with neither I/O nor <span class="monospace">eval</span>), and such dependencies in R7RS-large will be minimized.</li></ul></li></ul>
      <ul>
        <li>R6RS gives a fairly low priority to backwards compatibility.  Implementations are evidently expected to provide mechanisms for switching.  There's no incremental update path; each Scheme program must be completely transformed all at once, which effectively means it will never happen.
          <ul>
            <li>Whether or not this is true (and moving code from R5RS to R6RS systems does not appear to be that difficult), R7RS has given very high priority to backwards compatibility.</li></ul></li></ul>
      <ul>
        <li>Modules and <span class="monospace">syntax-case</span> are entirely new and declarative sub-languages fundamentally different from the core language, which has always been imperative.
          <ul>
            <li>True.  However, this is also true of <span class="monospace">syntax-rules</span>, which has been around since R4RS (though non-normative at the time).</li></ul></li></ul>
      <ul>
        <li>The effort required to implement a standard-compliant Scheme becomes much larger than before.  This will discourage future implementers, endangering the diversity that is one of Scheme's present strengths.</li></ul>
      <ul>
        <li>R6RS tries to standardize insufficient compromise solutions for things that are better left unspecified.  R6RS is a misguided attempt to make Scheme more suitable for the mainstream, but effectively does the very opposite by removing the assets that always distinguished Scheme from other dialects: smallness and simplicity.</li></ul>
      <ul>
        <li>R6RS should be *smaller* than R5RS, where some of the required features get moved to optional.</li></ul>
      <ul>
        <li>R6RS mandates too much.  The editors seem to be concerned that there is too much variety in the Scheme world, and propose to eliminate it by making the rulebook thicker.  That is exactly the wrong approach.  Celebrate the variety, and encourage it, so that Scheme implementations can make their own decisions about what is important to them.
          <ul>
            <li>R7RS-small mandates far less; R7RS-large will probably mandate little or nothing.</li></ul></li></ul>
      <ul>
        <li>The Scheme community relies in considerable part on the efforts of individual developers, or small teams of developers, who have to implement these reports -- or who would presumably like to do so if it did not take forever.  I think the Scheme community would be better served by a much smaller language, whose features included the minimum necessary so that the language could easily be extended by loading Scheme source code itself (and perhaps compiling it).
          <ul>
            <li>The smaller base library makes this possible to some extent.  However, Scheme standards have never been about the &quot;minimum necessary&quot;, or procedures like <span class="monospace">length</span> and <span class="monospace">list</span> would never have been provided.  What is more, facilities like sockets can't be layered over a &quot;minimum necessary&quot; core unless that core contains an FFI, which is a large and complex feature.  Sometimes the facade pattern is the Right Thing.</li></ul></li></ul>
      <h2 id="Lexicalsyntax">Lexical syntax</h2>
      <ul>
        <li>A petty irritant for me is the official sanction of square brackets: they are ugly and unhelpful in reading code. They create a very discordant visual rhythm and should be summarily outlawed. Square brackets are a gross violation of the LISP Party Ethic and offending implementers shall be required to submit thorough self-criticism of their motivations and then will be summarily shot. I really mean this.
          <ul>
            <li>No square brackets are defined in R7RS lexical syntax.</li></ul></li></ul>
      <ul>
        <li>There is no convincing evidence of the value of supporting Unicode for program text. That said, the capability of S-expression <span class="monospace">read</span> makes it hard to avoid. The addition of Unicode escapes is ugly.</li></ul>
      <h2 id="Primitiveexpressiontypes">Primitive expression types</h2>
      <ul>
        <li>Why would one aim to nail down so many boundary conditions without also specifying order of argument evaluation?
          <ul>
            <li>Scheme has always provided compilers the freedom to evaluate procedure arguments in any order desired.</li></ul></li></ul>
      <h2 id="Derivedexpressiontypes">Derived expression types</h2>
      <ul>
        <li>The <span class="monospace">when</span> and <span class="monospace">unless</span> forms should not be specified.
          <ul>
            <li>R7RS has added them to the base module.  Many people find them convenient in imperative programs.  However, the return value is now always unspecified, as it cannot be relied on in any case.</li></ul></li></ul>
      <h2 id="Macros">Macros</h2>
      <ul>
        <li>Scheme can live with the R5RS hygienic macros for a while still.
          <ul>
            <li>R7RS-small does live with them.</li></ul></li></ul>
      <ul>
        <li>Identifier syntax is purely syntactic sugar that complicate the semantics of the language.  Identifiers may no longer be simple variable references, making code potentially more difficult to read.  This breaks R5RS compatibility by eliminating a specific invariant on which R5RS programs and macros can rely, namely that a reference to an identifier has no side effects.  It weakens every macro in the entire language by removing knowledge about the language the macros are expanding.  Code-walking macros become more difficult to write.
          <ul>
            <li>Neither R7RS-small nor R7RS-large provides identifier syntax.</li></ul></li></ul>
      <ul>
        <li>The <span class="monospace">syntax-case</span> macro system is an unfortunate choice.  Both syntactic closures and explicit renaming macros are older, and are simpler and more in the spirit of Scheme.  The description of the mark-antimark for the <span class="monospace">syntax-case</span> algorithm significantly lengthens and increases the complexity of this chapter.
          <ul>
            <li>R7RS-small provides only <span class="monospace">syntax-rules</span>.  R7RS-large provides for explicit renaming; additional macro systems may be added.</li></ul></li></ul>
      <ul>
        <li>The R6RS treatment of <span class="monospace">_</span> and <span class="monospace">...</span> patterns.  It's unfortunate that R5RS macros can't match <span class="monospace">...</span> as a literal in templates, but with the same restriction on <span class="monospace">_</span> many existing macros will break, and moreover they have no easy workaround, requiring otherwise simple pattern matching macros to be rewritten in much longer and more convoluted low-level code.
          <ul>
            <li>R7RS-small adopts these conventions of R5RS, but also adopts SRFI 46.</li></ul></li></ul>
      <ul>
        <li>There is no way of importing <span class="monospace">set!</span> for a single level.  The composite library should not export <span class="monospace">define-syntax</span> and <span class="monospace">let[rec]-syntax for level 1</span>, or syntax-rules for level 0.  In the context of the (rnrs) import, there is nothing one can do with these bindings at those levels.
          <ul>
            <li>R7RS-small does not provide phasing, as its only macro system is <span class="monospace">syntax-rules</span>.  The question is still open for R7RS-large.</li></ul></li></ul>
      <ul>
        <li>R6RS links library instantiation and visitation not to import clauses, but instead to the presence of identifier references in the client, and provides no guarantee of instantiation otherwise.
          <ul>
            <li>R7RS requires whatever libraries are imported to be instantiated at least once, but provides no guarantees for or against multiple instantiation.</li></ul></li></ul>
      <ul>
        <li>The <span class="monospace">syntax-case</span> system implements a term-rewriting system, with limited programmability, to solve a problem for which there are significantly simpler solutions.  This sub-language introduces a new kind of variable that behaves differently from the variables we're used to, and pushes pattern-matching and templating to the center of the macro-writing process.</li></ul>
      <h2 id="Programs">Programs</h2>
      <ul>
        <li>R6RS utterly neglects the notions of &quot;top-level program&quot; and &quot;top-level environment&quot;, which are absolutely fundamental to Scheme as a language and a system.
          <ul>
            <li>Both top-level programs and REPLs are part of R7RS, though there is no requirement to provide a REPL.</li></ul></li></ul>
      <ul>
        <li>R6RS moves away from the ability to be used interactively through a REPL by removing <span class="monospace">load</span> and offering only a static linking model for programs.  It does not explain how this affects program development and debugging using a REPL, which is the bread-and-butter of a large number of Scheme users.
          <ul>
            <li>REPLs are rather complex beasts, and probably won't be standardized.  However, R7RS does provide minimal REPL semantics.</li></ul></li></ul>
      <ul>
        <li>The draft recognises libraries, a top-level and scripts, three variants of what is basically the same thing (see Queinnec&amp;Padget: <i>Modules, Macros and Lisp</i>) - not the Scheme way.</li></ul>
      <h2 id="Records">Records</h2>
      <ul>
        <li>The record system is far too complicated.
          <ul>
            <li>R7RS-small provides only a SRFI-9-compatible syntactic record layer.</li></ul></li></ul>
      <ul>
        <li>The constructor-related parts of the syntactic record layer and of the procedural layer are bewilderingly complex.  The custom constructor design is a good example of premature generalization and piling feature upon feature, and their current API adversely affects other aspects of the design, such as modularity.</li></ul>
      <ul>
        <li>The problem of two record systems that don't quite work together.  See Will Clinger's essay <a href="http://www.ccs.neu.edu/home/will/R6RS/essay.txt">&quot;Fixing the Syntactic Record Layer&quot;</a>.
          <ul>
            <li>R7RS-large will probably provide SRFI 99 records or something very like them.</li></ul></li></ul>
      <ul>
        <li>You cannot simply take a record value and access one of its fields by name.  See <a href="http://lists.r6rs.org/pipermail/r6rs-discuss/2007-August/thread.html#3145">http://lists.r6rs.org/pipermail/r6rs-discuss/2007-August/thread.html#3145</a>.  We want a container that requires certain behavior of the values it contains while not requiring that theybe on an approved list or inherit from the same ancestor.  Importing the accessors of each type of value we wish to contain makes the container's import list the approved list.</li></ul>
      <ul>
        <li>Despite the last-minute change in the 5.97 draft that attempted to fix things by piling yet another feature, a parent-rtd clause, on top of the syntactic layer, you <i>still</i> have to know whether the base record type was defined using the syntactic or record layer, and you <i>still</i> can't change a record definition from one layer to the other without running the risk of breaking client code.  Record types defined by the syntactic layer are not interchangeable with record types defined by the procedural layer:  in consequence, the code you write for a record type definition that inherits from some base type depends upon whether that base type was defined using the syntactic or procedural layer.</li></ul>
      <ul>
        <li>Both record-system layers are complex, which makes it hard for a casual reader to understand their relationships.</li></ul>
      <ul>
        <li>The record procedural layer is the more expressive layer, so the draft's new warnings that try to frighten programmers into preferring the syntactic layer would have limited impact even if they were true.</li></ul>
      <h2 id="Libraries">Libraries</h2>
      <ul>
        <li>Scheme needs a simple module system that can be grasped easily.
          <ul>
            <li>Although the R7RS library system has some extensions over the R6RS one, it is also simplified.</li></ul></li></ul>
      <ul>
        <li>There is no need to embed library versions in import specifications. Matching library versions should be solved outside of the language.  Everything done with versions in the current draft could be added in a backwards compatible manner in future drafts.  Also, the version reference syntax is very complex and rather ugly.
          <ul>
            <li>Version numbers are not a feature of R7RS libraries.</li></ul></li></ul>
      <ul>
        <li>The R6RS library mechanism fails to be modular; users must know and exclude from modules any exported redefinitions, whether or not they use those identifiers!
          <ul>
            <li>This continues to be a problem in R7RS.  A ticket has been filed to permit ambiguous imports of unused identifiers.</li></ul></li></ul>
      <ul>
        <li>It is perfectly meaningful to say that if a specific library is implemented, it must meet the entire spec. but <i>all</i> libraries must be optional in a base language and a base language implemener <i>does not</i> have to provide all libraries.
          <ul>
            <li>This is exactly the R7RS approach.</li></ul></li></ul>
      <ul>
        <li>R6RS does not provide unsafe arithmetic or list operations.
          <ul>
            <li>R7RS does not require the safety guarantees of R6RS, leaving the balancing between safety, speed, and other concerns up to the implementation.</li></ul></li></ul>
      <ul>
        <li>The module system is basically a way to tell the linker how to construct programs from parts.  Rather than invent a new language to do this, it's possible to build the linker such that the programmer can insert Scheme code to control aspects of the linking process.  Such code could do <i>more</i> than the current module system does, and because of the added expressivity, it could do so more concisely in many cases.
          <ul>
            <li>The R6RS and R7RS library systems are designed for simplicity and portability to all kinds of existing implementations of modules.  For those purposes, a static system is satisfactory, but doesn't disallow introduction of more complex module systems for other purposes.</li></ul></li></ul>
      <ul>
        <li>Many R6RS features are useful and definitely should be part of the standard, but rather than arbitrarily including them in the language, the should be defined <i>on top of the language</i>.  Only features that are required in order to support the libraries should be carefully added to the language itself.  This approach would lead to a `<span class="monospace">core language'' and a set of </span>`extension libraries'' that is implemented in terms of the core language. These libraries should be optional extensions to the core language.
          <ul>
            <li>While it is not always possible to define R7RS-large packages in terms of the R7RS-small language (i.e. a package supporting TCP connections in the large language cannot be written portably), the overall design of core and extension libraries has been adopted for R7RS.  Some libraries are considered part of the small language, though they are technically optional; the rest belong to the large language.</li></ul></li></ul>
      <ul>
        <li>What is the principled reason why <span class="monospace">assoc</span> and <span class="monospace">memq</span> (for example) are exiled to libraries without bringing along the equally derivative <span class="monospace">append</span>, <span class="monospace">string-for-each!</span>, <span class="monospace">vector-map</span>, and so on; the library system fails to delineate a kernel, which I had thought was one of its goals.
          <ul>
            <li>As noted, the base library is not a kernel.  However, all these procedures are in the R7RS base library.</li></ul></li></ul>
      <ul>
        <li>The reason for ABSOLUTELY prohibiting linking to multiple versions of the same library per formal comment 130 is very weak.  Scheme and the LISP family in general are incisive, powerful languages that give their users great power that can be easily misused.</li></ul>
      <ul>
        <li>Scheme should accommodate the desires of library writers to intermix definitions and expressions [insert usual platitudes about needless restrictions---and how Scheme is perhaps more than anything else a system for communicating to other programmers...].</li></ul>
      <ul>
        <li>The enforced phase separation in the module system described in the R6RS proposal overspecifies the module system and disallows different implementation strategies, thus prohibiting the Scheme community from experimenting and innovating.  In addition, the module system becomes an obstacle to the use of Scheme as a teaching language, because beginners now must deal with it long before it can be explained to them why.
          <ul>
            <li>R7RS-small does not require phase information, because the only macro system is <span class="monospace">syntax-rules</span>, which does not run user-supplied Scheme code at compile time.  (Note that R6RS is not as fully phase-separated as Racket, because while an identifier may be defined or undefined at a given phase, it may not be defined <i>differently</i> at different phases.)  The R7RS-large library system is not yet specified; certainly implicit phasing will be one of the options considered.</li></ul></li></ul>
      <ul>
        <li>R6RS library descriptions need to be enclosed in an additional layer of parentheses, as opposed to a single definition at the top of the file.
          <ul>
            <li>Still true in R7RS.  Libraries remain a single S-expression in R7RS.  However, the =include= form in library declarations makes it possible to load another file inside a module, and that file doesn't require the additional level of parentheses.</li></ul></li></ul>
      <h2 id="Numbers">Numbers</h2>
      <ul>
        <li>It is not clear what problem implicit mantissa widths solve, and they are ill-defined.  Explicit mantissa widths are &quot;additional features&quot;, the need for which should be eliminated by removing restrictions against non-decimal floating-point values.
          <ul>
            <li>Neither implicit nor explicit mantissa widths are provided in R7RS.</li></ul></li></ul>
      <ul>
        <li>Requiring the full numeric tower works against using Scheme in smaller environments such as embedded systems, where full support conflicts with other implementation priorities.
          <ul>
            <li>R7RS-small does not require the full tower.</li></ul></li></ul>
      <ul>
        <li>Procedures such as <span class="monospace">div0-and-mod0</span>, <span class="monospace">exact-integer-sqrt</span> simply do not belong in a base language.  In fact a lot of the numerical procedures belong in a library.
          <ul>
            <li>Integer division has been moved to a library in R7RS, as have the transcendental and complex number procedures (the latter primarily because inexact and non-real numbers are not required in R7RS).</li></ul></li></ul>
      <ul>
        <li>Given that fixnum and flonum types have implementation dependent ranges, there is no need to require fixnum and flonum types in the standard.
          <ul>
            <li>These types are not present in R7RS-small.  Flonum and fixnum packages will be provided in R7RS.</li></ul></li></ul>
      <ul>
        <li>Scheme is best served by retaining its jewel-like character: tiny, beautiful and perfect.  There is no need to expand Scheme as the editors propose -- if I want Common Lisp, I know where to find it.
          <ul>
            <li>It's debatable whether the exact set of procedures provided in R5RS is really so jewel-like or perfect.  Certainly there were many, if small, changes from R2RS to R5RS.</li></ul></li></ul>
      <h2 id="Pairs">Pairs</h2>
      <ul>
        <li>Immutable pairs may make optimization easier, but do not fit at all with the practice and spirit of Lisp.
          <ul>
            <li>They aren't provided in R7RS-small.</li></ul></li></ul>
      <h2 id="Characters">Characters</h2>
      <ul>
        <li>Implementations should be allowed to support characters beyond Unicode.
          <ul>
            <li>R7RS permits such characters, though we don't expect to see widespread implementation of them.</li></ul></li></ul>
      <ul>
        <li>Scheme has been around for a long time, and has seen many encodings come and go - there's no reason to bind it to a single encoding forever.
          <ul>
            <li>R7RS does not require more than the ASCII repertoire to be supported, but does require Unicode conformance in case mapping, char-integer conversion, etc.</li></ul></li></ul>
      <ul>
        <li>Character-level case mappings encourage programmers to write broken algorithms.
          <ul>
            <li>Unfortunately, they are an IEEE Scheme feature and can't easily be removed.</li></ul></li></ul>
      <ul>
        <li>It is perhaps better to remove those features of R5RS that prohibit Unicode implementation (such as <span class="monospace">char-&gt;integer</span> and <span class="monospace">integer-&gt;char</span>), and rely on extended SRFI-13 and SRFI-14 for Unicode support.
          <ul>
            <li>Actually those features aren't problematic for Unicode.</li></ul></li></ul>
      <h2 id="Strings">Strings</h2>
      <ul>
        <li>The normalization procedures handle normalization at the wrong level.  It's inherently an encoding issue, and is best treated as such.  Providing this functionality at the string level forbids the implementation strategy of keeping all strings in the same normalization form - a very appealing strategy on many levels.
          <ul>
            <li>R7RS-small provides normalized comparison procedures rather than normalization procedures.</li></ul></li></ul>
      <ul>
        <li>O(1) string access suggests that all Schemes should use UCS-4 character vectors for their string representation, discouraging the use of alternate representations such as UTF-8 and ropes or trees.
          <ul>
            <li>R7RS does not prescribe O(1) access time for strings.</li></ul></li></ul>
      <ul>
        <li>There are competing character sets that may be preferable to Unicode in some circumstances, and requiring Unicode would forestall their use.  Unicode necessarily requires more storage space than ASCII, and more complicated runtime support, which may not be desirable in all cases.
          <ul>
            <li>Any encoding may be used internally to an implementation, provided that it covers at least the ASCII repertoire.</li></ul></li></ul>
      <h2 id="Vectors">Vectors</h2>
      <ul>
        <li>There is nothing to indicate that the editors ever considered the inclusion of multidimensional arrays, even though they are the subject of SRFI-25, SRFI-47, SRFI-58, and SRFI-63, and portably supported by SLIB.
          <ul>
            <li>R7RS-large will include multidimensional arrays, though the exact form they will take is not yet known.</li></ul></li></ul>
      <h2 id="Bytevectors">Bytevectors</h2>
      <ul>
        <li>The fact that bytevectors are, by their nature, type aliasing nightmares is too lightly ignored in the draft.  Making these the basic implementation strategy of homogenous vectors makes it harder for Scheme systems that compile to C for portability to implement homogeneous vectors efficiently, due to the C aliasing rules.  IEEE-754 does <i>not</i> specify the bit patterns for single- and double-precision floating-point numbers in a way that this report seems to think can be exploited in bytevectors.
          <ul>
            <li>R5R5-small only provides 8-bit facilities.  There is a R7RS-large proposal on the table that provides other types (s8, u16, s16, floats, etc.) in both homogeneous and heterogenous styles.</li></ul></li></ul>
      <ul>
        <li>The core language must only include the abstract vector type. Having particular types of vector representations is precisely the domain of SRFIs. The R6RS proposal byte vector syntax is not widely agreed upon, and it requires two sets of vector procedures in the core language.
          <ul>
            <li>R7RS does provide bytevectors in the base.  The lexical syntax provided is SRFI-4-compatible rather than R6RS-compatible.</li></ul></li></ul>
      <ul>
        <li>Strings always were a bit sore in Scheme, with their manifestly-typed locations.  Instead of solving that, this draft adds bytevectors.  Neither can contain variables in the right-hand side of a syntax rule - the kind of arbitrary restriction of which Scheme should be free.
          <ul>
            <li>If you want generic vectors, you know where to find them.  Strings are often not used as containers, but as immutable values, and this is even more true in a Unicode world.</li></ul></li></ul>
      <ul>
        <li>R6RS does not provide homogeneous numeric vectors.  The suggestion is made in the rationale that bytevectors plus sealed and opaque types can lead to efficient implementations of them.  This assumes the existence of a &quot;suitably smart compiler&quot;.</li></ul>
      <h2 id="Multiplevalues">Multiple values</h2>
      <ul>
        <li>Multiple-return values *still* has not been fixed. The most straightforward solution is simply to make all continuations multi-valued - or rather that applying a single-argument continuation to multiple values results in the coercion of the actual arguments to some list form.  It would actually be even better to eliminate multi-valued continuations entirely, but that would be at the cost of breaking existing code (SRFI code even).
          <ul>
            <li>Treating multiple values in this way requires checks and coercions every time a non-singular value is passed to a continuation expecting one value, which is almost all the time.  Leaving the behavior undefined allows avoiding such coercions and potentially the checks as well.</li></ul></li></ul>
      <h2 id="Dynamicenvironment">Dynamic environment</h2>
      <ul>
        <li>It has been clearly shown that <span class="monospace">dynamic-wind</span> (and R5RS <span class="monospace">call/cc</span>) is implementable in terms of R4RS <span class="monospace">call/cc</span>, but that the reverse is not true. Given the renaming facilities available in the library system, it would seem <i>really</i> obvious that R4RS <span class="monospace">call/cc</span> should be in the core and R5RS <span class="monospace">dynamic-wind</span> and <span class="monospace">call/cc</span> should be a separate library.
          <ul>
            <li>R7RS provides R5RS <span class="monospace">call/cc</span> and <span class="monospace">dynamic-wind</span> in the core.</li></ul></li></ul>
      <ul>
        <li>The Scheme specification needs a solid model for asynchronous events.
          <ul>
            <li>R7RS-large may have something like this.</li></ul></li></ul>
      <h2 id="Errors,exceptionsandconditions">Errors, exceptions and conditions</h2>
      <ul>
        <li>Far too much of R6RS appears fixated on defining and punishing syntactic errors.
          <ul>
            <li>R7RS sticks with &quot;is an error&quot;, as R5RS and earlier versions did.  This allows implementations to choose how to handle syntactic and most other errors.</li></ul></li></ul>
      <ul>
        <li>The exception system is far too large and over-specified. Implementations should be free to experiment with extensions in these areas.  The division into simple and compound conditions, along with the infrastructure required to manipulate these, is overly complex and may be awkward to use in practice.
          <ul>
            <li>R7RS-small provides the R6RS <i>exception</i> system, but not the <i>condition</i> system; any Scheme object can be signalled (as is also true in R6RS).</li></ul></li></ul>
      <ul>
        <li>The exception/condition functionality <i>should</i> be part of the core specification - as is shown by the inclusion of a section on exceptions in the formal semantics.
          <ul>
            <li>R7RS exception signaling and handling are in the base library.</li></ul></li></ul>
      <ul>
        <li>The R5RS report used the phrase &quot;an error is signalled&quot; to indicate that implementations must detect and report an error, without going into specifics. In contrast, the R6RS proposal requires the signaling of exceptions, and it goes further to propose a complex and very specific hierarchy of exceptions. Once again, common practices in the Scheme community are ignored, and instead of relying on the SRFI process, exceptions are mandated in the core language.
          <ul>
            <li>R7RS-small follows R5RS.</li></ul></li></ul>
      <ul>
        <li>All condition types should be record types, and compound conditions should be eliminated.
          <ul>
            <li>R7RS-small has no specific condition types or hierarchy.  It's not clear yet what will happen in R7RS-large.</li></ul></li></ul>
      <ul>
        <li>Exceptions are an unfortunate (if understandable) addition.
          <ul>
            <li>It's not clear whether this refers to exception signaling, exception handling, or the condition hierarchy.</li></ul></li></ul>
      <h2 id="I/O">I/O</h2>
      <ul>
        <li>The I/O system was totally rewritten for no reason, and all aspects of it are controlled with gratuitous syntactic forms - second class forms which discourage high-level procedures.
          <ul>
            <li>R7RS-small provides only R5RS I/O plus a close parallel of it for binary I/O.  R7RS-large will have a more complex I/O package, but its content is not yet defined.</li></ul></li></ul>
      <ul>
        <li>R6RS I/O is lacking support for PGM/PPM files, open TCP sockets, and other features.
          <ul>
            <li>R7RS-large will have a TCP package.</li></ul></li></ul>
      <ul>
        <li>All but fundamental I/O primitives should be put in a library: non-abstract operations do not belong in the core language.
          <ul>
            <li>In both R6RS and R7RS, there is no I/O in the R7RS base library at all.</li></ul></li></ul>
      <h2 id="Enumerations">Enumerations</h2>
      <ul>
        <li>There's simply no reason for enumerations, since Scheme has traditionally used symbols for the same purpose.  It is an example of premature generalization and piling feature upon feature.
          <ul>
            <li>Enumerations are not in R7RS-small; the R7RS-large situation is still open.</li></ul></li></ul>
      <h2 id="FFI">FFI</h2>
      <ul>
        <li>R6RS is not good enough for commericial usage since it lacks a FFI to interface it with libraries implented in C/C++, and it specifies too much for an experimental language.  Neither fish nor fowl.
          <ul>
            <li>The R7RS-large WG decided not to attempt to specify a standard FFI.</li></ul></li></ul>
      <h2 id="Hashtables">Hash tables</h2>
      <ul>
        <li>The core specification must not mandate any particular standard for dictionary structures, as the existing implementations vary widely in APIs. A side effect free association list structure may be permitted, but anything more sophisticated must be relegated to a library.
          <ul>
            <li>R7RS, like R5RS, has the traditional <span class="monospace">assoc</span> and friends, enhanced to allow any equivalence predicate.  Of course, such association lists are not inherently immutable.</li></ul></li></ul>
      <ul>
        <li>The standard library report gratuitously eschews important and widely-used existing SRFIs such as tSRFI-69 hash tables in favor of its equivalent incompatible functionality.
          <ul>
            <li>Partly because the WG could not agree on the appropriate API, R7RS-small does not provide hash tables, though they are present in almost every major Scheme implementation.</li></ul></li></ul>
      <ul>
        <li>Hash tables, while useful, are not necessary (after all, other equally useful data structures were not added).
          <ul>
            <li>They will be provided in R7RS-large, though the exact API is as yet undecided.</li></ul></li></ul>
      <h2 id="Formalsemantics">Formal semantics</h2>
      <ul>
        <li>The operational semantics for the proposed R6RS is nowhere near as clean and succinct as the denotational semantics for R5RS. Considerations of their non-normativeness aside, the denotational semantics presented, in a couple of pages, a clear formalization of the basis of Scheme.
          <ul>
            <li>The R5RS denotational semantics has been retained unchanged.</li></ul></li></ul>
      <h2 id="Process">Process</h2>
      <ul>
        <li>It would be regrettable if something becomes a standard because &quot;we didn't have time to come up with a better [idea] by the last couple of days&quot;.
          <ul>
            <li>The R7RS process has encouraged continuous feedback throughout the development process, which has taken place entirely in the open.</li></ul></li></ul>
      <ul>
        <li>Several features specified in R6RS have been tested in existing implementations of Scheme insufficiently to warrant inclusion in the standard.  Some features of the draft, such as the I/O system and records, are completely new and clearly suffer from feature creep.  The standard is not the place to experiment.
    * The WG agrees in general; almost all the syntax and procedures of R7RS are already widely available in Scheme implementations, with the exception of the library system, which is very close to (but simplified from) the R6RS system.</li>
        <li>The jump from R5RS to R6RS is too big for its users (implementers and other programmers) to digest all at once, and has not set a good example for R7RS.  To make sure we all continue communicating and learning from one another, the revision process needs to be more open and incremental in the future, I think.
          <ul>
            <li>The R7RS process has been much more open (everything has been done in public, and informal comments from the public have been accepted throughout the process), and its changes to R5RS are quite incremental.  We believe that it will be straightforward to implement R7RS on any R5RS system that already has some sort of modules, and on any R6RS system.</li></ul></li></ul>
      <ul>
        <li>The current thrust of Scheme development raises a concern that the language will go the way of C++, which seems to have given rise to a large variety of mutually nearly incomprehensible C++ dialects and programming styles, and to a great deal of confusion about what the various features are supposed to do.
          <ul>
            <li>This is rather speculative.</li></ul></li></ul>
      <ul>
        <li>We want to experiment and innovate, and the purpose of standardization is the exact opposite: to prevent experimentation and innovation. The objective of standardization is to get it right on the first try, to allow long term stability and interoperability, when the benefits of such outweigh the benefits of innovation.
          <ul>
            <li>Experimentation and innovation are among the purposes of R7RS-small.</li></ul></li></ul>
      <ul>
        <li>The goal in R6RS should be to make it easier to achieve conformance <i>and</i> easier to experiment without getting the pedants' backs up. A good standards document helps the documentation effort.
          <ul>
            <li>The small base library makes conformance straightforward, if not necessarily easy.  The other libraries must be provided in full if they are provided at all, which also makes conformance straightforward.</li></ul></li></ul>
      <ul>
        <li>R6RS will likely create a schism between the various scheme implementations, because it ignores the desires of parts of the community, in order to cater to some others. Scheme can't operate under the assumptions of one-size fits all, because the Scheme community is naturally already heavily invested in areas where divergence (to some degree) is encouraged.
          <ul>
            <li>The WG agrees.  Hopefully R7RS will see wider take-up among the implementer community.</li></ul></li></ul>
      <ul>
        <li>If R6RS fails, the next attempt should be <i>in the direction</i> of previous revised reports in requiring unanimous consent <i>for the core</i> (which includes the library mechanism, but precious few libraries).  Therefore the process in the future must continue to require super-majorities for core ratification and maybe even greater ones than the current 60% -- and that helps to properly draw the line between it and the required standard libraries.  Library ratification does not need to be as strict: as long as they are &quot;acceptable&quot; and have nothing dreadfully wrong with them, it is better to have usable standards than no standards at all, and in theory the SFRI process has allowed the community to discover what works in practice and is worth standardizing.
          <ul>
            <li>This is roughly what the R7RS process is doing.  The current threshold is 85% to ratify R7RS-small, 75% to ratify R7RS-large.</li></ul></li></ul>
      <h2 id="Performance">Performance</h2>
      <ul>
        <li>R6RS puts too much emphasis on performance.  Is R5RS Scheme so slow that we need to introduce into the standard immutable variables, fields, and pairs?  I am all for speed, but not at the expense of inconsistencies in the language design.  Immutability hinders debugging and &quot;live-repair&quot;, and goes against the basic design principles of Scheme.
          <ul>
            <li>R7RS has only the immutability of R5RS; that is, literal constants are immutable, but implementations are not required to detect attempts to mutate them.</li></ul></li></ul></div></body></html>