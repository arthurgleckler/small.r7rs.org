
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Copyright 2013 by Arthur A. Gleckler. All rights reserved. -->
    <title>WG1BallotGanz</title>
    <link href="/trac.css" rel="stylesheet" type="text/css"></head>
  <body>
    <header>This site is a static rendering of the <a href="https://trac.edgewall.org/">Trac</a> instance that was used by <a href="http://scheme-reports.org/2015/working-group-1.html">R7RS-WG1</a> for its work on R7RS-small (<a href="/attachment/r7rs.pdf">PDF</a>), which was ratified in 2013. For more information, see <a href="/">Home</a>. For a version of this page that may be more recent, see <a href="https://github.com/johnwcowan/r7rs-work/blob/master/WG1BallotGanz.md">WG1BallotGanz</a> in WG2's repo for R7RS-large.</header>
    <ul class="navigation">
      <li><a href="/">Home</a></li>
      <li><a href="/ticket/">All tickets</a></li>
      <li><a href="/wiki/">All wiki pages</a></li></ul>
    <h1 class="wiki">WG1Ballot&shy;Ganz</h1>
    <div class="wiki metadata">
      <div class="author">steven_ganz</div>
      <div class="time">2011-01-16 18:51:29</div>
      <div class="version">2<span class="comment"></span><a href="/wiki/WG1BallotGanz/history">history</a></div>
      <div class="source"><a href="/wiki/WG1BallotGanz/2/source.html">source</a></div></div>
    <div class="wiki text">
      <p>Instructions
You may list as many of the options as you want in order of preference.
Options are comma-delimited (ignoring space) and case-insensitive.
You can pipe-delimit (|) options you want to give equal weight to.
You may write in your own option if you announce it to the list first.
You may specify a variant with option/variant, for example srfi-1/module to vote for srfi-1 but clarify it should be in a separate module. Please also include the srfi-1 option in this case.
You can write a free-form rationale after the &quot;preferences&quot; line,
module means &quot;yes, but I want it in a separate module&quot;,
wg2 means &quot;no, but I think it should go in WG2&quot;.
undecided means I want to discuss this issue further.
Abstain on any item by leaving the preferences blank.
WG1 Ballot Items To Finalize By Jan. 9
WG1 - Core</p>
      <p><a href="/ticket/32">#32</a> user-defined types</p>
      <p>Do we support any means of creating disjoint user-defined types, such as in SRFI-9, SRFI-99 or the R6RS record system?</p>
      <p>Proposals:
cowan: <a href="/wiki/RecordsCowan">RecordsCowan</a>
hsu: <a href="/wiki/RecordsArcfide">RecordsArcfide</a>
medernach: <a href="/wiki/AggregatesMedernach">AggregatesMedernach</a>
rush: <a href="/wiki/UserAggregatesRush">UserAggregatesRush</a>
snellpym: <a href="/wiki/UniqueTypesSnellPym">UniqueTypesSnellPym</a>
Options: srfi-9, srfi-57, srfi-99, r6rs, cowan, hsu, medernach, rush, snellpym, none, wg2, undecided
Default: none
Preferences:
<a href="/ticket/50">#50</a> byte-vectors</p>
      <p>Several SRFIs, R6RS, and most Scheme implementations support some sort of uniform packed integer vectors. In particular, these are necessary for efficient binary I/O, and for memory mapping, so WG2 will certainly want them.</p>
      <p>Do we provide a syntax and basic API for these in WG1?</p>
      <p>Proposals:
r6rs:  R6RS byte-vectors
cowan: <a href="/wiki/BlobAPI">BlobAPI</a>
snellpym: <a href="/wiki/BlobsAndSRFI4SnellPym">BlobsAndSRFI4SnellPym</a>
Options: r6rs, cowan, snellpym, wg2, none, undecided
Default: none
Preferences:
<a href="/ticket/55">#55</a> Lazy evaluation</p>
      <p>R5RS provides a simple mechanism for easy cases of lazy evaluation. It does not support generalized lazy evaluation, because all built-in procedures are eager whether they 'need' to be or not. The relevant identifiers are delay and force; they are not present in IEEE Scheme. SRFI 45 argues that this pair is insufficient for expressing common lazy algorithms in a way that preserves tail recursion, and adds lazy (equivalent to (delay (force ...)), but acting atomically) and eager. The semantics of delay and force remain downward compatible.</p>
      <p>Vote srfi-45 to add just the bindings lazy and eager in addition to delay and force, not all of the srfi-45 utilities. Vote none to remove delay and force from the standard.</p>
      <p>Options: r5rs, srfi-45, none, wg2, undecided
Default: r5rs
Preferences:
<a href="/ticket/57">#57</a> Random Numbers</p>
      <p>Random numbers are useful for a wide variety of applications, including cryptography, statistics, games, simulations and genetic programming. Do we want to provide an interface to random number generation in WG1 Scheme?</p>
      <p>Proposals:
srfi-27:  SRFI-27
cl: <a href="/wiki/RandomnessCommonLisp">RandomnessCommonLisp</a>
cowan: <a href="/wiki/RandomCowan">RandomCowan</a>
hsu: <a href="/wiki/RandomnessArcfide">RandomnessArcfide</a>
Options: srfi-27, cl, cowan, hsu, none, wg2, undecided
Default: none
Preferences:
<a href="/ticket/62">#62</a> Environment Variables</p>
      <p>Currently, there is no standard way to communicate with the context from which a Scheme program was started. This has become pretty standardized over time: a list of strings (&quot;command-line arguments&quot;) and a map from strings to strings (&quot;environment variables&quot;) on input, and a small integer or string on output (&quot;exit value&quot;). Scheme should recognize these realities.</p>
      <p>We have command-line and exit from <a href="/wiki/ModulesShinn">ModulesShinn</a>, so the question remains if we should add SRFI-98 environment accessors.</p>
      <p>Options: srfi-98, none, wg2, undecided
Default: none
Preferences:
<a href="/ticket/68">#68</a> &quot;Undefined value&quot; vs. &quot;undefined values&quot;</p>
      <p>In R5RS, many procedures and syntax forms return an &quot;undefined value&quot;. In R6RS, the corresponding convention is to return &quot;undefined values&quot;, meaning an undefined number (including zero) of undefined values. How shall R7RS go?</p>
      <p>Vote r5rs for a single undefined value, r6rs for zero or more undefined values, or zero for exactly zero values. Anything other than r5rs would break R5RS (and IEEE) compatibility.</p>
      <p>Options: r5rs, r6rs, zero, undecided
Default: r5rs
Preferences:
<a href="/ticket/49">#49</a> Undefined value API</p>
      <p>Assuming a single &quot;undefined&quot; value (dependent on the result of <a href="/ticket/68">#68</a>), users sometimes want to test for this value. If we enforce a unique undefined value, one approach is to generate this value explicitly to test against, such as (void) provided by some implementations. Alternately we could provide a test such as undefined?. Either approach breaks compatibility with existing extensions, and may be prohibitively difficult to implement for compilers lacking a separate undefined value type. Some programmers also consider testing for this value sign of a broken design.</p>
      <p>Vote generate for a (void) procedure, test for undefined?, and both for both.</p>
      <p>Options: generate, test, both, none, wg2, undecided
Default: none
Preferences:
<a href="/ticket/51">#51</a> support for cyclic structures in primitives</p>
      <p>list?, length, equal? and other fundamental primitives may diverge when given cyclic data. In the former two cases, avoiding this is simple and not inefficient, and the equivalents are already provided in SRFI-1. In the latter case a  proposal was made and rejected on the R6RS list. In the former case, R6RS seems to require list? return #f and length raise an error.</p>
      <p>Do we want to specify the behavior when these primitives encounter cyclic data?</p>
      <p>Options are equal? to specify equal? must terminate on cyclic input, r6rs to specify R6RS behavior for list? and length, srfi-1 to specify the SRFI-1 semantics (where length returns #f) and equal?+r6rs or equal?+srfi-1 are options for both.</p>
      <p>Proposals:
equal?: equal? is required to do proper checks for cyclic structure to not diverge
r6rs: list? should return #f and length raise an error for cyclic lists
srfi-1: length is equivalent to length+ and returns #f for a cyclic list
Options: equal?,r6rs,srfi-1,equal?+r6rs,equal?+srfi-1,no,module,wg2,undecided
Preferences:
<a href="/ticket/69">#69</a> Dynamic <a href="/wiki/Parameters">Parameters</a></p>
      <p>Old-fashioned Lisps used dynamic extent of variables. Although Scheme has switched to lexical scope, the concept of a dynamic environment can be useful in special cases.</p>
      <p>Instead of special variables, SRFI-39 provides first-class &quot;parameter&quot; objects with dynamic bindings. Do we want to provide something similar?</p>
      <p>Proposals:
srfi-39:  SRFI-39
cowan: <a href="/wiki/ImmutableParametersCowan">ImmutableParametersCowan</a>
snellpym: <a href="/wiki/ParametersSnellPym">ParametersSnellPym</a>
Options: cowan, snellpym, srfi-39, none, wg2, undecided
Default: none
Preferences:
<a href="/ticket/70">#70</a> accessing the system time</p>
      <p>Short of a full time and date library, a single procedure</p>
      <p>(current-seconds)</p>
      <p>returning the epoch time in seconds, possibly as a real number, would be useful and is sufficient to implement a full library (though access to the host system's timezone would be desirable in that case).</p>
      <p>Since some systems may not have access to a clock, we could make this an optional procedure. Alternately, it could be defined as a simple counter in such cases, providing an accurate notion of time ordering but no sense of duration. Finally, it could return #f in the absense of a clock.</p>
      <p>Proposals:
cowan: <a href="/wiki/TimeCowan">TimeCowan</a>
required: (current-seconds) must return seconds since epoch
optional: (current-seconds) is an optional procedure
counter: (current-seconds) may just be a counter, returning 0, 1, 2, ...
return-false: (current-seconds) may return #f if unsupported
Options: cowan, required, optional, counter, return-false, none, wg2, undecided
Default: none
Preferences:
<a href="/ticket/109">#109</a> elapsed time</p>
      <p>Should we have functions allowing a program to compute elapsed time, as distinct from calendar time?</p>
      <p><a href="/wiki/TimeCowan">TimeCowan</a> contains a proposal.</p>
      <p>Options: cowan, yes, no, wg2, undecided
Default: no
Preferences:
<a href="/ticket/78">#78</a> Should we have case-lambda?</p>
      <p>Should we provide case-lambda as in SRFI 16 and R6RS? It provides simple overloading of procedures based on the number of their arguments, and does not require that optional arguments appear only after mandatory ones.</p>
      <p>Options: yes, no, module, wg2, undecided
Default: no
Preferences:
<a href="/ticket/82">#82</a> missing port? procedure</p>
      <p>It's not clear whether R5RS requires a PORT? procedure or not. It's listed in Section 3.3.2 under Disjointness of Types, but not under section 6.6.1 under Ports. R6RS requires it. Racket, Gauche, MIT Scheme, Gambit, Chicken, Guile, SISC support it; Scheme48/scsh, Kawa, and Chibi currently do not.</p>
      <p>Shall we require it?</p>
      <p>Options: yes, no, module, wg2, undecided
Default: no
Preferences:
<a href="/ticket/107">#107</a> port status detection</p>
      <p>Currently there's no way to determine whether a port is open or closed, short of trying to read/write to it and catching an error. Do we want to add an interface to this?</p>
      <p>Options: port-open?, port-closed?, both, no, wg2, undecided
Default: no
Preferences:
<a href="/ticket/87">#87</a> Allow multiple producers in call-with-values</p>
      <p>In R5RS and R6RS, call-with-values takes two arguments, both procedures. The first is a producer of multiple values; the second is a consumer, to which the multiple values returned by producer are passed as arguments.</p>
      <p>A possible extension is to allow multiple producer arguments, flattening all the produced values together, analogous to Common Lisp's multiple-value-call.</p>
      <p>Do we add this extension?</p>
      <p>Options: yes, no, wg2, undecided
Default: no
Preferences:
<a href="/ticket/88">#88</a> SRFI 87: =&gt; in CASE</p>
      <p>SRFI-87 extends case with a =&gt; clauses, analogous to the use of =&gt; in cond clauses, which allows you to pass the item actually matched to a procedure.</p>
      <p>Do we add this extension?</p>
      <p>Options: yes, no, wg2, undecided
Default: no
Preferences:
<a href="/ticket/89">#89</a> SRFI 61: COND =&gt; with generator and guard</p>
      <p>SRFI-61 extends =&gt; clauses in cond with an optional guard form, such that after the value is generated and found to be true, it's further checked against the guard. If the guard returns #f the clause fails and processing proceeds to the next clause, otherwise the clause is accepted as normal.</p>
      <p>Do we add this extension?</p>
      <p>Options: yes, no, wg2, undecided
Default: no
Preferences:
<a href="/ticket/90">#90</a> Multiple values in COND =&gt; clauses</p>
      <p>Currently, =&gt; clauses in cond accept a single value from the generator (right-hand side) and pass it to the receiver (left-hand side). Shall we allow the generator to return multiple values and pass them to the receiver? If both this ticket and <a href="/ticket/89">#89</a> pass, multiple values would also be allowed for generator/guard cond clauses.</p>
      <p>Options: yes, no, wg2, undecided
Default: no
Preferences:
<a href="/ticket/91">#91</a> INCLUDE at the REPL</p>
      <p>Should we allow (include &quot;<i>filename</i>&quot;) at the REPL? This is distinct from import in that it just loads code without altering the module structure.</p>
      <p>Options: yes, no, wg2, undecided
Default: no
Preferences:
<a href="/ticket/92">#92</a> Case-folding flags</p>
      <p>The default reader in R7RS will default to case-sensitive, but users may wish to override this in some situations. R6RS allows at the top-level #!case-fold and #!no-case-fold read syntax to control the case-sensitivity of the current file. Many existing R5RS implementations, on the other hand, use #ci and #cs, with the difference that they refer to the next datum only.</p>
      <p>Note <a href="/wiki/PortsCowan">PortsCowan</a> provides a separate means of controlling case-sensitivity per-port.</p>
      <p>Vote per-datum for the next-datum-only #ci/#cs syntax.</p>
      <p>Options: r6rs, per-datum, none, wg2, undecided
Default: none
Preferences:
<a href="/ticket/116">#116</a> Source File Character Encoding</p>
      <p>The standard currently says nothing about the character encoding system of source files. Do we require this to be a fixed encoding such as UTF-8, use an out-of-band specification like the Emacs (and Python) -*- coding: foo -*- convention, or just leave it unspecified?</p>
      <p>Options: utf-8, emacs, unspecified, undecided
Default: none
Preferences:
<a href="/ticket/93">#93</a> Removing string mutability</p>
      <p>R6RS relegated string-set! to a module, and many modern languages tend towards making strings immutable. Removing entirely, however, breaks IEEE Scheme compatibility and should only be considered if you believe mutable strings are fundamentally broken.</p>
      <p>Do we remove string-set!? Vote yes to remove, module to relegate to a module as in R6RS, or no to keep as is.</p>
      <p>Options: yes, no, module, undecided
Default: no
Preferences:
<a href="/ticket/83">#83</a> Auxiliary <a href="/wiki/Keywords">Keywords</a></p>
      <p>In R6RS auxiliary keywords (such as else in cond and case forms) are explicitly exported from the (rnrs base (6)) library. Do we want to bind and export these from the core library?</p>
      <p>If else is bound in the default module, then it must be imported at the call site whenever using it in cond or it won't match hygienically.</p>
      <p>If else is not bound in the default module, then it must not be bound or imported at the call site whenever using it in cond or it won't match hygienically.</p>
      <p>Another option is to specify for cond and case that they match the else identifier literally, ignoring any hygiene. This breaks compatibility with R5RS and R6RS.</p>
      <p>Options: bound, unbound, unhygienic, undecided
Preferences:
<a href="/ticket/101">#101</a> exactness and eqv?/equal?</p>
      <p>In R5RS eqv?/equal? are in some sense the broadest tests for equality, comparing structural equality, but also tests for the same exactness, so that</p>
      <p>(equal? 0 0.0) =&gt; #f</p>
      <p>whereas</p>
      <p>(= 0 0.0) =&gt; #t</p>
      <p>Some users consider this confusing, others sometimes want an equal? that behaves like = for numbers.</p>
      <p>Do we want to change equal? and eqv? in this way, or add a separate exactness-agnostic procedure? Vote yes to change, equal=? or inexact-equal? for separate procedures of those names (plus the analogous eqv=? or inexact-eqv?), or no to leave as is. Alternately, write in a separate name.</p>
      <p>Options: yes, equal=?, inexact-equal?, no, wg2, undecided
Default: no
Preferences:
<a href="/ticket/102">#102</a> module syntax name</p>
      <p>A bikeshed color issue, we need to choose the actual names for the module syntax for the winner of <a href="/ticket/2">#2</a>.</p>
      <p>import, export and include are fairly universal and no alternate is suggested unless someone wants to write in a proposal.</p>
      <p>The enclosing syntax can be called either library as in R6RS, module or some other proposal.</p>
      <p>Options: library, module, undecided
Default: library
Preferences:
<a href="/ticket/103">#103</a> module body syntax name</p>
      <p>Similar to <a href="/ticket/102">#102</a>, we need to choose a name for the form to include Scheme code directly in a module form. This can be body as in the proposal, begin or some other name.</p>
      <p>Options: body, begin, scheme, code, undecided
Default: body
Preferences:
<a href="/ticket/105">#105</a> case-insensitive module includes</p>
      <p>The include module form includes files literally with the default case-sensitivity. An include-ci form could include files case-insensitively without resorting to the reader hacks proposed in <a href="/ticket/92">#92</a>, allowing existing R5RS libraries to be used without modification.</p>
      <p>Options: yes, no, wg2, undecided
Default: no
Preferences:
<a href="/ticket/106">#106</a> conditional code selection</p>
      <p>Users invariably want some way to conditionally select code depending on the implementation and/or feature set available. <a href="/wiki/CondExpandCowan">CondExpandCowan</a> allows conditional expansion in the style of SRFI-0 within the module language.  SRFI-0 provides cond-expand,  SRFI-103 provides a library naming extension, and numerous other personal hacks exist.</p>
      <p>Do we want to include something along these lines in WG1 Scheme?</p>
      <p>Proposals:
cowan: <a href="/wiki/CondExpandCowan">CondExpandCowan</a>
srfi-0: cond-expand only defined as a top-level module form
srfi-103: the search path extension used by R6RS implementations
Options: cowan, srfi-0, srfi-103, none, wg2, undecided
Default: none
Preferences:
<a href="/ticket/108">#108</a> immutable data interface</p>
      <p>R5RS specifies literal data in source code as immutable, but otherwise provides no way to generate or introspect immutable data.</p>
      <p>One proposal is given in <a href="/wiki/ImmutableData">ImmutableData</a>, providing mutable?, make-immutable and immutable-&gt;mutable.</p>
      <p>Racket, for which all pairs are immutable in the default language, needs some way to generate shared and cyclic data structures at runtime, and provides the shared syntax for this. It also has an immutable? utility as the complement to mutable? above.</p>
      <p>Proposals:
medernach: <a href="/wiki/ImmutableData">ImmutableData</a>
racket: shared, immutable? ( http://docs.racket-lang.org/reference/shared.html)
Options: medernach, racket, no, undecided
Default: no
Preferences:
<a href="/ticket/111">#111</a> require equal? to return #t if eqv? does</p>
      <p>Currently equal? is strictly broader than eqv? except in the pathological case of comparing the same circular list with itself, for which eqv? returns true and equal? may loop infinitely. We could explicitly require equal? to check and return #t in this case, which most implementations do as a performance hack anyway.</p>
      <p>Options: yes, no, undecided
Default: no
Preferences:
WG1 - Exceptions</p>
      <p><a href="/ticket/18">#18</a> exception system</p>
      <p>R6RS provided a detailed exception system with support for raising and catching exceptions, using a hierarchy of exception types.</p>
      <p>Do we use this, or parts of it, or a new exception system? The r6rs option is just for the core exception handling.</p>
      <p>Proposals:
r6rs:  R6RS Exceptions - with-exception-handler, guard, raise, raise-continuable
cowan: <a href="/wiki/ExceptionHandlingCowan">ExceptionHandlingCowan</a>
Options: cowan, r6rs, wg2, none, undecided
Default: none
Preferences:
<a href="/ticket/19">#19</a> when to throw an error</p>
      <p>R5RS defines many things as &quot;is an error&quot; without any specification of what happens in that situation. R6RS goes to the opposite extreme and specifies as much as possible what exceptions are raised when.</p>
      <p>Taking into account the system provided by ticket <a href="/ticket/18">#18</a>, we need to come up with guidelines for when exceptions should be raised, and clarify which R5RS &quot;error&quot; situations should raise an exception or be left unspecified.</p>
      <p>R5RS specifies only 3 situations where an error is required to be signalled, leaving most situations unspecified as described in <a href="/wiki/ErrorSituations">ErrorSituations</a>.</p>
      <p>Options: r5rs, r6rs, undecided
Default: r5rs
Preferences:
WG1 - I/O</p>
      <p><a href="/ticket/28">#28</a> binary I/O ports</p>
      <p>Do we provide any binary input or output ports, and if so how do we construct them and operate on them? Can binary and textual operations be mixed on the different port types?</p>
      <p><a href="/wiki/PortsCowan">PortsCowan</a> provides binary port operations along with other extensions.</p>
      <p>R6RS provides an entirely new I/O system, as well as a separate R5RS-compatible I/O system.</p>
      <p>The withdrawn SRFI-91 provides yet another I/O system supporting binary ports.</p>
      <p>Note this item as well as <a href="/ticket/29">#29</a> and <a href="/ticket/31">#31</a> specify semi-orthogonal aspects of I/O systems which are typically specified together by individual proposals. If the same proposal doesn't win for all three, the aspects will be merged as needed.</p>
      <p>Proposals:
r6rs:  R6RS Port I/O
r6rs-simple:  R6RS Simple I/O
srfi-91:  SRFI-91
cowan: <a href="/wiki/PortsCowan">PortsCowan</a> (subset relevant to binary I/O)
Options: r6rs, r6rs-simple, srfi-91, cowan, none, undecided
Default: none
Preferences:
<a href="/ticket/29">#29</a> port encodings</p>
      <p>Do we support encoding and decoding text from ports with different character encoding systems? Different end-of-line conventions? Different normalizations? How are encoding errors handled?</p>
      <p>Proposals:
r6rs:  R6RS Port I/O
srfi-91:  SRFI-91
cowan: <a href="/wiki/PortsCowan">PortsCowan</a> (subset relevant to port encodings)
Options: r6rs, srfi-91, cowan, none, undecided
Default: none
Preferences:
<a href="/ticket/31">#31</a> custom ports</p>
      <p>Do we provide a mechanism for custom ports, on which for instance string ports could be created?</p>
      <p>R6RS as well as a number of Scheme implementations provide custom ports with various APIs.</p>
      <p>Proposals:
r6rs:  R6RS Port I/O
Options: r6rs, none
Default: none
Preferences:
WG1 - Libraries</p>
      <p><a href="/ticket/36">#36</a> hash-tables</p>
      <p>R6RS and SRFI-69 both provide hash-table interfaces. Do we provide either of these, or try to provide some primitives on which efficient hash-tables can be implemented?</p>
      <p>Options: r6rs, srfi-69, no, wg2, undecided
Default: no
Preferences:
<a href="/ticket/113">#113</a> directory contents</p>
      <p>We've decided to add file-exists? and delete-file, essential for a large class of scripts, but still have no way to get a list of files in a directory. Do we want to provide an interface to this?</p>
      <p>Proposals:
cowan: <a href="/wiki/DirectoryPortsCowan">DirectoryPortsCowan</a>
directory-files: return a list of all files in the dir
directory-streams:  SCSH directory stream interface
Options: directory-files, directory-streams, no, wg2, undecided
Default: no
Preferences:
WG1 - Macros</p>
      <p><a href="/ticket/48">#48</a> let-syntax</p>
      <p>let-syntax and letrec-syntax has known ambiguities in their behavior. We have the option of altering the semantics to correct this behavior, defining which behavior we intend, or removing let-syntax entirely. We could also leave this ambiguity unspecified.</p>
      <p>The question of whether or not to introduce a new lexical scope (i.e. whether internal defines are visible outside the let-syntax) is straightforward.</p>
      <p>If we don't introduce a new lexical scope, the question arises whether or not internal define-syntax forms are allowed and whether they apply to the body of the let-syntax, forms following the let-syntax, or both.</p>
      <p>If internal define-syntax applies to the body, we may also wish to specify what happens when said define-syntax redefines an identifier bound by the enclosing let-syntax. This varies by implementation and may be difficult for macro expanders to change, so is left unspecified in the proposals below.</p>
      <p>Proposals:
hsu: <a href="/wiki/LetSyntaxArcfide">LetSyntaxArcfide</a>
remove: remove both of these forms from the standard
lexical: introduces a new lexical contour
define: allows splicing define/begin
syntax: allows define-syntax
syntax-body: allows define-syntax only applying to the body
syntax-follows: allows define-syntax only applying to following forms
Options: hsu, remove, lexical, define, syntax, syntax-body, syntax-follows, unspecified, undecided
Default: unspecified
Preferences:
<a href="/ticket/97">#97</a> syntax-rules special literals</p>
      <p>... and with the result of <a href="/ticket/6">#6</a> also _ have special meaning in syntax-rules patterns, so they are not treated as pattern variables by default.</p>
      <p>However their behavior when used in the literals list of syntax-rules is ambiguous, and simply breaks in most implementations.</p>
      <p>Rather than breaking, it makes sense to go ahead and treat them as normal literals, overriding their special meanings.</p>
      <p>In particular, there are many existing R5RS macros which make use of _ in the literals and are thus broken outright by <a href="/ticket/6">#6</a>. Allowing them as literals fixes these macros.</p>
      <p>Options: literal, error, unspecified, undecided
Default: unspecified
Preferences:
WG1 - Modules</p>
      <p><a href="/ticket/3">#3</a> module naming convention</p>
      <p>We need a naming convention for the core modules and standard libraries of the new module system.</p>
      <p>In R5RS everything is effectively in a single module. R6RS provides a much more fine-grained breakdown of modules which could be retro-fitted to the bindings we include in our standard.</p>
      <p>John Cowan has proposed a number of module factorings in items <a href="/ticket/71">#71</a>, <a href="/ticket/72">#72</a>, <a href="/ticket/73">#73</a>, <a href="/ticket/74">#74</a>, <a href="/ticket/75">#75</a>, <a href="/ticket/76">#76</a>, <a href="/ticket/77">#77</a>, as well as an I/O module breakdown in <a href="/wiki/PortsCowan">PortsCowan</a>.</p>
      <p>Since the naming and breakdown must be internally consistent I'm grouping these into a single ballot item. Members desiring to put forth a new proposal should specify where all bindings belong, or specify a subset of the bindings and default the rest to some other proposal.</p>
      <p>Note some ballots specify explicitly whether or not the bindings in question are intended to be in a module or the core language. In these cases we still need to decide to which module they belong. Where specific votes contradict general factoring proposals, the specific vote wins.</p>
      <p>Proposals:
r5rs: one single module
r6rs:
cowan: <a href="/ticket/71">#71</a>, <a href="/ticket/72">#72</a>, <a href="/ticket/73">#73</a>, <a href="/ticket/74">#74</a>, <a href="/ticket/75">#75</a>, <a href="/ticket/76">#76</a>, <a href="/ticket/77">#77</a>
Options: r5rs, r6rs, cowan, undecided
Default: r5rs
Preferences:
WG1 - Numerics</p>
      <p><a href="/ticket/79">#79</a> rational-expt</p>
      <p>Often a rational-only exponentiation function is useful; that is, a rational number raised to an integer power. Should we add this procedure to the core so that exponentiation is available even if inexact rationals are not provided or not imported?</p>
      <p>Options: yes, no, module, wg2, undecided
Default: no
Preferences:
<a href="/ticket/81">#81</a> What numeric tower variants should be supported?</p>
      <p><a href="/wiki/NumericTower">NumericTower</a> lists a plausible set of ten from fixnums only to the full monty. Which ones should we allow an implementation to provide? R5RS requires only fixnums large enough to handle string and vector indexes, while R6RS requires the full numeric tower.</p>
      <p>Vote on the minimum level of support you want to require (implementations may of course still provide more than this). I've included only the most likely options below, write in other options if needed.</p>
      <p>Note quaternions are a fairly rare numeric type, known to be provided only by extensions to  scm and  chicken, and thus may be difficult for other implementations to support if required.</p>
      <p>Proposals:
r5rs: fixnum (inexact? may always be false)
inexact-only: inexact (exact? may be the same as integer?)
inexact: fixnum, inexact
rational: fixnum, inexact, rational
complex: fixnum, inexact, complex
r6rs: fixnum, inexact, rational, complex
quaternion: fixnum, inexact, rational, complex, quaternion
Options: r5rs, inexact-only, inexact, rational, complex, r6rs, quaternion, undecided
Default: r5rs
Preferences:
<a href="/ticket/100">#100</a> integral division</p>
      <p>R5RS provides quotient, modulo and remainder for integral division. R6RS extended this with div/mod and div0/mod0. A thorough analysis of possible division operations is provided in <a href="/wiki/DivisionRiastradh">DivisionRiastradh</a>, which includes a proposal for five separate division operator pairs. We need to choose which API we'll provide.</p>
      <p>Proposals:
riastradh: <a href="/wiki/DivisionRiastradh">DivisionRiastradh</a>
Options: r5rs, r6rs, riastradh, undecided
Default: r5rs
Preferences:
WG1 - Reader Syntax</p>
      <p><a href="/ticket/12">#12</a> symbol literal extensions</p>
      <p>In R5RS, symbols parsed as any sequence of valid symbol characters that does not begin with a character that can begin a number. The three exceptions +, - and ... are also provided. This allows parsing with only constant lookahead to determine type.</p>
      <p>R6RS added additional exceptions for symbols beginning with -&gt;, a common idiom, still allowing parsers to determine type with a constant lookahead.</p>
      <p>John Cowan proposes allowing anything that cannot be parsed as a number to be a valid symbol. This removes the special case exceptions, but may require arbitrary lookahead.</p>
      <p>Alex Shinn proposes symbols are any sequence of valid symbol characters that does not have a prefix which is a valid number. This removes the special case exceptions, allows constant lookahead, and allows extensions to number syntax.</p>
      <p>Proposals:
r5rs: symbols may not begin with -, except for - itself
r6rs: symbols may not begin with -[^&gt;]
cowan: symbols are anything that doesn't parse as a number
shinn: symbols may not begin with a number prefix
Options: r5rs, r6rs, cowan, shinn, undecided
Default: r5rs
Preferences:
<a href="/ticket/84">#84</a> Need to decide on a list of named character escapes ¶</p>
      <p>The WG has voted to have a list of character names.</p>
      <p>The list in R5RS and the longer list in R6RS are only informative. I suggest adopting the R6RS list and making it normative.</p>
      <p>Proposals:
r5rs: space, newline
r6rs:  R6RS Characters
shinn: space, tab, newline, return, escape, null, alarm, backspace
Options: r5rs, r6rs, shinn
Default: r5rs
Preferences:
<a href="/ticket/104">#104</a> list of mnemonic string escapes</p>
      <p>Similar to <a href="/ticket/84">#84</a>, we need to choose a specific list of mnemonic escapes like \n and \t to be recognized in strings.</p>
      <p>Proposals:
r5rs: \\, \&quot;
r6rs:  R6RS Strings
shinn: \\, \&quot;, \t, \n, \r, \e, \a, \b
Options: r5rs, r6rs, shinn
Default: r5rs
Preferences:
Download in other formats:
Plain Text</p></div></body></html>